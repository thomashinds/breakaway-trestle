/* automatically generated by rust-bindgen 0.64.0 */

#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub const MAX_NR_GATT_CLIENTS: u32 = 0;
pub const HCI_OUTGOING_PRE_BUFFER_SIZE: u32 = 4;
pub const HCI_ACL_PAYLOAD_SIZE: u32 = 259;
pub const HCI_ACL_CHUNK_SIZE_ALIGNMENT: u32 = 4;
pub const MAX_NR_HCI_CONNECTIONS: u32 = 1;
pub const MAX_NR_SM_LOOKUP_ENTRIES: u32 = 3;
pub const MAX_NR_WHITELIST_ENTRIES: u32 = 16;
pub const MAX_NR_LE_DEVICE_DB_ENTRIES: u32 = 16;
pub const MAX_NR_CONTROLLER_ACL_BUFFERS: u32 = 3;
pub const MAX_NR_CONTROLLER_SCO_PACKETS: u32 = 3;
pub const HCI_HOST_ACL_PACKET_LEN: u32 = 259;
pub const HCI_HOST_ACL_PACKET_NUM: u32 = 3;
pub const HCI_HOST_SCO_PACKET_LEN: u32 = 120;
pub const HCI_HOST_SCO_PACKET_NUM: u32 = 3;
pub const NVM_NUM_DEVICE_DB_ENTRIES: u32 = 16;
pub const NVM_NUM_LINK_KEYS: u32 = 16;
pub const MAX_ATT_DB_SIZE: u32 = 512;
pub const HCI_RESET_RESEND_TIMEOUT_MS: u32 = 1000;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const BD_ADDR_LEN: u32 = 6;
pub const LINK_KEY_LEN: u32 = 16;
pub const LINK_KEY_STR_LEN: u32 = 32;
pub const EXTENDED_INQUIRY_RESPONSE_DATA_LEN: u32 = 240;
pub const HCI_LINK_SUPERVISION_TIMEOUT_DEFAULT: u32 = 32000;
pub const HCI_COMMAND_DATA_PACKET: u32 = 1;
pub const HCI_ACL_DATA_PACKET: u32 = 2;
pub const HCI_SCO_DATA_PACKET: u32 = 3;
pub const HCI_EVENT_PACKET: u32 = 4;
pub const HCI_ISO_DATA_PACKET: u32 = 5;
pub const ERROR_CODE_SUCCESS: u32 = 0;
pub const ERROR_CODE_UNKNOWN_HCI_COMMAND: u32 = 1;
pub const ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER: u32 = 2;
pub const ERROR_CODE_HARDWARE_FAILURE: u32 = 3;
pub const ERROR_CODE_PAGE_TIMEOUT: u32 = 4;
pub const ERROR_CODE_AUTHENTICATION_FAILURE: u32 = 5;
pub const ERROR_CODE_PIN_OR_KEY_MISSING: u32 = 6;
pub const ERROR_CODE_MEMORY_CAPACITY_EXCEEDED: u32 = 7;
pub const ERROR_CODE_CONNECTION_TIMEOUT: u32 = 8;
pub const ERROR_CODE_CONNECTION_LIMIT_EXCEEDED: u32 = 9;
pub const ERROR_CODE_SYNCHRONOUS_CONNECTION_LIMIT_TO_A_DEVICE_EXCEEDED: u32 = 10;
pub const ERROR_CODE_ACL_CONNECTION_ALREADY_EXISTS: u32 = 11;
pub const ERROR_CODE_COMMAND_DISALLOWED: u32 = 12;
pub const ERROR_CODE_CONNECTION_REJECTED_DUE_TO_LIMITED_RESOURCES: u32 = 13;
pub const ERROR_CODE_CONNECTION_REJECTED_DUE_TO_SECURITY_REASONS: u32 = 14;
pub const ERROR_CODE_CONNECTION_REJECTED_DUE_TO_UNACCEPTABLE_BD_ADDR: u32 = 15;
pub const ERROR_CODE_CONNECTION_ACCEPT_TIMEOUT_EXCEEDED: u32 = 16;
pub const ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE: u32 = 17;
pub const ERROR_CODE_INVALID_HCI_COMMAND_PARAMETERS: u32 = 18;
pub const ERROR_CODE_REMOTE_USER_TERMINATED_CONNECTION: u32 = 19;
pub const ERROR_CODE_REMOTE_DEVICE_TERMINATED_CONNECTION_DUE_TO_LOW_RESOURCES: u32 = 20;
pub const ERROR_CODE_REMOTE_DEVICE_TERMINATED_CONNECTION_DUE_TO_POWER_OFF: u32 = 21;
pub const ERROR_CODE_CONNECTION_TERMINATED_BY_LOCAL_HOST: u32 = 22;
pub const ERROR_CODE_REPEATED_ATTEMPTS: u32 = 23;
pub const ERROR_CODE_PAIRING_NOT_ALLOWED: u32 = 24;
pub const ERROR_CODE_UNKNOWN_LMP_PDU: u32 = 25;
pub const ERROR_CODE_UNSUPPORTED_REMOTE_FEATURE_UNSUPPORTED_LMP_FEATURE: u32 = 26;
pub const ERROR_CODE_SCO_OFFSET_REJECTED: u32 = 27;
pub const ERROR_CODE_SCO_INTERVAL_REJECTED: u32 = 28;
pub const ERROR_CODE_SCO_AIR_MODE_REJECTED: u32 = 29;
pub const ERROR_CODE_INVALID_LMP_PARAMETERS_INVALID_LL_PARAMETERS: u32 = 30;
pub const ERROR_CODE_UNSPECIFIED_ERROR: u32 = 31;
pub const ERROR_CODE_UNSUPPORTED_LMP_PARAMETER_VALUE_UNSUPPORTED_LL_PARAMETER_VALUE: u32 = 32;
pub const ERROR_CODE_ROLE_CHANGE_NOT_ALLOWED: u32 = 33;
pub const ERROR_CODE_LMP_RESPONSE_TIMEOUT_LL_RESPONSE_TIMEOUT: u32 = 34;
pub const ERROR_CODE_LMP_ERROR_TRANSACTION_COLLISION: u32 = 35;
pub const ERROR_CODE_LMP_PDU_NOT_ALLOWED: u32 = 36;
pub const ERROR_CODE_ENCRYPTION_MODE_NOT_ACCEPTABLE: u32 = 37;
pub const ERROR_CODE_LINK_KEY_CANNOT_BE_CHANGED: u32 = 38;
pub const ERROR_CODE_REQUESTED_QOS_NOT_SUPPORTED: u32 = 39;
pub const ERROR_CODE_INSTANT_PASSED: u32 = 40;
pub const ERROR_CODE_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED: u32 = 41;
pub const ERROR_CODE_DIFFERENT_TRANSACTION_COLLISION: u32 = 42;
pub const ERROR_CODE_RESERVED: u32 = 43;
pub const ERROR_CODE_QOS_UNACCEPTABLE_PARAMETER: u32 = 44;
pub const ERROR_CODE_QOS_REJECTED: u32 = 45;
pub const ERROR_CODE_CHANNEL_CLASSIFICATION_NOT_SUPPORTED: u32 = 46;
pub const ERROR_CODE_INSUFFICIENT_SECURITY: u32 = 47;
pub const ERROR_CODE_PARAMETER_OUT_OF_MANDATORY_RANGE: u32 = 48;
pub const ERROR_CODE_ROLE_SWITCH_PENDING: u32 = 50;
pub const ERROR_CODE_RESERVED_SLOT_VIOLATION: u32 = 52;
pub const ERROR_CODE_ROLE_SWITCH_FAILED: u32 = 53;
pub const ERROR_CODE_EXTENDED_INQUIRY_RESPONSE_TOO_LARGE: u32 = 54;
pub const ERROR_CODE_SECURE_SIMPLE_PAIRING_NOT_SUPPORTED_BY_HOST: u32 = 55;
pub const ERROR_CODE_HOST_BUSY_PAIRING: u32 = 56;
pub const ERROR_CODE_CONNECTION_REJECTED_DUE_TO_NO_SUITABLE_CHANNEL_FOUND: u32 = 57;
pub const ERROR_CODE_CONTROLLER_BUSY: u32 = 58;
pub const ERROR_CODE_UNACCEPTABLE_CONNECTION_PARAMETERS: u32 = 59;
pub const ERROR_CODE_DIRECTED_ADVERTISING_TIMEOUT: u32 = 60;
pub const ERROR_CODE_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE: u32 = 61;
pub const ERROR_CODE_CONNECTION_FAILED_TO_BE_ESTABLISHED: u32 = 62;
pub const ERROR_CODE_MAC_CONNECTION_FAILED: u32 = 63;
pub const ERROR_CODE_COARSE_CLOCK_ADJUSTMENT_REJECTED_BUT_WILL_TRY_TO_ADJUST_USING_CLOCK_DRAGGING : u32 = 64 ;
pub const BTSTACK_CONNECTION_TO_BTDAEMON_FAILED: u32 = 80;
pub const BTSTACK_ACTIVATION_FAILED_SYSTEM_BLUETOOTH: u32 = 81;
pub const BTSTACK_ACTIVATION_POWERON_FAILED: u32 = 82;
pub const BTSTACK_ACTIVATION_FAILED_UNKNOWN: u32 = 83;
pub const BTSTACK_NOT_ACTIVATED: u32 = 84;
pub const BTSTACK_BUSY: u32 = 85;
pub const BTSTACK_MEMORY_ALLOC_FAILED: u32 = 86;
pub const BTSTACK_ACL_BUFFERS_FULL: u32 = 87;
pub const L2CAP_COMMAND_REJECT_REASON_COMMAND_NOT_UNDERSTOOD: u32 = 96;
pub const L2CAP_COMMAND_REJECT_REASON_SIGNALING_MTU_EXCEEDED: u32 = 97;
pub const L2CAP_COMMAND_REJECT_REASON_INVALID_CID_IN_REQUEST: u32 = 98;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_SUCCESSFUL: u32 = 99;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_PENDING: u32 = 100;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_REFUSED_PSM: u32 = 101;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_REFUSED_SECURITY: u32 = 102;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_REFUSED_RESOURCES: u32 = 103;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_ERTM_NOT_SUPPORTED: u32 = 104;
pub const L2CAP_CONNECTION_RESPONSE_RESULT_RTX_TIMEOUT: u32 = 105;
pub const L2CAP_CONNECTION_BASEBAND_DISCONNECT: u32 = 106;
pub const L2CAP_SERVICE_ALREADY_REGISTERED: u32 = 107;
pub const L2CAP_DATA_LEN_EXCEEDS_REMOTE_MTU: u32 = 108;
pub const L2CAP_SERVICE_DOES_NOT_EXIST: u32 = 109;
pub const L2CAP_LOCAL_CID_DOES_NOT_EXIST: u32 = 110;
pub const L2CAP_CONNECTION_RESPONSE_UNKNOWN_ERROR: u32 = 111;
pub const RFCOMM_MULTIPLEXER_STOPPED: u32 = 112;
pub const RFCOMM_CHANNEL_ALREADY_REGISTERED: u32 = 113;
pub const RFCOMM_NO_OUTGOING_CREDITS: u32 = 114;
pub const RFCOMM_AGGREGATE_FLOW_OFF: u32 = 115;
pub const RFCOMM_DATA_LEN_EXCEEDS_MTU: u32 = 116;
pub const HFP_REMOTE_REJECTS_AUDIO_CONNECTION: u32 = 127;
pub const SDP_HANDLE_ALREADY_REGISTERED: u32 = 128;
pub const SDP_QUERY_INCOMPLETE: u32 = 129;
pub const SDP_SERVICE_NOT_FOUND: u32 = 130;
pub const SDP_HANDLE_INVALID: u32 = 131;
pub const SDP_QUERY_BUSY: u32 = 132;
pub const ATT_HANDLE_VALUE_INDICATION_IN_PROGRESS: u32 = 144;
pub const ATT_HANDLE_VALUE_INDICATION_TIMEOUT: u32 = 145;
pub const ATT_HANDLE_VALUE_INDICATION_DISCONNECT: u32 = 146;
pub const GATT_CLIENT_NOT_CONNECTED: u32 = 147;
pub const GATT_CLIENT_BUSY: u32 = 148;
pub const GATT_CLIENT_IN_WRONG_STATE: u32 = 149;
pub const GATT_CLIENT_DIFFERENT_CONTEXT_FOR_ADDRESS_ALREADY_EXISTS: u32 = 150;
pub const GATT_CLIENT_VALUE_TOO_LONG: u32 = 151;
pub const GATT_CLIENT_CHARACTERISTIC_NOTIFICATION_NOT_SUPPORTED: u32 = 152;
pub const GATT_CLIENT_CHARACTERISTIC_INDICATION_NOT_SUPPORTED: u32 = 153;
pub const BNEP_SERVICE_ALREADY_REGISTERED: u32 = 160;
pub const BNEP_CHANNEL_NOT_CONNECTED: u32 = 161;
pub const BNEP_DATA_LEN_EXCEEDS_MTU: u32 = 162;
pub const OBEX_UNKNOWN_ERROR: u32 = 176;
pub const OBEX_CONNECT_FAILED: u32 = 177;
pub const OBEX_DISCONNECTED: u32 = 178;
pub const OBEX_NOT_FOUND: u32 = 179;
pub const OBEX_NOT_ACCEPTABLE: u32 = 180;
pub const OBEX_ABORTED: u32 = 181;
pub const MESH_ERROR_APPKEY_INDEX_INVALID: u32 = 208;
pub const AVRCP_BROWSING_ERROR_CODE_INVALID_COMMAND: u32 = 0;
pub const AVRCP_BROWSING_ERROR_CODE_INVALID_PARAMETER: u32 = 1;
pub const AVRCP_BROWSING_ERROR_CODE_SPECIFIED_PARAMETER_NOT_FOUND: u32 = 2;
pub const AVRCP_BROWSING_ERROR_CODE_INTERNAL_ERROR: u32 = 3;
pub const AVRCP_BROWSING_ERROR_CODE_SUCCESS: u32 = 4;
pub const AVRCP_BROWSING_ERROR_CODE_UID_CHANGED: u32 = 5;
pub const AVRCP_BROWSING_ERROR_CODE_RESERVED_06: u32 = 6;
pub const AVRCP_BROWSING_ERROR_CODE_INVALID_DIRECTION: u32 = 7;
pub const AVRCP_BROWSING_ERROR_CODE_NOT_A_DIRECTORY: u32 = 8;
pub const AVRCP_BROWSING_ERROR_CODE_DOES_NOT_EXIST: u32 = 9;
pub const AVRCP_BROWSING_ERROR_CODE_INVALID_SCOPE: u32 = 10;
pub const AVRCP_BROWSING_ERROR_CODE_RANGE_OUT_OF_BOUNDS: u32 = 11;
pub const AVRCP_BROWSING_ERROR_CODE_UID_IS_A_DIRECTORY: u32 = 12;
pub const AVRCP_BROWSING_ERROR_CODE_MEDIA_IN_USES: u32 = 13;
pub const AVRCP_BROWSING_ERROR_CODE_NOW_PLAYING_LIST_FULL: u32 = 14;
pub const AVRCP_BROWSING_ERROR_CODE_SEARCH_NOT_SUPPORTED: u32 = 15;
pub const AVRCP_BROWSING_ERROR_CODE_SEARCH_IN_PROGRESS: u32 = 16;
pub const AVRCP_BROWSING_ERROR_CODE_INVALID_PLAYER_ID: u32 = 17;
pub const AVRCP_BROWSING_ERROR_CODE_PLAYER_NOT_BROWSABLE: u32 = 18;
pub const AVRCP_BROWSING_ERROR_CODE_PLAYER_NOT_ADDRESSED: u32 = 19;
pub const AVRCP_BROWSING_ERROR_CODE_NO_VALID_SEARCH_RESULTS: u32 = 20;
pub const AVRCP_BROWSING_ERROR_CODE_NO_AVAILABLE_PLAYERS: u32 = 21;
pub const AVRCP_BROWSING_ERROR_CODE_ADDRESSED_PLAYER_CHANGED: u32 = 22;
pub const HCI_ACL_DM1_SIZE: u32 = 17;
pub const HCI_ACL_DH1_SIZE: u32 = 27;
pub const HCI_ACL_2DH1_SIZE: u32 = 54;
pub const HCI_ACL_3DH1_SIZE: u32 = 83;
pub const HCI_ACL_DM3_SIZE: u32 = 121;
pub const HCI_ACL_DH3_SIZE: u32 = 183;
pub const HCI_ACL_DM5_SIZE: u32 = 224;
pub const HCI_ACL_DH5_SIZE: u32 = 339;
pub const HCI_ACL_2DH3_SIZE: u32 = 367;
pub const HCI_ACL_3DH3_SIZE: u32 = 552;
pub const HCI_ACL_2DH5_SIZE: u32 = 679;
pub const HCI_ACL_3DH5_SIZE: u32 = 1021;
pub const HCI_SCO_HV1_SIZE: u32 = 10;
pub const HCI_SCO_HV2_SIZE: u32 = 20;
pub const HCI_SCO_HV3_SIZE: u32 = 30;
pub const HCI_SCO_EV3_SIZE: u32 = 30;
pub const HCI_SCO_EV4_SIZE: u32 = 120;
pub const HCI_SCO_EV5_SIZE: u32 = 180;
pub const HCI_SCO_2EV3_SIZE: u32 = 60;
pub const HCI_SCO_2EV5_SIZE: u32 = 360;
pub const HCI_SCO_3EV3_SIZE: u32 = 90;
pub const HCI_SCO_3EV5_SIZE: u32 = 540;
pub const LE_ADVERTISING_DATA_SIZE: u32 = 31;
pub const LE_EXTENDED_ADVERTISING_MAX_HANDLE: u32 = 239;
pub const LE_EXTENDED_ADVERTISING_MAX_CHUNK_LEN: u32 = 251;
pub const LE_ADVERTISING_PROPERTIES_CONNECTABLE: u32 = 1;
pub const LE_ADVERTISING_PROPERTIES_SCANNABLE: u32 = 2;
pub const LE_ADVERTISING_PROPERTIES_DIRECTED: u32 = 4;
pub const LE_ADVERTISING_PROPERTIES_HIGH_DUTY_CYCLE: u32 = 8;
pub const LE_ADVERTISING_PROPERTIES_LEGACY: u32 = 16;
pub const LE_ADVERTISING_PROPERTIES_ANONYMOUS: u32 = 32;
pub const LE_ADVERTISING_PROPERTIES_INCLUDE_TX_POWER: u32 = 64;
pub const SCO_PACKET_TYPES_NONE: u32 = 0;
pub const SCO_PACKET_TYPES_HV1: u32 = 1;
pub const SCO_PACKET_TYPES_HV2: u32 = 2;
pub const SCO_PACKET_TYPES_HV3: u32 = 4;
pub const SCO_PACKET_TYPES_EV3: u32 = 8;
pub const SCO_PACKET_TYPES_EV4: u32 = 16;
pub const SCO_PACKET_TYPES_EV5: u32 = 32;
pub const SCO_PACKET_TYPES_2EV3: u32 = 64;
pub const SCO_PACKET_TYPES_3EV3: u32 = 128;
pub const SCO_PACKET_TYPES_2EV5: u32 = 256;
pub const SCO_PACKET_TYPES_3EV5: u32 = 512;
pub const SCO_PACKET_TYPES_ALL: u32 = 1023;
pub const LM_LINK_POLICY_DISABLE_ALL_LM_MODES: u32 = 0;
pub const LM_LINK_POLICY_ENABLE_ROLE_SWITCH: u32 = 1;
pub const LM_LINK_POLICY_ENABLE_HOLD_MODE: u32 = 2;
pub const LM_LINK_POLICY_ENABLE_SNIFF_MODE: u32 = 4;
pub const ACL_CONNECTION_MODE_ACTIVE: u32 = 0;
pub const ACL_CONNECTION_MODE_HOLD: u32 = 1;
pub const ACL_CONNECTION_MODE_SNIFF: u32 = 2;
pub const GAP_IAC_GENERAL_INQUIRY: u32 = 10390323;
pub const GAP_IAC_LIMITED_INQUIRY: u32 = 10390272;
pub const SSP_IO_CAPABILITY_DISPLAY_ONLY: u32 = 0;
pub const SSP_IO_CAPABILITY_DISPLAY_YES_NO: u32 = 1;
pub const SSP_IO_CAPABILITY_KEYBOARD_ONLY: u32 = 2;
pub const SSP_IO_CAPABILITY_NO_INPUT_NO_OUTPUT: u32 = 3;
pub const SSP_IO_CAPABILITY_UNKNOWN: u32 = 255;
pub const SSP_IO_AUTHREQ_MITM_PROTECTION_NOT_REQUIRED_NO_BONDING: u32 = 0;
pub const SSP_IO_AUTHREQ_MITM_PROTECTION_REQUIRED_NO_BONDING: u32 = 1;
pub const SSP_IO_AUTHREQ_MITM_PROTECTION_NOT_REQUIRED_DEDICATED_BONDING: u32 = 2;
pub const SSP_IO_AUTHREQ_MITM_PROTECTION_REQUIRED_DEDICATED_BONDING: u32 = 3;
pub const SSP_IO_AUTHREQ_MITM_PROTECTION_NOT_REQUIRED_GENERAL_BONDING: u32 = 4;
pub const SSP_IO_AUTHREQ_MITM_PROTECTION_REQUIRED_GENERAL_BONDING: u32 = 5;
pub const OGF_LINK_CONTROL: u32 = 1;
pub const OGF_LINK_POLICY: u32 = 2;
pub const OGF_CONTROLLER_BASEBAND: u32 = 3;
pub const OGF_INFORMATIONAL_PARAMETERS: u32 = 4;
pub const OGF_STATUS_PARAMETERS: u32 = 5;
pub const OGF_TESTING: u32 = 6;
pub const OGF_LE_CONTROLLER: u32 = 8;
pub const OGF_VENDOR: u32 = 63;
pub const L2CAP_HEADER_SIZE: u32 = 4;
pub const L2CAP_MINIMAL_MTU: u32 = 48;
pub const L2CAP_DEFAULT_MTU: u32 = 672;
pub const L2CAP_LE_DEFAULT_MTU: u32 = 23;
pub const L2CAP_CID_SIGNALING: u32 = 1;
pub const L2CAP_CID_CONNECTIONLESS_CHANNEL: u32 = 2;
pub const L2CAP_CID_ATTRIBUTE_PROTOCOL: u32 = 4;
pub const L2CAP_CID_SIGNALING_LE: u32 = 5;
pub const L2CAP_CID_SECURITY_MANAGER_PROTOCOL: u32 = 6;
pub const L2CAP_CID_BR_EDR_SECURITY_MANAGER: u32 = 7;
pub const L2CAP_CONNECTION_RESULT_SUCCESS: u32 = 0;
pub const L2CAP_CONNECTION_RESULT_PENDING: u32 = 1;
pub const L2CAP_CONNECTION_RESULT_PSM_NOT_SUPPORTED: u32 = 2;
pub const L2CAP_CONNECTION_RESULT_SECURITY_BLOCK: u32 = 3;
pub const L2CAP_CONNECTION_RESULT_NO_RESOURCES_AVAILABLE: u32 = 4;
pub const L2CAP_CONNECTION_RESULT_INVALID_SOURCE_CID: u32 = 6;
pub const L2CAP_CONNECTION_RESULT_SOURCE_CID_ALREADY_ALLOCATED: u32 = 7;
pub const L2CAP_CBM_CONNECTION_RESULT_SUCCESS: u32 = 0;
pub const L2CAP_CBM_CONNECTION_RESULT_SPSM_NOT_SUPPORTED: u32 = 2;
pub const L2CAP_CBM_CONNECTION_RESULT_NO_RESOURCES_AVAILABLE: u32 = 4;
pub const L2CAP_CBM_CONNECTION_RESULT_INSUFFICIENT_AUTHENTICATION: u32 = 5;
pub const L2CAP_CBM_CONNECTION_RESULT_INSUFFICIENT_AUTHORIZATION: u32 = 6;
pub const L2CAP_CBM_CONNECTION_RESULT_ENCYRPTION_KEY_SIZE_TOO_SHORT: u32 = 7;
pub const L2CAP_CBM_CONNECTION_RESULT_INSUFFICIENT_ENCRYPTION: u32 = 8;
pub const L2CAP_CBM_CONNECTION_RESULT_INVALID_SOURCE_CID: u32 = 9;
pub const L2CAP_CBM_CONNECTION_RESULT_SOURCE_CID_ALREADY_ALLOCATED: u32 = 10;
pub const L2CAP_CBM_CONNECTION_RESULT_UNACCEPTABLE_PARAMETERS: u32 = 11;
pub const L2CAP_ECBM_MAX_CID_ARRAY_SIZE: u32 = 5;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_SUCCESS: u32 = 0;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_SPSM_NOT_SUPPORTED: u32 = 2;
pub const L2CAP_ECBM_CONNECTION_RESULT_SOME_REFUSED_INSUFFICIENT_RESOURCES_AVAILABLE: u32 = 4;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_INSUFFICIENT_AUTHENTICATION: u32 = 5;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_INSUFFICIENT_AUTHORIZATION: u32 = 6;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_ENCYRPTION_KEY_SIZE_TOO_SHORT: u32 = 7;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_INSUFFICIENT_ENCRYPTION: u32 = 8;
pub const L2CAP_ECBM_CONNECTION_RESULT_SOME_REFUSED_INVALID_SOURCE_CID: u32 = 9;
pub const L2CAP_ECBM_CONNECTION_RESULT_SOME_REFUSED_SOURCE_CID_ALREADY_ALOCATED: u32 = 10;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_UNACCEPTABLE_PARAMETERS: u32 = 11;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_REFUSED_INVALID_PARAMETERS: u32 = 12;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_PENDING_NO_FURTHER_INFORMATION: u32 = 13;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_PENDING_AUTHENTICATION: u32 = 14;
pub const L2CAP_ECBM_CONNECTION_RESULT_ALL_PENDING_AUTHORIZATION: u32 = 15;
pub const L2CAP_ECBM_RECONFIGURE_SUCCESS: u32 = 0;
pub const L2CAP_ECBM_RECONFIGURE_FAILED_MTU_REDUCTION_NOT_ALLOWED: u32 = 1;
pub const L2CAP_ECBM_RECONFIGURE_FAILED_MPS_REDUCTION_MULTIPLE_CHANNELS: u32 = 2;
pub const L2CAP_ECBM_RECONFIGURE_FAILED_DESTINATION_CID_INVALID: u32 = 3;
pub const L2CAP_ECBM_RECONFIGURE_FAILED_UNACCEPTABLE_PARAMETERS: u32 = 4;
pub const DEVICE_ID_VENDOR_ID_SOURCE_BLUETOOTH: u32 = 1;
pub const DEVICE_ID_VENDOR_ID_SOURCE_USB: u32 = 2;
pub const SDP_vCard_2_1: u32 = 1;
pub const SDP_vCard_3_0: u32 = 2;
pub const SDP_vCal_1_0: u32 = 3;
pub const SDP_iCal_2_0: u32 = 4;
pub const SDP_vNote: u32 = 5;
pub const SDP_vMessage: u32 = 6;
pub const SDP_OBEXFileTypeAny: u32 = 255;
pub const LINE_STATUS_NO_ERROR: u32 = 0;
pub const LINE_STATUS_OVERRUN_ERROR: u32 = 3;
pub const LINE_STATUS_PARITY_ERORR: u32 = 5;
pub const LINE_STATUS_FRAMING_ERROR: u32 = 9;
pub const MODEM_STATUS_FC: u32 = 2;
pub const MODEM_STATUS_RTC: u32 = 4;
pub const MODEM_STATUS_RTR: u32 = 8;
pub const MODEM_STATUS_IC: u32 = 64;
pub const MODEM_STATUS_DV: u32 = 128;
pub const RPN_FLOW_CONTROL_XONXOFF_ON_INPUT: u32 = 1;
pub const RPN_FLOW_CONTROL_XONXOFF_ON_OUTPUT: u32 = 2;
pub const RPN_FLOW_CONTROL_RTR_ON_INPUT: u32 = 4;
pub const RPN_FLOW_CONTROL_RTR_ON_OUTPUT: u32 = 8;
pub const RPN_FLOW_CONTROL_RTC_ON_INPUT: u32 = 16;
pub const RPN_FLOW_CONTROL_RTC_ON_OUTPUT: u32 = 32;
pub const RPN_PARAM_MASK_0_BAUD: u32 = 1;
pub const RPN_PARAM_MASK_0_DATA_BITS: u32 = 2;
pub const RPN_PARAM_MASK_0_STOP_BITS: u32 = 4;
pub const RPN_PARAM_MASK_0_PARITY: u32 = 8;
pub const RPN_PARAM_MASK_0_PARITY_TYPE: u32 = 16;
pub const RPN_PARAM_MASK_0_XON_CHAR: u32 = 32;
pub const RPN_PARAM_MASK_0_XOFF_CHAR: u32 = 64;
pub const RPN_PARAM_MASK_0_RESERVED: u32 = 128;
pub const RPN_PARAM_MASK_1_XONOFF_ON_INPUT: u32 = 1;
pub const RPN_PARAM_MASK_1_XONOFF_ON_OUTPUT: u32 = 2;
pub const RPN_PARAM_MASK_1_RTR_ON_INPUT: u32 = 4;
pub const RPN_PARAM_MASK_1_RTR_ON_OUTPUT: u32 = 8;
pub const RPN_PARAM_MASK_1_RTC_ON_INPUT: u32 = 16;
pub const RPN_PARAM_MASK_1_RTC_ON_OUTPUT: u32 = 32;
pub const RPN_PARAM_MASK_1_RESERVED_0: u32 = 64;
pub const RPN_PARAM_MASK_1_RESERVED_1: u32 = 128;
pub const ETHER_ADDR_LEN: u32 = 6;
pub const ETHERTYPE_VLAN: u32 = 33024;
pub const BNEP_MTU_MIN: u32 = 1691;
pub const ATT_DEFAULT_MTU: u32 = 23;
pub const ATT_ERROR_SUCCESS: u32 = 0;
pub const ATT_ERROR_INVALID_HANDLE: u32 = 1;
pub const ATT_ERROR_READ_NOT_PERMITTED: u32 = 2;
pub const ATT_ERROR_WRITE_NOT_PERMITTED: u32 = 3;
pub const ATT_ERROR_INVALID_PDU: u32 = 4;
pub const ATT_ERROR_INSUFFICIENT_AUTHENTICATION: u32 = 5;
pub const ATT_ERROR_REQUEST_NOT_SUPPORTED: u32 = 6;
pub const ATT_ERROR_INVALID_OFFSET: u32 = 7;
pub const ATT_ERROR_INSUFFICIENT_AUTHORIZATION: u32 = 8;
pub const ATT_ERROR_PREPARE_QUEUE_FULL: u32 = 9;
pub const ATT_ERROR_ATTRIBUTE_NOT_FOUND: u32 = 10;
pub const ATT_ERROR_ATTRIBUTE_NOT_LONG: u32 = 11;
pub const ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE: u32 = 12;
pub const ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH: u32 = 13;
pub const ATT_ERROR_UNLIKELY_ERROR: u32 = 14;
pub const ATT_ERROR_INSUFFICIENT_ENCRYPTION: u32 = 15;
pub const ATT_ERROR_UNSUPPORTED_GROUP_TYPE: u32 = 16;
pub const ATT_ERROR_INSUFFICIENT_RESOURCES: u32 = 17;
pub const ATT_ERROR_VALUE_NOT_ALLOWED: u32 = 19;
pub const ATT_ERROR_HCI_DISCONNECT_RECEIVED: u32 = 31;
pub const ATT_ERROR_BONDING_INFORMATION_MISSING: u32 = 112;
pub const ATT_ERROR_DATA_MISMATCH: u32 = 126;
pub const ATT_ERROR_TIMEOUT: u32 = 127;
pub const ATT_ERROR_WRITE_RESPONSE_PENDING: u32 = 256;
pub const ATT_ERROR_WRITE_REQUEST_REJECTED: u32 = 252;
pub const ATT_ERROR_CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR_IMPROPERLY_CONFIGURED: u32 = 253;
pub const ATT_ERROR_PROCEDURE_ALREADY_IN_PROGRESS: u32 = 254;
pub const ATT_ERROR_OUT_OF_RANGE: u32 = 255;
pub const CYCLING_POWER_ERROR_CODE_INAPPROPRIATE_CONNECTION_PARAMETERS: u32 = 128;
pub const CYCLING_POWER_ERROR_CODE_PROCEDURE_ALREADY_IN_PROGRESS: u32 = 254;
pub const CYCLING_POWER_ERROR_CODE_CCC_DESCRIPTOR_IMPROPERLY_CONFIGURED: u32 = 253;
pub const CYCLING_SPEED_AND_CADENCE_ERROR_CODE_PROCEDURE_ALREADY_IN_PROGRESS: u32 = 128;
pub const CYCLING_SPEED_AND_CADENCE_ERROR_CODE_CCC_DESCRIPTOR_IMPROPERLY_CONFIGURED: u32 = 129;
pub const ATT_PROPERTY_BROADCAST: u32 = 1;
pub const ATT_PROPERTY_READ: u32 = 2;
pub const ATT_PROPERTY_WRITE_WITHOUT_RESPONSE: u32 = 4;
pub const ATT_PROPERTY_WRITE: u32 = 8;
pub const ATT_PROPERTY_NOTIFY: u32 = 16;
pub const ATT_PROPERTY_INDICATE: u32 = 32;
pub const ATT_PROPERTY_AUTHENTICATED_SIGNED_WRITE: u32 = 64;
pub const ATT_PROPERTY_EXTENDED_PROPERTIES: u32 = 128;
pub const ATT_PROPERTY_DYNAMIC: u32 = 256;
pub const ATT_SECURITY_NONE: u32 = 0;
pub const ATT_SECURITY_ENCRYPTED: u32 = 1;
pub const ATT_SECURITY_AUTHENTICATED: u32 = 2;
pub const ATT_SECURITY_AUTHORIZED: u32 = 3;
pub const ATT_SECURITY_AUTHENTICATED_SC: u32 = 4;
pub const ATT_TRANSACTION_TIMEOUT_MS: u32 = 30000;
pub const ATT_TRANSACTION_MODE_NONE: u32 = 0;
pub const ATT_TRANSACTION_MODE_ACTIVE: u32 = 1;
pub const ATT_TRANSACTION_MODE_EXECUTE: u32 = 2;
pub const ATT_TRANSACTION_MODE_CANCEL: u32 = 3;
pub const ATT_TRANSACTION_MODE_VALIDATE: u32 = 4;
pub const GATT_PRIMARY_SERVICE_UUID: u32 = 10240;
pub const GATT_SECONDARY_SERVICE_UUID: u32 = 10241;
pub const GATT_INCLUDE_SERVICE_UUID: u32 = 10242;
pub const GATT_CHARACTERISTICS_UUID: u32 = 10243;
pub const GATT_CHARACTERISTIC_EXTENDED_PROPERTIES: u32 = 10496;
pub const GATT_CHARACTERISTIC_USER_DESCRIPTION: u32 = 10497;
pub const GATT_CLIENT_CHARACTERISTICS_CONFIGURATION: u32 = 10498;
pub const GATT_SERVER_CHARACTERISTICS_CONFIGURATION: u32 = 10499;
pub const GATT_CHARACTERISTIC_PRESENTATION_FORMAT: u32 = 10500;
pub const GATT_CHARACTERISTIC_AGGREGATE_FORMAT: u32 = 10501;
pub const GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NONE: u32 = 0;
pub const GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION: u32 = 1;
pub const GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_INDICATION: u32 = 2;
pub const GATT_CLIENT_ANY_CONNECTION: u32 = 65535;
pub const GATT_CLIENT_ANY_VALUE_HANDLE: u32 = 0;
pub const GAP_SERVICE_UUID: u32 = 6144;
pub const GAP_DEVICE_NAME_UUID: u32 = 10752;
pub const GAP_APPEARANCE_UUID: u32 = 10753;
pub const GAP_PERIPHERAL_PRIVACY_FLAG: u32 = 10754;
pub const GAP_RECONNECTION_ADDRESS_UUID: u32 = 10755;
pub const GAP_PERIPHERAL_PREFERRED_CONNECTION_PARAMETERS_UUID: u32 = 10756;
pub const GAP_SERVICE_CHANGED: u32 = 10757;
pub const SM_AUTHREQ_NO_BONDING: u32 = 0;
pub const SM_AUTHREQ_BONDING: u32 = 1;
pub const SM_AUTHREQ_MITM_PROTECTION: u32 = 4;
pub const SM_AUTHREQ_SECURE_CONNECTION: u32 = 8;
pub const SM_AUTHREQ_KEYPRESS: u32 = 16;
pub const SM_AUTHREQ_CT2: u32 = 32;
pub const SM_KEYDIST_ENC_KEY: u32 = 1;
pub const SM_KEYDIST_ID_KEY: u32 = 2;
pub const SM_KEYDIST_SIGN: u32 = 4;
pub const SM_KEYDIST_LINK_KEY: u32 = 8;
pub const SM_KEYDIST_FLAG_ENCRYPTION_INFORMATION: u32 = 1;
pub const SM_KEYDIST_FLAG_MASTER_IDENTIFICATION: u32 = 2;
pub const SM_KEYDIST_FLAG_IDENTITY_INFORMATION: u32 = 4;
pub const SM_KEYDIST_FLAG_IDENTITY_ADDRESS_INFORMATION: u32 = 8;
pub const SM_KEYDIST_FLAG_SIGNING_IDENTIFICATION: u32 = 16;
pub const SM_STK_GENERATION_METHOD_JUST_WORKS: u32 = 1;
pub const SM_STK_GENERATION_METHOD_OOB: u32 = 2;
pub const SM_STK_GENERATION_METHOD_PASSKEY: u32 = 4;
pub const SM_STK_GENERATION_METHOD_NUMERIC_COMPARISON: u32 = 8;
pub const SM_REASON_RESERVED: u32 = 0;
pub const SM_REASON_PASSKEY_ENTRY_FAILED: u32 = 1;
pub const SM_REASON_OOB_NOT_AVAILABLE: u32 = 2;
pub const SM_REASON_AUTHENTHICATION_REQUIREMENTS: u32 = 3;
pub const SM_REASON_CONFIRM_VALUE_FAILED: u32 = 4;
pub const SM_REASON_PAIRING_NOT_SUPPORTED: u32 = 5;
pub const SM_REASON_ENCRYPTION_KEY_SIZE: u32 = 6;
pub const SM_REASON_COMMAND_NOT_SUPPORTED: u32 = 7;
pub const SM_REASON_UNSPECIFIED_REASON: u32 = 8;
pub const SM_REASON_REPEATED_ATTEMPTS: u32 = 9;
pub const SM_REASON_INVALID_PARAMETERS: u32 = 10;
pub const SM_REASON_DHKEY_CHECK_FAILED: u32 = 11;
pub const SM_REASON_NUMERIC_COMPARISON_FAILED: u32 = 12;
pub const SM_REASON_BR_EDR_PAIRING_IN_PROGRESS: u32 = 13;
pub const SM_REASON_CROSS_TRANSPORT_KEY_DERIVATION_NOT_ALLOWED: u32 = 14;
pub const SM_REASON_KEY_REJECTED: u32 = 15;
pub const SM_KEYPRESS_PASSKEY_ENTRY_STARTED: u32 = 0;
pub const SM_KEYPRESS_PASSKEY_DIGIT_ENTERED: u32 = 1;
pub const SM_KEYPRESS_PASSKEY_DIGIT_ERASED: u32 = 2;
pub const SM_KEYPRESS_PASSKEY_CLEARED: u32 = 3;
pub const SM_KEYPRESS_PASSKEY_ENTRY_COMPLETED: u32 = 4;
pub const BLUETOOTH_PSM_SDP: u32 = 1;
pub const BLUETOOTH_PSM_RFCOMM: u32 = 3;
pub const BLUETOOTH_PSM_TCS_BIN: u32 = 5;
pub const BLUETOOTH_PSM_TCS_BIN_CORDLESS: u32 = 7;
pub const BLUETOOTH_PSM_BNEP: u32 = 15;
pub const BLUETOOTH_PSM_HID_CONTROL: u32 = 17;
pub const BLUETOOTH_PSM_HID_INTERRUPT: u32 = 19;
pub const BLUETOOTH_PSM_UPNP: u32 = 21;
pub const BLUETOOTH_PSM_AVCTP: u32 = 23;
pub const BLUETOOTH_PSM_AVDTP: u32 = 25;
pub const BLUETOOTH_PSM_AVCTP_BROWSING: u32 = 27;
pub const BLUETOOTH_PSM_UDI_C_PLANE: u32 = 29;
pub const BLUETOOTH_PSM_ATT: u32 = 31;
pub const BLUETOOTH_PSM_3DSP: u32 = 33;
pub const BLUETOOTH_PSM_LE_PSM_IPSP: u32 = 35;
pub const BLUETOOTH_PSM_OTS: u32 = 37;
pub const BLUETOOTH_COMPANY_ID_ERICSSON_TECHNOLOGY_LICENSING: u32 = 0;
pub const BLUETOOTH_COMPANY_ID_NOKIA_MOBILE_PHONES: u32 = 1;
pub const BLUETOOTH_COMPANY_ID_INTEL_CORP: u32 = 2;
pub const BLUETOOTH_COMPANY_ID_IBM_CORP: u32 = 3;
pub const BLUETOOTH_COMPANY_ID_TOSHIBA_CORP: u32 = 4;
pub const BLUETOOTH_COMPANY_ID_3COM: u32 = 5;
pub const BLUETOOTH_COMPANY_ID_MICROSOFT: u32 = 6;
pub const BLUETOOTH_COMPANY_ID_LUCENT: u32 = 7;
pub const BLUETOOTH_COMPANY_ID_MOTOROLA: u32 = 8;
pub const BLUETOOTH_COMPANY_ID_INFINEON_TECHNOLOGIES_AG: u32 = 9;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM_TECHNOLOGIES_INTERNATIONAL_LTD: u32 = 10;
pub const BLUETOOTH_COMPANY_ID_SILICON_WAVE: u32 = 11;
pub const BLUETOOTH_COMPANY_ID_DIGIANSWER_A_S: u32 = 12;
pub const BLUETOOTH_COMPANY_ID_TEXAS_INSTRUMENTS_INC: u32 = 13;
pub const BLUETOOTH_COMPANY_ID_PARTHUS_TECHNOLOGIES_INC: u32 = 14;
pub const BLUETOOTH_COMPANY_ID_BROADCOM_CORPORATION: u32 = 15;
pub const BLUETOOTH_COMPANY_ID_MITEL_SEMICONDUCTOR: u32 = 16;
pub const BLUETOOTH_COMPANY_ID_WIDCOMM_INC: u32 = 17;
pub const BLUETOOTH_COMPANY_ID_ZEEVO_INC: u32 = 18;
pub const BLUETOOTH_COMPANY_ID_ATMEL_CORPORATION: u32 = 19;
pub const BLUETOOTH_COMPANY_ID_MITSUBISHI_ELECTRIC_CORPORATION: u32 = 20;
pub const BLUETOOTH_COMPANY_ID_RTX_TELECOM_A_S: u32 = 21;
pub const BLUETOOTH_COMPANY_ID_KC_TECHNOLOGY_INC: u32 = 22;
pub const BLUETOOTH_COMPANY_ID_NEWLOGIC: u32 = 23;
pub const BLUETOOTH_COMPANY_ID_TRANSILICA_INC: u32 = 24;
pub const BLUETOOTH_COMPANY_ID_ROHDE_AND_SCHWARZ_GMBH_AND_CO_KG: u32 = 25;
pub const BLUETOOTH_COMPANY_ID_TTPCOM_LIMITED: u32 = 26;
pub const BLUETOOTH_COMPANY_ID_SIGNIA_TECHNOLOGIES_INC: u32 = 27;
pub const BLUETOOTH_COMPANY_ID_CONEXANT_SYSTEMS_INC: u32 = 28;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM: u32 = 29;
pub const BLUETOOTH_COMPANY_ID_INVENTEL: u32 = 30;
pub const BLUETOOTH_COMPANY_ID_AVM_BERLIN: u32 = 31;
pub const BLUETOOTH_COMPANY_ID_BANDSPEED_INC: u32 = 32;
pub const BLUETOOTH_COMPANY_ID_MANSELLA_LTD: u32 = 33;
pub const BLUETOOTH_COMPANY_ID_NEC_CORPORATION: u32 = 34;
pub const BLUETOOTH_COMPANY_ID_WAVEPLUS_TECHNOLOGY_CO_LTD: u32 = 35;
pub const BLUETOOTH_COMPANY_ID_ALCATEL: u32 = 36;
pub const BLUETOOTH_COMPANY_ID_NXP_SEMICONDUCTORS: u32 = 37;
pub const BLUETOOTH_COMPANY_ID_C_TECHNOLOGIES: u32 = 38;
pub const BLUETOOTH_COMPANY_ID_OPEN_INTERFACE: u32 = 39;
pub const BLUETOOTH_COMPANY_ID_R_F_MICRO_DEVICES: u32 = 40;
pub const BLUETOOTH_COMPANY_ID_HITACHI_LTD: u32 = 41;
pub const BLUETOOTH_COMPANY_ID_SYMBOL_TECHNOLOGIES_INC: u32 = 42;
pub const BLUETOOTH_COMPANY_ID_TENOVIS: u32 = 43;
pub const BLUETOOTH_COMPANY_ID_MACRONIX_INTERNATIONAL_CO_LTD: u32 = 44;
pub const BLUETOOTH_COMPANY_ID_GCT_SEMICONDUCTOR: u32 = 45;
pub const BLUETOOTH_COMPANY_ID_NORWOOD_SYSTEMS: u32 = 46;
pub const BLUETOOTH_COMPANY_ID_MEWTEL_TECHNOLOGY_INC: u32 = 47;
pub const BLUETOOTH_COMPANY_ID_ST_MICROELECTRONICS: u32 = 48;
pub const BLUETOOTH_COMPANY_ID_SYNOPSYS_INC: u32 = 49;
pub const BLUETOOTH_COMPANY_ID_RED_M_LTD: u32 = 50;
pub const BLUETOOTH_COMPANY_ID_COMMIL_LTD: u32 = 51;
pub const BLUETOOTH_COMPANY_ID_COMPUTER_ACCESS_TECHNOLOGY_CORPORATION: u32 = 52;
pub const BLUETOOTH_COMPANY_ID_ECLIPSE_SL: u32 = 53;
pub const BLUETOOTH_COMPANY_ID_RENESAS_ELECTRONICS_CORPORATION: u32 = 54;
pub const BLUETOOTH_COMPANY_ID_MOBILIAN_CORPORATION: u32 = 55;
pub const BLUETOOTH_COMPANY_ID_SYNTRONIX_CORPORATION: u32 = 56;
pub const BLUETOOTH_COMPANY_ID_INTEGRATED_SYSTEM_SOLUTION_CORP: u32 = 57;
pub const BLUETOOTH_COMPANY_ID_PANASONIC_CORPORATION: u32 = 58;
pub const BLUETOOTH_COMPANY_ID_GENNUM_CORPORATION: u32 = 59;
pub const BLUETOOTH_COMPANY_ID_BLACKBERRY_LIMITED: u32 = 60;
pub const BLUETOOTH_COMPANY_ID_IPEXTREME_INC: u32 = 61;
pub const BLUETOOTH_COMPANY_ID_SYSTEMS_AND_CHIPS_INC: u32 = 62;
pub const BLUETOOTH_COMPANY_ID_BLUETOOTH_SIG_INC: u32 = 63;
pub const BLUETOOTH_COMPANY_ID_SEIKO_EPSON_CORPORATION: u32 = 64;
pub const BLUETOOTH_COMPANY_ID_INTEGRATED_SILICON_SOLUTION_TAIWAN_INC: u32 = 65;
pub const BLUETOOTH_COMPANY_ID_CONWISE_TECHNOLOGY_CORPORATION_LTD: u32 = 66;
pub const BLUETOOTH_COMPANY_ID_PARROT_AUTOMOTIVE_SAS: u32 = 67;
pub const BLUETOOTH_COMPANY_ID_SOCKET_MOBILE: u32 = 68;
pub const BLUETOOTH_COMPANY_ID_ATHEROS_COMMUNICATIONS_INC: u32 = 69;
pub const BLUETOOTH_COMPANY_ID_MEDIATEK_INC: u32 = 70;
pub const BLUETOOTH_COMPANY_ID_BLUEGIGA: u32 = 71;
pub const BLUETOOTH_COMPANY_ID_MARVELL_TECHNOLOGY_GROUP_LTD: u32 = 72;
pub const BLUETOOTH_COMPANY_ID_3DSP_CORPORATION: u32 = 73;
pub const BLUETOOTH_COMPANY_ID_ACCEL_SEMICONDUCTOR_LTD: u32 = 74;
pub const BLUETOOTH_COMPANY_ID_CONTINENTAL_AUTOMOTIVE_SYSTEMS: u32 = 75;
pub const BLUETOOTH_COMPANY_ID_APPLE_INC: u32 = 76;
pub const BLUETOOTH_COMPANY_ID_STACCATO_COMMUNICATIONS_INC: u32 = 77;
pub const BLUETOOTH_COMPANY_ID_AVAGO_TECHNOLOGIES: u32 = 78;
pub const BLUETOOTH_COMPANY_ID_APT_LTD: u32 = 79;
pub const BLUETOOTH_COMPANY_ID_SIRF_TECHNOLOGY_INC: u32 = 80;
pub const BLUETOOTH_COMPANY_ID_TZERO_TECHNOLOGIES_INC: u32 = 81;
pub const BLUETOOTH_COMPANY_ID_JANDM_CORPORATION: u32 = 82;
pub const BLUETOOTH_COMPANY_ID_FREE2MOVE_AB: u32 = 83;
pub const BLUETOOTH_COMPANY_ID_3DIJOY_CORPORATION: u32 = 84;
pub const BLUETOOTH_COMPANY_ID_PLANTRONICS_INC: u32 = 85;
pub const BLUETOOTH_COMPANY_ID_SONY_ERICSSON_MOBILE_COMMUNICATIONS: u32 = 86;
pub const BLUETOOTH_COMPANY_ID_HARMAN_INTERNATIONAL_INDUSTRIES_INC: u32 = 87;
pub const BLUETOOTH_COMPANY_ID_VIZIO_INC: u32 = 88;
pub const BLUETOOTH_COMPANY_ID_NORDIC_SEMICONDUCTOR_ASA: u32 = 89;
pub const BLUETOOTH_COMPANY_ID_EM_MICROELECTRONIC_MARIN_SA: u32 = 90;
pub const BLUETOOTH_COMPANY_ID_RALINK_TECHNOLOGY_CORPORATION: u32 = 91;
pub const BLUETOOTH_COMPANY_ID_BELKIN_INTERNATIONAL_INC: u32 = 92;
pub const BLUETOOTH_COMPANY_ID_REALTEK_SEMICONDUCTOR_CORPORATION: u32 = 93;
pub const BLUETOOTH_COMPANY_ID_STONESTREET_ONE_LLC: u32 = 94;
pub const BLUETOOTH_COMPANY_ID_WICENTRIC_INC: u32 = 95;
pub const BLUETOOTH_COMPANY_ID_RIVIERAWAVES_SAS: u32 = 96;
pub const BLUETOOTH_COMPANY_ID_RDA_MICROELECTRONICS: u32 = 97;
pub const BLUETOOTH_COMPANY_ID_GIBSON_GUITARS: u32 = 98;
pub const BLUETOOTH_COMPANY_ID_MICOMMAND_INC: u32 = 99;
pub const BLUETOOTH_COMPANY_ID_BAND_XI_INTERNATIONAL_LLC: u32 = 100;
pub const BLUETOOTH_COMPANY_ID_HP_INC: u32 = 101;
pub const BLUETOOTH_COMPANY_ID_9SOLUTIONS_OY: u32 = 102;
pub const BLUETOOTH_COMPANY_ID_GN_NETCOM_A_S: u32 = 103;
pub const BLUETOOTH_COMPANY_ID_GENERAL_MOTORS: u32 = 104;
pub const BLUETOOTH_COMPANY_ID_AANDD_ENGINEERING_INC: u32 = 105;
pub const BLUETOOTH_COMPANY_ID_MINDTREE_LTD: u32 = 106;
pub const BLUETOOTH_COMPANY_ID_POLAR_ELECTRO_OY: u32 = 107;
pub const BLUETOOTH_COMPANY_ID_BEAUTIFUL_ENTERPRISE_CO_LTD: u32 = 108;
pub const BLUETOOTH_COMPANY_ID_BRIARTEK_INC: u32 = 109;
pub const BLUETOOTH_COMPANY_ID_SUMMIT_DATA_COMMUNICATIONS_INC: u32 = 110;
pub const BLUETOOTH_COMPANY_ID_SOUND_ID: u32 = 111;
pub const BLUETOOTH_COMPANY_ID_MONSTER_LLC: u32 = 112;
pub const BLUETOOTH_COMPANY_ID_CONNECTBLUE_AB: u32 = 113;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_SUPER_SMART_ELECTRONICS_CO_LTD: u32 = 114;
pub const BLUETOOTH_COMPANY_ID_GROUP_SENSE_LTD: u32 = 115;
pub const BLUETOOTH_COMPANY_ID_ZOMM_LLC: u32 = 116;
pub const BLUETOOTH_COMPANY_ID_SAMSUNG_ELECTRONICS_CO_LTD: u32 = 117;
pub const BLUETOOTH_COMPANY_ID_CREATIVE_TECHNOLOGY_LTD: u32 = 118;
pub const BLUETOOTH_COMPANY_ID_LAIRD_TECHNOLOGIES: u32 = 119;
pub const BLUETOOTH_COMPANY_ID_NIKE_INC: u32 = 120;
pub const BLUETOOTH_COMPANY_ID_LESSWIRE_AG: u32 = 121;
pub const BLUETOOTH_COMPANY_ID_MSTAR_SEMICONDUCTOR_INC: u32 = 122;
pub const BLUETOOTH_COMPANY_ID_HANLYNN_TECHNOLOGIES: u32 = 123;
pub const BLUETOOTH_COMPANY_ID_A_AND_R_CAMBRIDGE: u32 = 124;
pub const BLUETOOTH_COMPANY_ID_SEERS_TECHNOLOGY_CO_LTD: u32 = 125;
pub const BLUETOOTH_COMPANY_ID_SPORTS_TRACKING_TECHNOLOGIES_LTD: u32 = 126;
pub const BLUETOOTH_COMPANY_ID_AUTONET_MOBILE: u32 = 127;
pub const BLUETOOTH_COMPANY_ID_DELORME_PUBLISHING_COMPANY_INC: u32 = 128;
pub const BLUETOOTH_COMPANY_ID_WUXI_VIMICRO: u32 = 129;
pub const BLUETOOTH_COMPANY_ID_SENNHEISER_COMMUNICATIONS_A_S: u32 = 130;
pub const BLUETOOTH_COMPANY_ID_TIMEKEEPING_SYSTEMS_INC: u32 = 131;
pub const BLUETOOTH_COMPANY_ID_LUDUS_HELSINKI_LTD: u32 = 132;
pub const BLUETOOTH_COMPANY_ID_BLUERADIOS_INC: u32 = 133;
pub const BLUETOOTH_COMPANY_ID_EQUINUX_AG: u32 = 134;
pub const BLUETOOTH_COMPANY_ID_GARMIN_INTERNATIONAL_INC: u32 = 135;
pub const BLUETOOTH_COMPANY_ID_ECOTEST: u32 = 136;
pub const BLUETOOTH_COMPANY_ID_GN_RESOUND_A_S: u32 = 137;
pub const BLUETOOTH_COMPANY_ID_JAWBONE: u32 = 138;
pub const BLUETOOTH_COMPANY_ID_TOPCON_POSITIONING_SYSTEMS_LLC: u32 = 139;
pub const BLUETOOTH_COMPANY_ID_GIMBAL_INC: u32 = 140;
pub const BLUETOOTH_COMPANY_ID_ZSCAN_SOFTWARE: u32 = 141;
pub const BLUETOOTH_COMPANY_ID_QUINTIC_CORP: u32 = 142;
pub const BLUETOOTH_COMPANY_ID_TELIT_WIRELESS_SOLUTIONS_GMBH: u32 = 143;
pub const BLUETOOTH_COMPANY_ID_FUNAI_ELECTRIC_CO_LTD: u32 = 144;
pub const BLUETOOTH_COMPANY_ID_ADVANCED_PANMOBIL_SYSTEMS_GMBH_AND_CO_KG: u32 = 145;
pub const BLUETOOTH_COMPANY_ID_THINKOPTICS_INC: u32 = 146;
pub const BLUETOOTH_COMPANY_ID_UNIVERSAL_ELECTRONICS_INC: u32 = 147;
pub const BLUETOOTH_COMPANY_ID_AIROHA_TECHNOLOGY_CORP: u32 = 148;
pub const BLUETOOTH_COMPANY_ID_NEC_LIGHTING_LTD: u32 = 149;
pub const BLUETOOTH_COMPANY_ID_ODM_TECHNOLOGY_INC: u32 = 150;
pub const BLUETOOTH_COMPANY_ID_CONNECTEDEVICE_LTD: u32 = 151;
pub const BLUETOOTH_COMPANY_ID_ZERO1TV_GMBH: u32 = 152;
pub const BLUETOOTH_COMPANY_ID_ITECH_DYNAMIC_GLOBAL_DISTRIBUTION_LTD: u32 = 153;
pub const BLUETOOTH_COMPANY_ID_ALPWISE: u32 = 154;
pub const BLUETOOTH_COMPANY_ID_JIANGSU_TOPPOWER_AUTOMOTIVE_ELECTRONICS_CO_LTD: u32 = 155;
pub const BLUETOOTH_COMPANY_ID_COLORFY_INC: u32 = 156;
pub const BLUETOOTH_COMPANY_ID_GEOFORCE_INC: u32 = 157;
pub const BLUETOOTH_COMPANY_ID_BOSE_CORPORATION: u32 = 158;
pub const BLUETOOTH_COMPANY_ID_SUUNTO_OY: u32 = 159;
pub const BLUETOOTH_COMPANY_ID_KENSINGTON_COMPUTER_PRODUCTS_GROUP: u32 = 160;
pub const BLUETOOTH_COMPANY_ID_SR_MEDIZINELEKTRONIK: u32 = 161;
pub const BLUETOOTH_COMPANY_ID_VERTU_CORPORATION_LIMITED: u32 = 162;
pub const BLUETOOTH_COMPANY_ID_META_WATCH_LTD: u32 = 163;
pub const BLUETOOTH_COMPANY_ID_LINAK_A_S: u32 = 164;
pub const BLUETOOTH_COMPANY_ID_OTL_DYNAMICS_LLC: u32 = 165;
pub const BLUETOOTH_COMPANY_ID_PANDA_OCEAN_INC: u32 = 166;
pub const BLUETOOTH_COMPANY_ID_VISTEON_CORPORATION: u32 = 167;
pub const BLUETOOTH_COMPANY_ID_ARP_DEVICES_LIMITED: u32 = 168;
pub const BLUETOOTH_COMPANY_ID_MARELLI_EUROPE_SPA: u32 = 169;
pub const BLUETOOTH_COMPANY_ID_CAEN_RFID_SRL: u32 = 170;
pub const BLUETOOTH_COMPANY_ID_INGENIEUR_SYSTEMGRUPPE_ZAHN_GMBH: u32 = 171;
pub const BLUETOOTH_COMPANY_ID_GREEN_THROTTLE_GAMES: u32 = 172;
pub const BLUETOOTH_COMPANY_ID_PETER_SYSTEMTECHNIK_GMBH: u32 = 173;
pub const BLUETOOTH_COMPANY_ID_OMEGAWAVE_OY: u32 = 174;
pub const BLUETOOTH_COMPANY_ID_CINETIX: u32 = 175;
pub const BLUETOOTH_COMPANY_ID_PASSIF_SEMICONDUCTOR_CORP: u32 = 176;
pub const BLUETOOTH_COMPANY_ID_SARIS_CYCLING_GROUP_INC: u32 = 177;
pub const BLUETOOTH_COMPANY_ID_BEKEY_A_S: u32 = 178;
pub const BLUETOOTH_COMPANY_ID_CLARINOX_TECHNOLOGIES_PTY_LTD: u32 = 179;
pub const BLUETOOTH_COMPANY_ID_BDE_TECHNOLOGY_CO_LTD: u32 = 180;
pub const BLUETOOTH_COMPANY_ID_SWIRL_NETWORKS: u32 = 181;
pub const BLUETOOTH_COMPANY_ID_MESO_INTERNATIONAL: u32 = 182;
pub const BLUETOOTH_COMPANY_ID_TRELAB_LTD: u32 = 183;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM_INNOVATION_CENTER_INC: u32 = 184;
pub const BLUETOOTH_COMPANY_ID_JOHNSON_CONTROLS_INC: u32 = 185;
pub const BLUETOOTH_COMPANY_ID_STARKEY_LABORATORIES_INC: u32 = 186;
pub const BLUETOOTH_COMPANY_ID_S_POWER_ELECTRONICS_LIMITED: u32 = 187;
pub const BLUETOOTH_COMPANY_ID_ACE_SENSOR_INC: u32 = 188;
pub const BLUETOOTH_COMPANY_ID_APLIX_CORPORATION: u32 = 189;
pub const BLUETOOTH_COMPANY_ID_AAMP_OF_AMERICA: u32 = 190;
pub const BLUETOOTH_COMPANY_ID_STALMART_TECHNOLOGY_LIMITED: u32 = 191;
pub const BLUETOOTH_COMPANY_ID_AMICCOM_ELECTRONICS_CORPORATION: u32 = 192;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_EXCELSECU_DATA_TECHNOLOGY_COLTD: u32 = 193;
pub const BLUETOOTH_COMPANY_ID_GENEQ_INC: u32 = 194;
pub const BLUETOOTH_COMPANY_ID_ADIDAS_AG: u32 = 195;
pub const BLUETOOTH_COMPANY_ID_LG_ELECTRONICS: u32 = 196;
pub const BLUETOOTH_COMPANY_ID_ONSET_COMPUTER_CORPORATION: u32 = 197;
pub const BLUETOOTH_COMPANY_ID_SELFLY_BV: u32 = 198;
pub const BLUETOOTH_COMPANY_ID_QUUPPA_OY: u32 = 199;
pub const BLUETOOTH_COMPANY_ID_GELO_INC: u32 = 200;
pub const BLUETOOTH_COMPANY_ID_EVLUMA: u32 = 201;
pub const BLUETOOTH_COMPANY_ID_MC10: u32 = 202;
pub const BLUETOOTH_COMPANY_ID_BINAURIC_SE: u32 = 203;
pub const BLUETOOTH_COMPANY_ID_BEATS_ELECTRONICS: u32 = 204;
pub const BLUETOOTH_COMPANY_ID_MICROCHIP_TECHNOLOGY_INC: u32 = 205;
pub const BLUETOOTH_COMPANY_ID_ELGATO_SYSTEMS_GMBH: u32 = 206;
pub const BLUETOOTH_COMPANY_ID_ARCHOS_SA: u32 = 207;
pub const BLUETOOTH_COMPANY_ID_DEXCOM_INC: u32 = 208;
pub const BLUETOOTH_COMPANY_ID_POLAR_ELECTRO_EUROPE_BV: u32 = 209;
pub const BLUETOOTH_COMPANY_ID_DIALOG_SEMICONDUCTOR_BV: u32 = 210;
pub const BLUETOOTH_COMPANY_ID_TAIXINGBANG_TECHNOLOGY_CO_LTD: u32 = 211;
pub const BLUETOOTH_COMPANY_ID_KAWANTECH: u32 = 212;
pub const BLUETOOTH_COMPANY_ID_AUSTCO_COMMUNICATION_SYSTEMS: u32 = 213;
pub const BLUETOOTH_COMPANY_ID_TIMEX_GROUP_USA_INC: u32 = 214;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM_TECHNOLOGIES_INC: u32 = 215;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM_CONNECTED_EXPERIENCES_INC: u32 = 216;
pub const BLUETOOTH_COMPANY_ID_VOYETRA_TURTLE_BEACH: u32 = 217;
pub const BLUETOOTH_COMPANY_ID_TXTR_GMBH: u32 = 218;
pub const BLUETOOTH_COMPANY_ID_BIOSENTRONICS: u32 = 219;
pub const BLUETOOTH_COMPANY_ID_PROCTER_AND_GAMBLE: u32 = 220;
pub const BLUETOOTH_COMPANY_ID_HOSIDEN_CORPORATION: u32 = 221;
pub const BLUETOOTH_COMPANY_ID_MUZIK_LLC: u32 = 222;
pub const BLUETOOTH_COMPANY_ID_MISFIT_WEARABLES_CORP: u32 = 223;
pub const BLUETOOTH_COMPANY_ID_GOOGLE: u32 = 224;
pub const BLUETOOTH_COMPANY_ID_DANLERS_LTD: u32 = 225;
pub const BLUETOOTH_COMPANY_ID_SEMILINK_INC: u32 = 226;
pub const BLUETOOTH_COMPANY_ID_INMUSIC_BRANDS_INC: u32 = 227;
pub const BLUETOOTH_COMPANY_ID_LAIRD_CONNECTIVITY_INC_FORMERLY_LS_RESEARCH_INC: u32 = 228;
pub const BLUETOOTH_COMPANY_ID_EDEN_SOFTWARE_CONSULTANTS_LTD: u32 = 229;
pub const BLUETOOTH_COMPANY_ID_FRESHTEMP: u32 = 230;
pub const BLUETOOTH_COMPANY_ID_KS_TECHNOLOGIES: u32 = 231;
pub const BLUETOOTH_COMPANY_ID_ACTS_TECHNOLOGIES: u32 = 232;
pub const BLUETOOTH_COMPANY_ID_VTRACK_SYSTEMS: u32 = 233;
pub const BLUETOOTH_COMPANY_ID_NIELSEN_KELLERMAN_COMPANY: u32 = 234;
pub const BLUETOOTH_COMPANY_ID_SERVER_TECHNOLOGY_INC: u32 = 235;
pub const BLUETOOTH_COMPANY_ID_BIORESEARCH_ASSOCIATES: u32 = 236;
pub const BLUETOOTH_COMPANY_ID_JOLLY_LOGIC_LLC: u32 = 237;
pub const BLUETOOTH_COMPANY_ID_ABOVE_AVERAGE_OUTCOMES_INC: u32 = 238;
pub const BLUETOOTH_COMPANY_ID_BITSPLITTERS_GMBH: u32 = 239;
pub const BLUETOOTH_COMPANY_ID_PAYPAL_INC: u32 = 240;
pub const BLUETOOTH_COMPANY_ID_WITRON_TECHNOLOGY_LIMITED: u32 = 241;
pub const BLUETOOTH_COMPANY_ID_MORSE_PROJECT_INC: u32 = 242;
pub const BLUETOOTH_COMPANY_ID_KENT_DISPLAYS_INC: u32 = 243;
pub const BLUETOOTH_COMPANY_ID_NAUTILUS_INC: u32 = 244;
pub const BLUETOOTH_COMPANY_ID_SMARTIFIER_OY: u32 = 245;
pub const BLUETOOTH_COMPANY_ID_ELCOMETER_LIMITED: u32 = 246;
pub const BLUETOOTH_COMPANY_ID_VSN_TECHNOLOGIES_INC: u32 = 247;
pub const BLUETOOTH_COMPANY_ID_ACEUNI_CORP_LTD: u32 = 248;
pub const BLUETOOTH_COMPANY_ID_STICKNFIND: u32 = 249;
pub const BLUETOOTH_COMPANY_ID_CRYSTAL_CODE_AB: u32 = 250;
pub const BLUETOOTH_COMPANY_ID_KOUKAAM_AS: u32 = 251;
pub const BLUETOOTH_COMPANY_ID_DELPHI_CORPORATION: u32 = 252;
pub const BLUETOOTH_COMPANY_ID_VALENCETECH_LIMITED: u32 = 253;
pub const BLUETOOTH_COMPANY_ID_STANLEY_BLACK_AND_DECKER: u32 = 254;
pub const BLUETOOTH_COMPANY_ID_TYPO_PRODUCTS_LLC: u32 = 255;
pub const BLUETOOTH_COMPANY_ID_TOMTOM_INTERNATIONAL_BV: u32 = 256;
pub const BLUETOOTH_COMPANY_ID_FUGOO_INC: u32 = 257;
pub const BLUETOOTH_COMPANY_ID_KEISER_CORPORATION: u32 = 258;
pub const BLUETOOTH_COMPANY_ID_BANG_AND_OLUFSEN_A_S: u32 = 259;
pub const BLUETOOTH_COMPANY_ID_PLUS_LOCATION_SYSTEMS_PTY_LTD: u32 = 260;
pub const BLUETOOTH_COMPANY_ID_UBIQUITOUS_COMPUTING_TECHNOLOGY_CORPORATION: u32 = 261;
pub const BLUETOOTH_COMPANY_ID_INNOVATIVE_YACHTTER_SOLUTIONS: u32 = 262;
pub const BLUETOOTH_COMPANY_ID_WILLIAM_DEMANT_HOLDING_A_S: u32 = 263;
pub const BLUETOOTH_COMPANY_ID_CHICONY_ELECTRONICS_CO_LTD: u32 = 264;
pub const BLUETOOTH_COMPANY_ID_ATUS_BV: u32 = 265;
pub const BLUETOOTH_COMPANY_ID_CODEGATE_LTD: u32 = 266;
pub const BLUETOOTH_COMPANY_ID_ERI_INC: u32 = 267;
pub const BLUETOOTH_COMPANY_ID_TRANSDUCERS_DIRECT_LLC: u32 = 268;
pub const BLUETOOTH_COMPANY_ID_DENSO_TEN_LIMITED: u32 = 269;
pub const BLUETOOTH_COMPANY_ID_AUDI_AG: u32 = 270;
pub const BLUETOOTH_COMPANY_ID_HISILICON_TECHNOLOGIES_CO_LIMITED: u32 = 271;
pub const BLUETOOTH_COMPANY_ID_NIPPON_SEIKI_CO_LTD: u32 = 272;
pub const BLUETOOTH_COMPANY_ID_STEELSERIES_APS: u32 = 273;
pub const BLUETOOTH_COMPANY_ID_VISYBL_INC: u32 = 274;
pub const BLUETOOTH_COMPANY_ID_OPENBRAIN_TECHNOLOGIES_CO_LTD: u32 = 275;
pub const BLUETOOTH_COMPANY_ID_XENSR: u32 = 276;
pub const BLUETOOTH_COMPANY_ID_ESOLUTIONS: u32 = 277;
pub const BLUETOOTH_COMPANY_ID_10AK_TECHNOLOGIES: u32 = 278;
pub const BLUETOOTH_COMPANY_ID_WIMOTO_TECHNOLOGIES_INC: u32 = 279;
pub const BLUETOOTH_COMPANY_ID_RADIUS_NETWORKS_INC: u32 = 280;
pub const BLUETOOTH_COMPANY_ID_WIZE_TECHNOLOGY_CO_LTD: u32 = 281;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM_LABS_INC: u32 = 282;
pub const BLUETOOTH_COMPANY_ID_HEWLETT_PACKARD_ENTERPRISE: u32 = 283;
pub const BLUETOOTH_COMPANY_ID_BAIDU: u32 = 284;
pub const BLUETOOTH_COMPANY_ID_ARENDI_AG: u32 = 285;
pub const BLUETOOTH_COMPANY_ID_SKODA_AUTO_AS: u32 = 286;
pub const BLUETOOTH_COMPANY_ID_VOLKSWAGEN_AG: u32 = 287;
pub const BLUETOOTH_COMPANY_ID_PORSCHE_AG: u32 = 288;
pub const BLUETOOTH_COMPANY_ID_SINO_WEALTH_ELECTRONIC_LTD: u32 = 289;
pub const BLUETOOTH_COMPANY_ID_AIRTURN_INC: u32 = 290;
pub const BLUETOOTH_COMPANY_ID_KINSA_INC: u32 = 291;
pub const BLUETOOTH_COMPANY_ID_HID_GLOBAL: u32 = 292;
pub const BLUETOOTH_COMPANY_ID_SEAT_ES: u32 = 293;
pub const BLUETOOTH_COMPANY_ID_PROMETHEAN_LTD: u32 = 294;
pub const BLUETOOTH_COMPANY_ID_SALUTICA_ALLIED_SOLUTIONS: u32 = 295;
pub const BLUETOOTH_COMPANY_ID_GPSI_GROUP_PTY_LTD: u32 = 296;
pub const BLUETOOTH_COMPANY_ID_NIMBLE_DEVICES_OY: u32 = 297;
pub const BLUETOOTH_COMPANY_ID_CHANGZHOU_YONGSE_INFOTECH_CO_LTD: u32 = 298;
pub const BLUETOOTH_COMPANY_ID_SPORTIQ: u32 = 299;
pub const BLUETOOTH_COMPANY_ID_TEMEC_INSTRUMENTS_BV: u32 = 300;
pub const BLUETOOTH_COMPANY_ID_SONY_CORPORATION: u32 = 301;
pub const BLUETOOTH_COMPANY_ID_ASSA_ABLOY: u32 = 302;
pub const BLUETOOTH_COMPANY_ID_CLARION_CO_INC: u32 = 303;
pub const BLUETOOTH_COMPANY_ID_WAREHOUSE_INNOVATIONS: u32 = 304;
pub const BLUETOOTH_COMPANY_ID_CYPRESS_SEMICONDUCTOR: u32 = 305;
pub const BLUETOOTH_COMPANY_ID_MADS_INC: u32 = 306;
pub const BLUETOOTH_COMPANY_ID_BLUE_MAESTRO_LIMITED: u32 = 307;
pub const BLUETOOTH_COMPANY_ID_RESOLUTION_PRODUCTS_LTD: u32 = 308;
pub const BLUETOOTH_COMPANY_ID_AIREWARE_LLC: u32 = 309;
pub const BLUETOOTH_COMPANY_ID_SILVAIR_INC: u32 = 310;
pub const BLUETOOTH_COMPANY_ID_PRESTIGIO_PLAZA_LTD: u32 = 311;
pub const BLUETOOTH_COMPANY_ID_NTEO_INC: u32 = 312;
pub const BLUETOOTH_COMPANY_ID_FOCUS_SYSTEMS_CORPORATION: u32 = 313;
pub const BLUETOOTH_COMPANY_ID_TENCENT_HOLDINGS_LTD: u32 = 314;
pub const BLUETOOTH_COMPANY_ID_ALLEGION: u32 = 315;
pub const BLUETOOTH_COMPANY_ID_MURATA_MANUFACTURING_CO_LTD: u32 = 316;
pub const BLUETOOTH_COMPANY_ID_WIRELESSWERX: u32 = 317;
pub const BLUETOOTH_COMPANY_ID_NOD_INC: u32 = 318;
pub const BLUETOOTH_COMPANY_ID_BANDB_MANUFACTURING_COMPANY: u32 = 319;
pub const BLUETOOTH_COMPANY_ID_ALPINE_ELECTRONICS_CO_LTD: u32 = 320;
pub const BLUETOOTH_COMPANY_ID_FEDEX_SERVICES: u32 = 321;
pub const BLUETOOTH_COMPANY_ID_GRAPE_SYSTEMS_INC: u32 = 322;
pub const BLUETOOTH_COMPANY_ID_BKON_CONNECT: u32 = 323;
pub const BLUETOOTH_COMPANY_ID_LINTECH_GMBH: u32 = 324;
pub const BLUETOOTH_COMPANY_ID_NOVATEL_WIRELESS: u32 = 325;
pub const BLUETOOTH_COMPANY_ID_CIRIGHT: u32 = 326;
pub const BLUETOOTH_COMPANY_ID_MIGHTY_CAST_INC: u32 = 327;
pub const BLUETOOTH_COMPANY_ID_AMBIMAT_ELECTRONICS: u32 = 328;
pub const BLUETOOTH_COMPANY_ID_PERYTONS_LTD: u32 = 329;
pub const BLUETOOTH_COMPANY_ID_TIVOLI_AUDIO_LLC: u32 = 330;
pub const BLUETOOTH_COMPANY_ID_MASTER_LOCK: u32 = 331;
pub const BLUETOOTH_COMPANY_ID_MESH_NET_LTD: u32 = 332;
pub const BLUETOOTH_COMPANY_ID_HUIZHOU_DESAY_SV_AUTOMOTIVE_CO_LTD: u32 = 333;
pub const BLUETOOTH_COMPANY_ID_TANGERINE_INC: u32 = 334;
pub const BLUETOOTH_COMPANY_ID_BANDW_GROUP_LTD: u32 = 335;
pub const BLUETOOTH_COMPANY_ID_PIONEER_CORPORATION: u32 = 336;
pub const BLUETOOTH_COMPANY_ID_ONBEEP: u32 = 337;
pub const BLUETOOTH_COMPANY_ID_VERNIER_SOFTWARE_AND_TECHNOLOGY: u32 = 338;
pub const BLUETOOTH_COMPANY_ID_ROL_ERGO: u32 = 339;
pub const BLUETOOTH_COMPANY_ID_PEBBLE_TECHNOLOGY: u32 = 340;
pub const BLUETOOTH_COMPANY_ID_NETATMO: u32 = 341;
pub const BLUETOOTH_COMPANY_ID_ACCUMULATE_AB: u32 = 342;
pub const BLUETOOTH_COMPANY_ID_ANHUI_HUAMI_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 343;
pub const BLUETOOTH_COMPANY_ID_INMITE_SRO: u32 = 344;
pub const BLUETOOTH_COMPANY_ID_CHEFSTEPS_INC: u32 = 345;
pub const BLUETOOTH_COMPANY_ID_MICAS_AG: u32 = 346;
pub const BLUETOOTH_COMPANY_ID_BIOMEDICAL_RESEARCH_LTD: u32 = 347;
pub const BLUETOOTH_COMPANY_ID_PITIUS_TEC_SL: u32 = 348;
pub const BLUETOOTH_COMPANY_ID_ESTIMOTE_INC: u32 = 349;
pub const BLUETOOTH_COMPANY_ID_UNIKEY_TECHNOLOGIES_INC: u32 = 350;
pub const BLUETOOTH_COMPANY_ID_TIMER_CAP_CO: u32 = 351;
pub const BLUETOOTH_COMPANY_ID_AWOX_FORMERLY_AWOX: u32 = 352;
pub const BLUETOOTH_COMPANY_ID_YIKES: u32 = 353;
pub const BLUETOOTH_COMPANY_ID_MADSGLOBALNZ_LTD: u32 = 354;
pub const BLUETOOTH_COMPANY_ID_PCH_INTERNATIONAL: u32 = 355;
pub const BLUETOOTH_COMPANY_ID_QINGDAO_YEELINK_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 356;
pub const BLUETOOTH_COMPANY_ID_MILWAUKEE_TOOL: u32 = 357;
pub const BLUETOOTH_COMPANY_ID_MISHIK_PTE_LTD: u32 = 358;
pub const BLUETOOTH_COMPANY_ID_ASCENSIA_DIABETES_CARE_US_INC: u32 = 359;
pub const BLUETOOTH_COMPANY_ID_SPICEBOX_LLC: u32 = 360;
pub const BLUETOOTH_COMPANY_ID_EMBERLIGHT: u32 = 361;
pub const BLUETOOTH_COMPANY_ID_COOPER_ATKINS_CORPORATION: u32 = 362;
pub const BLUETOOTH_COMPANY_ID_QBLINKS: u32 = 363;
pub const BLUETOOTH_COMPANY_ID_MYSPHERA: u32 = 364;
pub const BLUETOOTH_COMPANY_ID_LIFESCAN_INC: u32 = 365;
pub const BLUETOOTH_COMPANY_ID_VOLANTIC_AB: u32 = 366;
pub const BLUETOOTH_COMPANY_ID_PODO_LABS_INC: u32 = 367;
pub const BLUETOOTH_COMPANY_ID_ROCHE_DIABETES_CARE_AG: u32 = 368;
pub const BLUETOOTH_COMPANY_ID_AMAZONCOM_SERVICES_LLC: u32 = 369;
pub const BLUETOOTH_COMPANY_ID_CONNOVATE_TECHNOLOGY_PRIVATE_LIMITED: u32 = 370;
pub const BLUETOOTH_COMPANY_ID_KOCOMOJO_LLC: u32 = 371;
pub const BLUETOOTH_COMPANY_ID_EVERYKEY_INC: u32 = 372;
pub const BLUETOOTH_COMPANY_ID_DYNAMIC_CONTROLS: u32 = 373;
pub const BLUETOOTH_COMPANY_ID_SENTRILOCK: u32 = 374;
pub const BLUETOOTH_COMPANY_ID_I_SYST_INC: u32 = 375;
pub const BLUETOOTH_COMPANY_ID_CASIO_COMPUTER_CO_LTD: u32 = 376;
pub const BLUETOOTH_COMPANY_ID_LAPIS_TECHNOLOGY_CO_LTD_FORMERLY_LAPIS_SEMICONDUCTOR_CO_LTD: u32 =
    377;
pub const BLUETOOTH_COMPANY_ID_TELEMONITOR_INC: u32 = 378;
pub const BLUETOOTH_COMPANY_ID_TASKIT_GMBH: u32 = 379;
pub const BLUETOOTH_COMPANY_ID_DAIMLER_AG: u32 = 380;
pub const BLUETOOTH_COMPANY_ID_BATANDCAT: u32 = 381;
pub const BLUETOOTH_COMPANY_ID_BLUDOTZ_LTD: u32 = 382;
pub const BLUETOOTH_COMPANY_ID_XTEL_WIRELESS_APS: u32 = 383;
pub const BLUETOOTH_COMPANY_ID_GIGASET_COMMUNICATIONS_GMBH: u32 = 384;
pub const BLUETOOTH_COMPANY_ID_GECKO_HEALTH_INNOVATIONS_INC: u32 = 385;
pub const BLUETOOTH_COMPANY_ID_HOP_UBIQUITOUS: u32 = 386;
pub const BLUETOOTH_COMPANY_ID_WALT_DISNEY: u32 = 387;
pub const BLUETOOTH_COMPANY_ID_NECTAR: u32 = 388;
pub const BLUETOOTH_COMPANY_ID_BEL_APPS_LLC: u32 = 389;
pub const BLUETOOTH_COMPANY_ID_CORE_LIGHTING_LTD: u32 = 390;
pub const BLUETOOTH_COMPANY_ID_SERAPHIM_SENSE_LTD: u32 = 391;
pub const BLUETOOTH_COMPANY_ID_UNICO_RBC: u32 = 392;
pub const BLUETOOTH_COMPANY_ID_PHYSICAL_ENTERPRISES_INC: u32 = 393;
pub const BLUETOOTH_COMPANY_ID_ABLE_TREND_TECHNOLOGY_LIMITED: u32 = 394;
pub const BLUETOOTH_COMPANY_ID_KONICA_MINOLTA_INC: u32 = 395;
pub const BLUETOOTH_COMPANY_ID_WILO_SE: u32 = 396;
pub const BLUETOOTH_COMPANY_ID_EXTRON_DESIGN_SERVICES: u32 = 397;
pub const BLUETOOTH_COMPANY_ID_FITBIT_INC: u32 = 398;
pub const BLUETOOTH_COMPANY_ID_FIREFLIES_SYSTEMS: u32 = 399;
pub const BLUETOOTH_COMPANY_ID_INTELLETTO_TECHNOLOGIES_INC: u32 = 400;
pub const BLUETOOTH_COMPANY_ID_FDK_CORPORATION: u32 = 401;
pub const BLUETOOTH_COMPANY_ID_CLOUDLEAF_INC: u32 = 402;
pub const BLUETOOTH_COMPANY_ID_MAVERIC_AUTOMATION_LLC: u32 = 403;
pub const BLUETOOTH_COMPANY_ID_ACOUSTIC_STREAM_CORPORATION: u32 = 404;
pub const BLUETOOTH_COMPANY_ID_ZULI: u32 = 405;
pub const BLUETOOTH_COMPANY_ID_PAXTON_ACCESS_LTD: u32 = 406;
pub const BLUETOOTH_COMPANY_ID_WISILICA_INC: u32 = 407;
pub const BLUETOOTH_COMPANY_ID_VENGIT_KORLATOLT_FELELOSSEGU_TARSASAG: u32 = 408;
pub const BLUETOOTH_COMPANY_ID_SALTO_SYSTEMS_SL: u32 = 409;
pub const BLUETOOTH_COMPANY_ID_TRON_FORUM: u32 = 410;
pub const BLUETOOTH_COMPANY_ID_CUBETECH_SRO: u32 = 411;
pub const BLUETOOTH_COMPANY_ID_COKIYA_INCORPORATED: u32 = 412;
pub const BLUETOOTH_COMPANY_ID_CVS_HEALTH: u32 = 413;
pub const BLUETOOTH_COMPANY_ID_CERUUS: u32 = 414;
pub const BLUETOOTH_COMPANY_ID_STRAINSTALL_LTD: u32 = 415;
pub const BLUETOOTH_COMPANY_ID_CHANNEL_ENTERPRISES_LTD: u32 = 416;
pub const BLUETOOTH_COMPANY_ID_FIAMM: u32 = 417;
pub const BLUETOOTH_COMPANY_ID_GIGALANECOLTD: u32 = 418;
pub const BLUETOOTH_COMPANY_ID_EROAD: u32 = 419;
pub const BLUETOOTH_COMPANY_ID_MINE_SAFETY_APPLIANCES: u32 = 420;
pub const BLUETOOTH_COMPANY_ID_ICON_HEALTH_AND_FITNESS: u32 = 421;
pub const BLUETOOTH_COMPANY_ID_WILLE_ENGINEERING: u32 = 422;
pub const BLUETOOTH_COMPANY_ID_ENERGOUS_CORPORATION: u32 = 423;
pub const BLUETOOTH_COMPANY_ID_TAOBAO: u32 = 424;
pub const BLUETOOTH_COMPANY_ID_CANON_INC: u32 = 425;
pub const BLUETOOTH_COMPANY_ID_GEOPHYSICAL_TECHNOLOGY_INC: u32 = 426;
pub const BLUETOOTH_COMPANY_ID_FACEBOOK_INC: u32 = 427;
pub const BLUETOOTH_COMPANY_ID_TRIVIDIA_HEALTH_INC: u32 = 428;
pub const BLUETOOTH_COMPANY_ID_FLIGHTSAFETY_INTERNATIONAL: u32 = 429;
pub const BLUETOOTH_COMPANY_ID_EARLENS_CORPORATION: u32 = 430;
pub const BLUETOOTH_COMPANY_ID_SUNRISE_MICRO_DEVICES_INC: u32 = 431;
pub const BLUETOOTH_COMPANY_ID_STAR_MICRONICS_CO_LTD: u32 = 432;
pub const BLUETOOTH_COMPANY_ID_NETIZENS_SP_Z_OO: u32 = 433;
pub const BLUETOOTH_COMPANY_ID_NYMI_INC: u32 = 434;
pub const BLUETOOTH_COMPANY_ID_NYTEC_INC: u32 = 435;
pub const BLUETOOTH_COMPANY_ID_TRINEO_SP_Z_OO: u32 = 436;
pub const BLUETOOTH_COMPANY_ID_NEST_LABS_INC: u32 = 437;
pub const BLUETOOTH_COMPANY_ID_LM_TECHNOLOGIES_LTD: u32 = 438;
pub const BLUETOOTH_COMPANY_ID_GENERAL_ELECTRIC_COMPANY: u32 = 439;
pub const BLUETOOTH_COMPANY_ID_I_AND_D3_SL: u32 = 440;
pub const BLUETOOTH_COMPANY_ID_HANA_MICRON: u32 = 441;
pub const BLUETOOTH_COMPANY_ID_STAGES_CYCLING_LLC: u32 = 442;
pub const BLUETOOTH_COMPANY_ID_COCHLEAR_BONE_ANCHORED_SOLUTIONS_AB: u32 = 443;
pub const BLUETOOTH_COMPANY_ID_SENIONLAB_AB: u32 = 444;
pub const BLUETOOTH_COMPANY_ID_SYSZONE_CO_LTD: u32 = 445;
pub const BLUETOOTH_COMPANY_ID_PULSATE_MOBILE_LTD: u32 = 446;
pub const BLUETOOTH_COMPANY_ID_HONG_KONG_HUNTERSUN_ELECTRONIC_LIMITED: u32 = 447;
pub const BLUETOOTH_COMPANY_ID_PIRONEX_GMBH: u32 = 448;
pub const BLUETOOTH_COMPANY_ID_BRADATECH_CORP: u32 = 449;
pub const BLUETOOTH_COMPANY_ID_TRANSENERGOOIL_AG: u32 = 450;
pub const BLUETOOTH_COMPANY_ID_BUNCH: u32 = 451;
pub const BLUETOOTH_COMPANY_ID_DME_MICROELECTRONICS: u32 = 452;
pub const BLUETOOTH_COMPANY_ID_BITCRAZE_AB: u32 = 453;
pub const BLUETOOTH_COMPANY_ID_HASWARE_INC: u32 = 454;
pub const BLUETOOTH_COMPANY_ID_ABIOGENIX_INC: u32 = 455;
pub const BLUETOOTH_COMPANY_ID_POLY_CONTROL_APS: u32 = 456;
pub const BLUETOOTH_COMPANY_ID_AVI_ON: u32 = 457;
pub const BLUETOOTH_COMPANY_ID_LAERDAL_MEDICAL_AS: u32 = 458;
pub const BLUETOOTH_COMPANY_ID_FETCH_MY_PET: u32 = 459;
pub const BLUETOOTH_COMPANY_ID_SAM_LABS_LTD: u32 = 460;
pub const BLUETOOTH_COMPANY_ID_CHENGDU_SYNWING_TECHNOLOGY_LTD: u32 = 461;
pub const BLUETOOTH_COMPANY_ID_HOUWA_SYSTEM_DESIGN_KK: u32 = 462;
pub const BLUETOOTH_COMPANY_ID_BSH: u32 = 463;
pub const BLUETOOTH_COMPANY_ID_PRIMUS_INTER_PARES_LTD: u32 = 464;
pub const BLUETOOTH_COMPANY_ID_AUGUST_HOME_INC: u32 = 465;
pub const BLUETOOTH_COMPANY_ID_GILL_ELECTRONICS: u32 = 466;
pub const BLUETOOTH_COMPANY_ID_SKY_WAVE_DESIGN: u32 = 467;
pub const BLUETOOTH_COMPANY_ID_NEWLAB_SRL: u32 = 468;
pub const BLUETOOTH_COMPANY_ID_ELAD_SRL: u32 = 469;
pub const BLUETOOTH_COMPANY_ID_G_WEARABLES_INC: u32 = 470;
pub const BLUETOOTH_COMPANY_ID_SQUADRONE_SYSTEMS_INC: u32 = 471;
pub const BLUETOOTH_COMPANY_ID_CODE_CORPORATION: u32 = 472;
pub const BLUETOOTH_COMPANY_ID_SAVANT_SYSTEMS_LLC: u32 = 473;
pub const BLUETOOTH_COMPANY_ID_LOGITECH_INTERNATIONAL_SA: u32 = 474;
pub const BLUETOOTH_COMPANY_ID_INNBLUE_CONSULTING: u32 = 475;
pub const BLUETOOTH_COMPANY_ID_IPARKING_LTD: u32 = 476;
pub const BLUETOOTH_COMPANY_ID_KONINKLIJKE_PHILIPS_ELECTRONICS_NV: u32 = 477;
pub const BLUETOOTH_COMPANY_ID_MINELAB_ELECTRONICS_PTY_LIMITED: u32 = 478;
pub const BLUETOOTH_COMPANY_ID_BISON_GROUP_LTD: u32 = 479;
pub const BLUETOOTH_COMPANY_ID_WIDEX_A_S: u32 = 480;
pub const BLUETOOTH_COMPANY_ID_JOLLA_LTD: u32 = 481;
pub const BLUETOOTH_COMPANY_ID_LECTRONIX_INC: u32 = 482;
pub const BLUETOOTH_COMPANY_ID_CATERPILLAR_INC: u32 = 483;
pub const BLUETOOTH_COMPANY_ID_FREEDOM_INNOVATIONS: u32 = 484;
pub const BLUETOOTH_COMPANY_ID_DYNAMIC_DEVICES_LTD: u32 = 485;
pub const BLUETOOTH_COMPANY_ID_TECHNOLOGY_SOLUTIONS_LTD: u32 = 486;
pub const BLUETOOTH_COMPANY_ID_IPS_GROUP_INC: u32 = 487;
pub const BLUETOOTH_COMPANY_ID_STIR: u32 = 488;
pub const BLUETOOTH_COMPANY_ID_SANO_INC: u32 = 489;
pub const BLUETOOTH_COMPANY_ID_ADVANCED_APPLICATION_DESIGN_INC: u32 = 490;
pub const BLUETOOTH_COMPANY_ID_AUTOMAP_LLC: u32 = 491;
pub const BLUETOOTH_COMPANY_ID_SPREADTRUM_COMMUNICATIONS_SHANGHAI_LTD: u32 = 492;
pub const BLUETOOTH_COMPANY_ID_CUTECIRCUIT_LTD: u32 = 493;
pub const BLUETOOTH_COMPANY_ID_VALEO_SERVICE: u32 = 494;
pub const BLUETOOTH_COMPANY_ID_FULLPOWER_TECHNOLOGIES_INC: u32 = 495;
pub const BLUETOOTH_COMPANY_ID_KLOUDNATION: u32 = 496;
pub const BLUETOOTH_COMPANY_ID_ZEBRA_TECHNOLOGIES_CORPORATION: u32 = 497;
pub const BLUETOOTH_COMPANY_ID_ITRON_INC: u32 = 498;
pub const BLUETOOTH_COMPANY_ID_THE_UNIVERSITY_OF_TOKYO: u32 = 499;
pub const BLUETOOTH_COMPANY_ID_UTC_FIRE_AND_SECURITY: u32 = 500;
pub const BLUETOOTH_COMPANY_ID_COOL_WEBTHINGS_LIMITED: u32 = 501;
pub const BLUETOOTH_COMPANY_ID_DJO_GLOBAL: u32 = 502;
pub const BLUETOOTH_COMPANY_ID_GELLINER_LIMITED: u32 = 503;
pub const BLUETOOTH_COMPANY_ID_ANYKA_MICROELECTRONICS_TECHNOLOGY_CO_LTD: u32 = 504;
pub const BLUETOOTH_COMPANY_ID_MEDTRONIC_INC: u32 = 505;
pub const BLUETOOTH_COMPANY_ID_GOZIO_INC: u32 = 506;
pub const BLUETOOTH_COMPANY_ID_FORM_LIFTING_LLC: u32 = 507;
pub const BLUETOOTH_COMPANY_ID_WAHOO_FITNESS_LLC: u32 = 508;
pub const BLUETOOTH_COMPANY_ID_KONTAKT_MICRO_LOCATION_SP_Z_OO: u32 = 509;
pub const BLUETOOTH_COMPANY_ID_RADIO_SYSTEMS_CORPORATION: u32 = 510;
pub const BLUETOOTH_COMPANY_ID_FREESCALE_SEMICONDUCTOR_INC: u32 = 511;
pub const BLUETOOTH_COMPANY_ID_VERIFONE_SYSTEMS_PTE_LTD_TAIWAN_BRANCH: u32 = 512;
pub const BLUETOOTH_COMPANY_ID_AR_TIMING: u32 = 513;
pub const BLUETOOTH_COMPANY_ID_RIGADO_LLC: u32 = 514;
pub const BLUETOOTH_COMPANY_ID_KEMPPI_OY: u32 = 515;
pub const BLUETOOTH_COMPANY_ID_TAPCENTIVE_INC: u32 = 516;
pub const BLUETOOTH_COMPANY_ID_SMARTBOTICS_INC: u32 = 517;
pub const BLUETOOTH_COMPANY_ID_OTTER_PRODUCTS_LLC: u32 = 518;
pub const BLUETOOTH_COMPANY_ID_STEMP_INC: u32 = 519;
pub const BLUETOOTH_COMPANY_ID_LUMIGEEK_LLC: u32 = 520;
pub const BLUETOOTH_COMPANY_ID_INVISIONHEART_INC: u32 = 521;
pub const BLUETOOTH_COMPANY_ID_MACNICA_INC: u32 = 522;
pub const BLUETOOTH_COMPANY_ID_JAGUAR_LAND_ROVER_LIMITED: u32 = 523;
pub const BLUETOOTH_COMPANY_ID_COROWARE_TECHNOLOGIES_INC: u32 = 524;
pub const BLUETOOTH_COMPANY_ID_SIMPLO_TECHNOLOGY_CO_LTD: u32 = 525;
pub const BLUETOOTH_COMPANY_ID_OMRON_HEALTHCARE_CO_LTD: u32 = 526;
pub const BLUETOOTH_COMPANY_ID_COMODULE_GMBH: u32 = 527;
pub const BLUETOOTH_COMPANY_ID_IKEGPS: u32 = 528;
pub const BLUETOOTH_COMPANY_ID_TELINK_SEMICONDUCTOR_CO_LTD: u32 = 529;
pub const BLUETOOTH_COMPANY_ID_INTERPLAN_CO_LTD: u32 = 530;
pub const BLUETOOTH_COMPANY_ID_WYLER_AG: u32 = 531;
pub const BLUETOOTH_COMPANY_ID_IK_MULTIMEDIA_PRODUCTION_SRL: u32 = 532;
pub const BLUETOOTH_COMPANY_ID_LUKOTON_EXPERIENCE_OY: u32 = 533;
pub const BLUETOOTH_COMPANY_ID_MTI_LTD: u32 = 534;
pub const BLUETOOTH_COMPANY_ID_TECH4HOME_LDA: u32 = 535;
pub const BLUETOOTH_COMPANY_ID_HIOTECH_AB: u32 = 536;
pub const BLUETOOTH_COMPANY_ID_DOTT_LIMITED: u32 = 537;
pub const BLUETOOTH_COMPANY_ID_BLUE_SPECK_LABS_LLC: u32 = 538;
pub const BLUETOOTH_COMPANY_ID_CISCO_SYSTEMS_INC: u32 = 539;
pub const BLUETOOTH_COMPANY_ID_MOBICOMM_INC: u32 = 540;
pub const BLUETOOTH_COMPANY_ID_EDAMIC: u32 = 541;
pub const BLUETOOTH_COMPANY_ID_GOODNET_LTD: u32 = 542;
pub const BLUETOOTH_COMPANY_ID_LUSTER_LEAF_PRODUCTS_INC: u32 = 543;
pub const BLUETOOTH_COMPANY_ID_MANUS_MACHINA_BV: u32 = 544;
pub const BLUETOOTH_COMPANY_ID_MOBIQUITY_NETWORKS_INC: u32 = 545;
pub const BLUETOOTH_COMPANY_ID_PRAXIS_DYNAMICS: u32 = 546;
pub const BLUETOOTH_COMPANY_ID_PHILIP_MORRIS_PRODUCTS_SA: u32 = 547;
pub const BLUETOOTH_COMPANY_ID_COMARCH_SA: u32 = 548;
pub const BLUETOOTH_COMPANY_ID_NESTL_NESPRESSO_SA: u32 = 549;
pub const BLUETOOTH_COMPANY_ID_MERLINIA_A_S: u32 = 550;
pub const BLUETOOTH_COMPANY_ID_LIFEBEAM_TECHNOLOGIES: u32 = 551;
pub const BLUETOOTH_COMPANY_ID_TWOCANOES_LABS_LLC: u32 = 552;
pub const BLUETOOTH_COMPANY_ID_MUOVERTI_LIMITED: u32 = 553;
pub const BLUETOOTH_COMPANY_ID_STAMER_MUSIKANLAGEN_GMBH: u32 = 554;
pub const BLUETOOTH_COMPANY_ID_TESLA_MOTORS: u32 = 555;
pub const BLUETOOTH_COMPANY_ID_PHARYNKS_CORPORATION: u32 = 556;
pub const BLUETOOTH_COMPANY_ID_LUPINE: u32 = 557;
pub const BLUETOOTH_COMPANY_ID_SIEMENS_AG: u32 = 558;
pub const BLUETOOTH_COMPANY_ID_HUAMI_CULTURE_COMMUNICATION_CO_LTD: u32 = 559;
pub const BLUETOOTH_COMPANY_ID_FOSTER_ELECTRIC_COMPANY_LTD: u32 = 560;
pub const BLUETOOTH_COMPANY_ID_ETA_SA: u32 = 561;
pub const BLUETOOTH_COMPANY_ID_X_SENSO_SOLUTIONS_KFT: u32 = 562;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_SULONG_COMMUNICATION_LTD: u32 = 563;
pub const BLUETOOTH_COMPANY_ID_FENGFAN_TECHNOLOGY_CO_LTD: u32 = 564;
pub const BLUETOOTH_COMPANY_ID_QRIO_INC: u32 = 565;
pub const BLUETOOTH_COMPANY_ID_PITPATPET_LTD: u32 = 566;
pub const BLUETOOTH_COMPANY_ID_MSHELI_SRL: u32 = 567;
pub const BLUETOOTH_COMPANY_ID_TRAKM8_LTD: u32 = 568;
pub const BLUETOOTH_COMPANY_ID_JIN_CO_LTD: u32 = 569;
pub const BLUETOOTH_COMPANY_ID_ALATECH_TEHNOLOGY: u32 = 570;
pub const BLUETOOTH_COMPANY_ID_BEIJING_CAREPULSE_ELECTRONIC_TECHNOLOGY_CO_LTD: u32 = 571;
pub const BLUETOOTH_COMPANY_ID_AWAREPOINT: u32 = 572;
pub const BLUETOOTH_COMPANY_ID_VICENTRA_BV: u32 = 573;
pub const BLUETOOTH_COMPANY_ID_RAVEN_INDUSTRIES: u32 = 574;
pub const BLUETOOTH_COMPANY_ID_WAVEWARE_TECHNOLOGIES_INC: u32 = 575;
pub const BLUETOOTH_COMPANY_ID_ARGENOX_TECHNOLOGIES: u32 = 576;
pub const BLUETOOTH_COMPANY_ID_BRAGI_GMBH: u32 = 577;
pub const BLUETOOTH_COMPANY_ID_16LAB_INC: u32 = 578;
pub const BLUETOOTH_COMPANY_ID_MASIMO_CORP: u32 = 579;
pub const BLUETOOTH_COMPANY_ID_IOTERA_INC: u32 = 580;
pub const BLUETOOTH_COMPANY_ID_ENDRESS_AND_HAUSER: u32 = 581;
pub const BLUETOOTH_COMPANY_ID_ACKME_NETWORKS_INC: u32 = 582;
pub const BLUETOOTH_COMPANY_ID_FIFTYTHREE_INC: u32 = 583;
pub const BLUETOOTH_COMPANY_ID_PARKER_HANNIFIN_CORP: u32 = 584;
pub const BLUETOOTH_COMPANY_ID_TRANSCRANIAL_LTD: u32 = 585;
pub const BLUETOOTH_COMPANY_ID_UWATEC_AG: u32 = 586;
pub const BLUETOOTH_COMPANY_ID_ORLAN_LLC: u32 = 587;
pub const BLUETOOTH_COMPANY_ID_BLUE_CLOVER_DEVICES: u32 = 588;
pub const BLUETOOTH_COMPANY_ID_M_WAY_SOLUTIONS_GMBH: u32 = 589;
pub const BLUETOOTH_COMPANY_ID_MICROTRONICS_ENGINEERING_GMBH: u32 = 590;
pub const BLUETOOTH_COMPANY_ID_SCHNEIDER_SCHREIBGERTE_GMBH: u32 = 591;
pub const BLUETOOTH_COMPANY_ID_SAPPHIRE_CIRCUITS_LLC: u32 = 592;
pub const BLUETOOTH_COMPANY_ID_LUMO_BODYTECH_INC: u32 = 593;
pub const BLUETOOTH_COMPANY_ID_UKC_TECHNOSOLUTION: u32 = 594;
pub const BLUETOOTH_COMPANY_ID_XICATO_INC: u32 = 595;
pub const BLUETOOTH_COMPANY_ID_PLAYBRUSH: u32 = 596;
pub const BLUETOOTH_COMPANY_ID_DAI_NIPPON_PRINTING_CO_LTD: u32 = 597;
pub const BLUETOOTH_COMPANY_ID_G24_POWER_LIMITED: u32 = 598;
pub const BLUETOOTH_COMPANY_ID_ADBABBLE_LOCAL_COMMERCE_INC: u32 = 599;
pub const BLUETOOTH_COMPANY_ID_DEVIALET_SA: u32 = 600;
pub const BLUETOOTH_COMPANY_ID_ALTYOR: u32 = 601;
pub const BLUETOOTH_COMPANY_ID_UNIVERSITY_OF_APPLIED_SCIENCES_VALAIS_HAUTE_ECOLE_VALAISANNE: u32 =
    602;
pub const BLUETOOTH_COMPANY_ID_FIVE_INTERACTIVE_LLC_DBA_ZENDO: u32 = 603;
pub const BLUETOOTH_COMPANY_ID_NETEASEHANGZHOUNETWORK_COLTD: u32 = 604;
pub const BLUETOOTH_COMPANY_ID_LEXMARK_INTERNATIONAL_INC: u32 = 605;
pub const BLUETOOTH_COMPANY_ID_FLUKE_CORPORATION: u32 = 606;
pub const BLUETOOTH_COMPANY_ID_YARDARM_TECHNOLOGIES: u32 = 607;
pub const BLUETOOTH_COMPANY_ID_SENSARX: u32 = 608;
pub const BLUETOOTH_COMPANY_ID_SECVRE_GMBH: u32 = 609;
pub const BLUETOOTH_COMPANY_ID_GLACIAL_RIDGE_TECHNOLOGIES: u32 = 610;
pub const BLUETOOTH_COMPANY_ID_IDENTIV_INC: u32 = 611;
pub const BLUETOOTH_COMPANY_ID_DDS_INC: u32 = 612;
pub const BLUETOOTH_COMPANY_ID_SMK_CORPORATION: u32 = 613;
pub const BLUETOOTH_COMPANY_ID_SCHAWBEL_TECHNOLOGIES_LLC: u32 = 614;
pub const BLUETOOTH_COMPANY_ID_XMI_SYSTEMS_SA: u32 = 615;
pub const BLUETOOTH_COMPANY_ID_CEREVO: u32 = 616;
pub const BLUETOOTH_COMPANY_ID_TORROX_GMBH_AND_CO_KG: u32 = 617;
pub const BLUETOOTH_COMPANY_ID_GEMALTO: u32 = 618;
pub const BLUETOOTH_COMPANY_ID_DEKA_RESEARCH_AND_DEVELOPMENT_CORP: u32 = 619;
pub const BLUETOOTH_COMPANY_ID_DOMSTER_TADEUSZ_SZYDLOWSKI: u32 = 620;
pub const BLUETOOTH_COMPANY_ID_TECHNOGYM_SPA: u32 = 621;
pub const BLUETOOTH_COMPANY_ID_FLEURBAEY_BVBA: u32 = 622;
pub const BLUETOOTH_COMPANY_ID_APTCODE_SOLUTIONS: u32 = 623;
pub const BLUETOOTH_COMPANY_ID_LSI_ADL_TECHNOLOGY: u32 = 624;
pub const BLUETOOTH_COMPANY_ID_ANIMAS_CORP: u32 = 625;
pub const BLUETOOTH_COMPANY_ID_ALPS_ALPINE_CO_LTD: u32 = 626;
pub const BLUETOOTH_COMPANY_ID_OCEASOFT: u32 = 627;
pub const BLUETOOTH_COMPANY_ID_MOTSAI_RESEARCH: u32 = 628;
pub const BLUETOOTH_COMPANY_ID_GEOTAB: u32 = 629;
pub const BLUETOOTH_COMPANY_ID_EGO_ELEKTRO_GERAETEBAU_GMBH: u32 = 630;
pub const BLUETOOTH_COMPANY_ID_BEWHERE_INC: u32 = 631;
pub const BLUETOOTH_COMPANY_ID_JOHNSON_OUTDOORS_INC: u32 = 632;
pub const BLUETOOTH_COMPANY_ID_STEUTE_SCHALTGERATE_GMBH_AND_CO_KG: u32 = 633;
pub const BLUETOOTH_COMPANY_ID_EKOMINI_INC: u32 = 634;
pub const BLUETOOTH_COMPANY_ID_DEFA_AS: u32 = 635;
pub const BLUETOOTH_COMPANY_ID_ASEPTIKA_LTD: u32 = 636;
pub const BLUETOOTH_COMPANY_ID_HUAWEI_TECHNOLOGIES_CO_LTD: u32 = 637;
pub const BLUETOOTH_COMPANY_ID_HABITAWARE_LLC: u32 = 638;
pub const BLUETOOTH_COMPANY_ID_RUWIDO_AUSTRIA_GMBH: u32 = 639;
pub const BLUETOOTH_COMPANY_ID_ITEC_CORPORATION: u32 = 640;
pub const BLUETOOTH_COMPANY_ID_STONEL: u32 = 641;
pub const BLUETOOTH_COMPANY_ID_SONOVA_AG: u32 = 642;
pub const BLUETOOTH_COMPANY_ID_MAVEN_MACHINES_INC: u32 = 643;
pub const BLUETOOTH_COMPANY_ID_SYNAPSE_ELECTRONICS: u32 = 644;
pub const BLUETOOTH_COMPANY_ID_STANDARD_INNOVATION_INC: u32 = 645;
pub const BLUETOOTH_COMPANY_ID_RF_CODE_INC: u32 = 646;
pub const BLUETOOTH_COMPANY_ID_WALLY_VENTURES_SL: u32 = 647;
pub const BLUETOOTH_COMPANY_ID_WILLOWBANK_ELECTRONICS_LTD: u32 = 648;
pub const BLUETOOTH_COMPANY_ID_SK_TELECOM: u32 = 649;
pub const BLUETOOTH_COMPANY_ID_JETRO_AS: u32 = 650;
pub const BLUETOOTH_COMPANY_ID_CODE_GEARS_LTD: u32 = 651;
pub const BLUETOOTH_COMPANY_ID_NANOLINK_APS: u32 = 652;
pub const BLUETOOTH_COMPANY_ID_IF_LLC: u32 = 653;
pub const BLUETOOTH_COMPANY_ID_RF_DIGITAL_CORP: u32 = 654;
pub const BLUETOOTH_COMPANY_ID_CHURCH_AND_DWIGHT_CO_INC: u32 = 655;
pub const BLUETOOTH_COMPANY_ID_MULTIBIT_OY: u32 = 656;
pub const BLUETOOTH_COMPANY_ID_CLINICLOUD_INC: u32 = 657;
pub const BLUETOOTH_COMPANY_ID_SWIFTSENSORS: u32 = 658;
pub const BLUETOOTH_COMPANY_ID_BLUE_BITE: u32 = 659;
pub const BLUETOOTH_COMPANY_ID_ELIAS_GMBH: u32 = 660;
pub const BLUETOOTH_COMPANY_ID_SIVANTOS_GMBH: u32 = 661;
pub const BLUETOOTH_COMPANY_ID_PETZL: u32 = 662;
pub const BLUETOOTH_COMPANY_ID_STORM_POWER_LTD: u32 = 663;
pub const BLUETOOTH_COMPANY_ID_EISST_LTD: u32 = 664;
pub const BLUETOOTH_COMPANY_ID_INEXESS_TECHNOLOGY_SIMMA_KG: u32 = 665;
pub const BLUETOOTH_COMPANY_ID_CURRANT_INC: u32 = 666;
pub const BLUETOOTH_COMPANY_ID_C2_DEVELOPMENT_INC: u32 = 667;
pub const BLUETOOTH_COMPANY_ID_BLUE_SKY_SCIENTIFIC_LLC: u32 = 668;
pub const BLUETOOTH_COMPANY_ID_ALOTTAZS_LABS_LLC: u32 = 669;
pub const BLUETOOTH_COMPANY_ID_KUPSON_SPOL_S_RO: u32 = 670;
pub const BLUETOOTH_COMPANY_ID_AREUS_ENGINEERING_GMBH: u32 = 671;
pub const BLUETOOTH_COMPANY_ID_IMPOSSIBLE_CAMERA_GMBH: u32 = 672;
pub const BLUETOOTH_COMPANY_ID_INVENTURETRACK_SYSTEMS: u32 = 673;
pub const BLUETOOTH_COMPANY_ID_LOCKEDUP: u32 = 674;
pub const BLUETOOTH_COMPANY_ID_ITUDE: u32 = 675;
pub const BLUETOOTH_COMPANY_ID_PACIFIC_LOCK_COMPANY: u32 = 676;
pub const BLUETOOTH_COMPANY_ID_TENDYRON_CORPORATION: u32 = 677;
pub const BLUETOOTH_COMPANY_ID_ROBERT_BOSCH_GMBH: u32 = 678;
pub const BLUETOOTH_COMPANY_ID_ILLUXTRON_INTERNATIONAL_BV: u32 = 679;
pub const BLUETOOTH_COMPANY_ID_MISPORT_LTD: u32 = 680;
pub const BLUETOOTH_COMPANY_ID_CHARGELIB: u32 = 681;
pub const BLUETOOTH_COMPANY_ID_DOPPLER_LAB: u32 = 682;
pub const BLUETOOTH_COMPANY_ID_BBPOS_LIMITED: u32 = 683;
pub const BLUETOOTH_COMPANY_ID_RTB_ELEKTRONIK_GMBH_AND_CO_KG: u32 = 684;
pub const BLUETOOTH_COMPANY_ID_RX_NETWORKS_INC: u32 = 685;
pub const BLUETOOTH_COMPANY_ID_WEATHERFLOW_INC: u32 = 686;
pub const BLUETOOTH_COMPANY_ID_TECHNICOLOR_USA_INC: u32 = 687;
pub const BLUETOOTH_COMPANY_ID_BESTECHNICLTD: u32 = 688;
pub const BLUETOOTH_COMPANY_ID_RADEN_INC: u32 = 689;
pub const BLUETOOTH_COMPANY_ID_JOUZEN_OY: u32 = 690;
pub const BLUETOOTH_COMPANY_ID_CLABER_SPA: u32 = 691;
pub const BLUETOOTH_COMPANY_ID_HYGINEX_INC: u32 = 692;
pub const BLUETOOTH_COMPANY_ID_HANSHIN_ELECTRIC_RAILWAY_COLTD: u32 = 693;
pub const BLUETOOTH_COMPANY_ID_SCHNEIDER_ELECTRIC: u32 = 694;
pub const BLUETOOTH_COMPANY_ID_OORT_TECHNOLOGIES_LLC: u32 = 695;
pub const BLUETOOTH_COMPANY_ID_CHRONO_THERAPEUTICS: u32 = 696;
pub const BLUETOOTH_COMPANY_ID_RINNAI_CORPORATION: u32 = 697;
pub const BLUETOOTH_COMPANY_ID_SWISSPRIME_TECHNOLOGIES_AG: u32 = 698;
pub const BLUETOOTH_COMPANY_ID_KOHACOLTD: u32 = 699;
pub const BLUETOOTH_COMPANY_ID_GENEVAC_LTD: u32 = 700;
pub const BLUETOOTH_COMPANY_ID_CHEMTRONICS: u32 = 701;
pub const BLUETOOTH_COMPANY_ID_SEGURO_TECHNOLOGY_SP_Z_OO: u32 = 702;
pub const BLUETOOTH_COMPANY_ID_REDBIRD_FLIGHT_SIMULATIONS: u32 = 703;
pub const BLUETOOTH_COMPANY_ID_DASH_ROBOTICS: u32 = 704;
pub const BLUETOOTH_COMPANY_ID_LINE_CORPORATION: u32 = 705;
pub const BLUETOOTH_COMPANY_ID_GUILLEMOT_CORPORATION: u32 = 706;
pub const BLUETOOTH_COMPANY_ID_TECHTRONIC_POWER_TOOLS_TECHNOLOGY_LIMITED: u32 = 707;
pub const BLUETOOTH_COMPANY_ID_WILSON_SPORTING_GOODS: u32 = 708;
pub const BLUETOOTH_COMPANY_ID_LENOVO: u32 = 709;
pub const BLUETOOTH_COMPANY_ID_AYATAN_SENSORS: u32 = 710;
pub const BLUETOOTH_COMPANY_ID_ELECTRONICS_TOMORROW_LIMITED: u32 = 711;
pub const BLUETOOTH_COMPANY_ID_ONESPAN: u32 = 712;
pub const BLUETOOTH_COMPANY_ID_PAYRANGE_INC: u32 = 713;
pub const BLUETOOTH_COMPANY_ID_ABOV_SEMICONDUCTOR: u32 = 714;
pub const BLUETOOTH_COMPANY_ID_AINA_WIRELESS_INC: u32 = 715;
pub const BLUETOOTH_COMPANY_ID_EIJKELKAMP_SOIL_AND_WATER: u32 = 716;
pub const BLUETOOTH_COMPANY_ID_BMA_ERGONOMICS_BV: u32 = 717;
pub const BLUETOOTH_COMPANY_ID_TEVA_BRANDED_PHARMACEUTICAL_PRODUCTS_RANDD_INC: u32 = 718;
pub const BLUETOOTH_COMPANY_ID_ANIMA: u32 = 719;
pub const BLUETOOTH_COMPANY_ID_3M: u32 = 720;
pub const BLUETOOTH_COMPANY_ID_EMPATICA_SRL: u32 = 721;
pub const BLUETOOTH_COMPANY_ID_AFERO_INC: u32 = 722;
pub const BLUETOOTH_COMPANY_ID_POWERCAST_CORPORATION: u32 = 723;
pub const BLUETOOTH_COMPANY_ID_SECUYOU_APS: u32 = 724;
pub const BLUETOOTH_COMPANY_ID_OMRON_CORPORATION: u32 = 725;
pub const BLUETOOTH_COMPANY_ID_SEND_SOLUTIONS: u32 = 726;
pub const BLUETOOTH_COMPANY_ID_NIPPON_SYSTEMWARE_COLTD: u32 = 727;
pub const BLUETOOTH_COMPANY_ID_NEOSFAR: u32 = 728;
pub const BLUETOOTH_COMPANY_ID_FLIEGL_AGRARTECHNIK_GMBH: u32 = 729;
pub const BLUETOOTH_COMPANY_ID_GILVADER: u32 = 730;
pub const BLUETOOTH_COMPANY_ID_DIGI_INTERNATIONAL_INC: u32 = 731;
pub const BLUETOOTH_COMPANY_ID_DEWALCH_TECHNOLOGIES_INC: u32 = 732;
pub const BLUETOOTH_COMPANY_ID_FLINT_REHABILITATION_DEVICES_LLC: u32 = 733;
pub const BLUETOOTH_COMPANY_ID_SAMSUNG_SDS_CO_LTD: u32 = 734;
pub const BLUETOOTH_COMPANY_ID_BLUR_PRODUCT_DEVELOPMENT: u32 = 735;
pub const BLUETOOTH_COMPANY_ID_UNIVERSITY_OF_MICHIGAN: u32 = 736;
pub const BLUETOOTH_COMPANY_ID_VICTRON_ENERGY_BV: u32 = 737;
pub const BLUETOOTH_COMPANY_ID_NTT_DOCOMO: u32 = 738;
pub const BLUETOOTH_COMPANY_ID_CARMANAH_TECHNOLOGIES_CORP: u32 = 739;
pub const BLUETOOTH_COMPANY_ID_BYTESTORM_LTD: u32 = 740;
pub const BLUETOOTH_COMPANY_ID_ESPRESSIF_INCORPORATED: u32 = 741;
pub const BLUETOOTH_COMPANY_ID_UNWIRE: u32 = 742;
pub const BLUETOOTH_COMPANY_ID_CONNECTED_YARD_INC: u32 = 743;
pub const BLUETOOTH_COMPANY_ID_AMERICAN_MUSIC_ENVIRONMENTS: u32 = 744;
pub const BLUETOOTH_COMPANY_ID_SENSOGRAM_TECHNOLOGIES_INC: u32 = 745;
pub const BLUETOOTH_COMPANY_ID_FUJITSU_LIMITED: u32 = 746;
pub const BLUETOOTH_COMPANY_ID_ARDIC_TECHNOLOGY: u32 = 747;
pub const BLUETOOTH_COMPANY_ID_DELTA_SYSTEMS_INC: u32 = 748;
pub const BLUETOOTH_COMPANY_ID_HTC_CORPORATION: u32 = 749;
pub const BLUETOOTH_COMPANY_ID_CITIZEN_HOLDINGS_CO_LTD: u32 = 750;
pub const BLUETOOTH_COMPANY_ID_SMART_INNOVATIONINC: u32 = 751;
pub const BLUETOOTH_COMPANY_ID_BLACKRAT_SOFTWARE: u32 = 752;
pub const BLUETOOTH_COMPANY_ID_THE_IDEA_CAVE_LLC: u32 = 753;
pub const BLUETOOTH_COMPANY_ID_GOPRO_INC: u32 = 754;
pub const BLUETOOTH_COMPANY_ID_AUTHAIR_INC: u32 = 755;
pub const BLUETOOTH_COMPANY_ID_VENSI_INC: u32 = 756;
pub const BLUETOOTH_COMPANY_ID_INDAGEM_TECH_LLC: u32 = 757;
pub const BLUETOOTH_COMPANY_ID_INTEMO_TECHNOLOGIES: u32 = 758;
pub const BLUETOOTH_COMPANY_ID_DREAMVISIONS_CO_LTD: u32 = 759;
pub const BLUETOOTH_COMPANY_ID_RUNTEQ_OY_LTD: u32 = 760;
pub const BLUETOOTH_COMPANY_ID_IMAGINATION_TECHNOLOGIES_LTD: u32 = 761;
pub const BLUETOOTH_COMPANY_ID_COSTAR_TECHNOLOGIES: u32 = 762;
pub const BLUETOOTH_COMPANY_ID_CLARIUS_MOBILE_HEALTH_CORP: u32 = 763;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_FREQUEN_MICROELECTRONICS_CO_LTD: u32 = 764;
pub const BLUETOOTH_COMPANY_ID_UWANNA_INC: u32 = 765;
pub const BLUETOOTH_COMPANY_ID_LIERDA_SCIENCE_AND_TECHNOLOGY_GROUP_CO_LTD: u32 = 766;
pub const BLUETOOTH_COMPANY_ID_SILICON_LABORATORIES: u32 = 767;
pub const BLUETOOTH_COMPANY_ID_WORLD_MOTO_INC: u32 = 768;
pub const BLUETOOTH_COMPANY_ID_GIATEC_SCIENTIFIC_INC: u32 = 769;
pub const BLUETOOTH_COMPANY_ID_LOOP_DEVICES_INC: u32 = 770;
pub const BLUETOOTH_COMPANY_ID_IACA_ELECTRONIQUE: u32 = 771;
pub const BLUETOOTH_COMPANY_ID_PROXY_TECHNOLOGIES_INC: u32 = 772;
pub const BLUETOOTH_COMPANY_ID_SWIPP_APS: u32 = 773;
pub const BLUETOOTH_COMPANY_ID_LIFE_LABORATORY_INC: u32 = 774;
pub const BLUETOOTH_COMPANY_ID_FUJI_INDUSTRIAL_COLTD: u32 = 775;
pub const BLUETOOTH_COMPANY_ID_SUREFIRE_LLC: u32 = 776;
pub const BLUETOOTH_COMPANY_ID_DOLBY_LABS: u32 = 777;
pub const BLUETOOTH_COMPANY_ID_ELLISYS: u32 = 778;
pub const BLUETOOTH_COMPANY_ID_MAGNITUDE_LIGHTING_CONVERTERS: u32 = 779;
pub const BLUETOOTH_COMPANY_ID_HILTI_AG: u32 = 780;
pub const BLUETOOTH_COMPANY_ID_DEVDATA_SRL: u32 = 781;
pub const BLUETOOTH_COMPANY_ID_DEVICEWORX: u32 = 782;
pub const BLUETOOTH_COMPANY_ID_SHORTCUT_LABS: u32 = 783;
pub const BLUETOOTH_COMPANY_ID_SGL_ITALIA_SRL: u32 = 784;
pub const BLUETOOTH_COMPANY_ID_PEEQ_DATA: u32 = 785;
pub const BLUETOOTH_COMPANY_ID_DUCERE_TECHNOLOGIES_PVT_LTD: u32 = 786;
pub const BLUETOOTH_COMPANY_ID_DIVENAV_INC: u32 = 787;
pub const BLUETOOTH_COMPANY_ID_RIIG_AI_SP_Z_OO: u32 = 788;
pub const BLUETOOTH_COMPANY_ID_THERMO_FISHER_SCIENTIFIC: u32 = 789;
pub const BLUETOOTH_COMPANY_ID_AG_MEASUREMATICS_PVT_LTD: u32 = 790;
pub const BLUETOOTH_COMPANY_ID_CHUO_ELECTRONICS_CO_LTD: u32 = 791;
pub const BLUETOOTH_COMPANY_ID_ASPENTA_INTERNATIONAL: u32 = 792;
pub const BLUETOOTH_COMPANY_ID_EUGSTER_FRISMAG_AG: u32 = 793;
pub const BLUETOOTH_COMPANY_ID_WURTH_ELEKTRONIK_EISOS_GMBH_AND_CO_KG: u32 = 794;
pub const BLUETOOTH_COMPANY_ID_HQ_INC: u32 = 795;
pub const BLUETOOTH_COMPANY_ID_LAB_SENSOR_SOLUTIONS: u32 = 796;
pub const BLUETOOTH_COMPANY_ID_ENTERLAB_APS: u32 = 797;
pub const BLUETOOTH_COMPANY_ID_EYEFI_INC: u32 = 798;
pub const BLUETOOTH_COMPANY_ID_METASYSTEM_SPA: u32 = 799;
pub const BLUETOOTH_COMPANY_ID_SONO_ELECTRONICS_CO_LTD: u32 = 800;
pub const BLUETOOTH_COMPANY_ID_JEWELBOTS: u32 = 801;
pub const BLUETOOTH_COMPANY_ID_COMPUMEDICS_LIMITED: u32 = 802;
pub const BLUETOOTH_COMPANY_ID_ROTOR_BIKE_COMPONENTS: u32 = 803;
pub const BLUETOOTH_COMPANY_ID_ASTRO_INC: u32 = 804;
pub const BLUETOOTH_COMPANY_ID_AMOTUS_SOLUTIONS: u32 = 805;
pub const BLUETOOTH_COMPANY_ID_HEALTHWEAR_TECHNOLOGIES_LTD: u32 = 806;
pub const BLUETOOTH_COMPANY_ID_ESSEX_ELECTRONICS: u32 = 807;
pub const BLUETOOTH_COMPANY_ID_GRUNDFOS_A_S: u32 = 808;
pub const BLUETOOTH_COMPANY_ID_EARGO_INC: u32 = 809;
pub const BLUETOOTH_COMPANY_ID_ELECTRONIC_DESIGN_LAB: u32 = 810;
pub const BLUETOOTH_COMPANY_ID_ESYLUX: u32 = 811;
pub const BLUETOOTH_COMPANY_ID_NIPPON_SMTCOLTD: u32 = 812;
pub const BLUETOOTH_COMPANY_ID_BM_INNOVATIONS_GMBH: u32 = 813;
pub const BLUETOOTH_COMPANY_ID_INDOORMAP: u32 = 814;
pub const BLUETOOTH_COMPANY_ID_OTTOQ_INC: u32 = 815;
pub const BLUETOOTH_COMPANY_ID_NORTH_POLE_ENGINEERING: u32 = 816;
pub const BLUETOOTH_COMPANY_ID_3FLARES_TECHNOLOGIES_INC: u32 = 817;
pub const BLUETOOTH_COMPANY_ID_ELECTROCOMPANIET_AS: u32 = 818;
pub const BLUETOOTH_COMPANY_ID_MUL_T_LOCK: u32 = 819;
pub const BLUETOOTH_COMPANY_ID_CORENTIUM_AS: u32 = 820;
pub const BLUETOOTH_COMPANY_ID_ENLIGHTED_INC: u32 = 821;
pub const BLUETOOTH_COMPANY_ID_GISTIC: u32 = 822;
pub const BLUETOOTH_COMPANY_ID_AJP2_HOLDINGS_LLC: u32 = 823;
pub const BLUETOOTH_COMPANY_ID_COBI_GMBH: u32 = 824;
pub const BLUETOOTH_COMPANY_ID_BLUE_SKY_SCIENTIFIC_LLC2: u32 = 825;
pub const BLUETOOTH_COMPANY_ID_APPCEPTION_INC: u32 = 826;
pub const BLUETOOTH_COMPANY_ID_COURTNEY_THORNE_LIMITED: u32 = 827;
pub const BLUETOOTH_COMPANY_ID_VIRTUOSYS: u32 = 828;
pub const BLUETOOTH_COMPANY_ID_TPV_TECHNOLOGY_LIMITED: u32 = 829;
pub const BLUETOOTH_COMPANY_ID_MONITRA_SA: u32 = 830;
pub const BLUETOOTH_COMPANY_ID_AUTOMATION_COMPONENTS_INC: u32 = 831;
pub const BLUETOOTH_COMPANY_ID_LETSENSE_SRL: u32 = 832;
pub const BLUETOOTH_COMPANY_ID_ETESIAN_TECHNOLOGIES_LLC: u32 = 833;
pub const BLUETOOTH_COMPANY_ID_GERTEC_BRASIL_LTDA: u32 = 834;
pub const BLUETOOTH_COMPANY_ID_DREKKER_DEVELOPMENT_PTY_LTD: u32 = 835;
pub const BLUETOOTH_COMPANY_ID_WHIRL_INC: u32 = 836;
pub const BLUETOOTH_COMPANY_ID_LOCUS_POSITIONING: u32 = 837;
pub const BLUETOOTH_COMPANY_ID_ACUITY_BRANDS_LIGHTING_INC: u32 = 838;
pub const BLUETOOTH_COMPANY_ID_PREVENT_BIOMETRICS: u32 = 839;
pub const BLUETOOTH_COMPANY_ID_ARIONEO: u32 = 840;
pub const BLUETOOTH_COMPANY_ID_VERSAME: u32 = 841;
pub const BLUETOOTH_COMPANY_ID_VADDIO: u32 = 842;
pub const BLUETOOTH_COMPANY_ID_LIBRATONE_A_S: u32 = 843;
pub const BLUETOOTH_COMPANY_ID_HM_ELECTRONICS_INC: u32 = 844;
pub const BLUETOOTH_COMPANY_ID_TASER_INTERNATIONAL_INC: u32 = 845;
pub const BLUETOOTH_COMPANY_ID_SAFETRUST_INC: u32 = 846;
pub const BLUETOOTH_COMPANY_ID_HEARTLAND_PAYMENT_SYSTEMS: u32 = 847;
pub const BLUETOOTH_COMPANY_ID_BITSTRATA_SYSTEMS_INC: u32 = 848;
pub const BLUETOOTH_COMPANY_ID_PIEPS_GMBH: u32 = 849;
pub const BLUETOOTH_COMPANY_ID_IRIDINGTECHNOLOGY_COLTD: u32 = 850;
pub const BLUETOOTH_COMPANY_ID_ALPHA_AUDIOTRONICS_INC: u32 = 851;
pub const BLUETOOTH_COMPANY_ID_TOPPAN_FORMS_COLTD: u32 = 852;
pub const BLUETOOTH_COMPANY_ID_SIGMA_DESIGNS_INC: u32 = 853;
pub const BLUETOOTH_COMPANY_ID_SPECTRUM_BRANDS_INC: u32 = 854;
pub const BLUETOOTH_COMPANY_ID_POLYMAP_WIRELESS: u32 = 855;
pub const BLUETOOTH_COMPANY_ID_MAGNIWARE_LTD: u32 = 856;
pub const BLUETOOTH_COMPANY_ID_NOVOTEC_MEDICAL_GMBH: u32 = 857;
pub const BLUETOOTH_COMPANY_ID_MEDICOM_INNOVATION_PARTNER_A_S: u32 = 858;
pub const BLUETOOTH_COMPANY_ID_MATRIX_INC: u32 = 859;
pub const BLUETOOTH_COMPANY_ID_EATON_CORPORATION: u32 = 860;
pub const BLUETOOTH_COMPANY_ID_KYS: u32 = 861;
pub const BLUETOOTH_COMPANY_ID_NAYA_HEALTH_INC: u32 = 862;
pub const BLUETOOTH_COMPANY_ID_ACROMAG: u32 = 863;
pub const BLUETOOTH_COMPANY_ID_INSULET_CORPORATION: u32 = 864;
pub const BLUETOOTH_COMPANY_ID_WELLINKS_INC: u32 = 865;
pub const BLUETOOTH_COMPANY_ID_ON_SEMICONDUCTOR: u32 = 866;
pub const BLUETOOTH_COMPANY_ID_FREELAP_SA: u32 = 867;
pub const BLUETOOTH_COMPANY_ID_FAVERO_ELECTRONICS_SRL: u32 = 868;
pub const BLUETOOTH_COMPANY_ID_BIOMECH_SENSOR_LLC: u32 = 869;
pub const BLUETOOTH_COMPANY_ID_BOLTT_SPORTS_TECHNOLOGIES_PRIVATE_LIMITED: u32 = 870;
pub const BLUETOOTH_COMPANY_ID_SAPHE_INTERNATIONAL: u32 = 871;
pub const BLUETOOTH_COMPANY_ID_METORMOTE_AB: u32 = 872;
pub const BLUETOOTH_COMPANY_ID_LITTLEBITS: u32 = 873;
pub const BLUETOOTH_COMPANY_ID_SETPOINT_MEDICAL: u32 = 874;
pub const BLUETOOTH_COMPANY_ID_BRCONTROLS_PRODUCTS_BV: u32 = 875;
pub const BLUETOOTH_COMPANY_ID_ZIPCAR: u32 = 876;
pub const BLUETOOTH_COMPANY_ID_AIRBOLT_PTY_LTD: u32 = 877;
pub const BLUETOOTH_COMPANY_ID_KEEPTRUCKIN_INC: u32 = 878;
pub const BLUETOOTH_COMPANY_ID_MOTIV_INC: u32 = 879;
pub const BLUETOOTH_COMPANY_ID_WAZOMBI_LABS_O: u32 = 880;
pub const BLUETOOTH_COMPANY_ID_ORBCOMM: u32 = 881;
pub const BLUETOOTH_COMPANY_ID_NIXIE_LABS_INC: u32 = 882;
pub const BLUETOOTH_COMPANY_ID_APPNEARME_LTD: u32 = 883;
pub const BLUETOOTH_COMPANY_ID_HOLMAN_INDUSTRIES: u32 = 884;
pub const BLUETOOTH_COMPANY_ID_EXPAIN_AS: u32 = 885;
pub const BLUETOOTH_COMPANY_ID_ELECTRONIC_TEMPERATURE_INSTRUMENTS_LTD: u32 = 886;
pub const BLUETOOTH_COMPANY_ID_PLEJD_AB: u32 = 887;
pub const BLUETOOTH_COMPANY_ID_PROPELLER_HEALTH: u32 = 888;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_IMCO_ELECTRONIC_TECHNOLOGY_COLTD: u32 = 889;
pub const BLUETOOTH_COMPANY_ID_ALGORIA: u32 = 890;
pub const BLUETOOTH_COMPANY_ID_APPTION_LABS_INC: u32 = 891;
pub const BLUETOOTH_COMPANY_ID_CRONOLOGICS_CORPORATION: u32 = 892;
pub const BLUETOOTH_COMPANY_ID_MICRODIA_LTD: u32 = 893;
pub const BLUETOOTH_COMPANY_ID_LULABYTES_SL: u32 = 894;
pub const BLUETOOTH_COMPANY_ID_SOCIT_DES_PRODUITS_NESTL_SA: u32 = 895;
pub const BLUETOOTH_COMPANY_ID_LLC__MEGA_F_SERVICE_: u32 = 896;
pub const BLUETOOTH_COMPANY_ID_SHARP_CORPORATION: u32 = 897;
pub const BLUETOOTH_COMPANY_ID_PRECISION_OUTCOMES_LTD: u32 = 898;
pub const BLUETOOTH_COMPANY_ID_KRONOS_INCORPORATED: u32 = 899;
pub const BLUETOOTH_COMPANY_ID_OCOSMOS_CO_LTD: u32 = 900;
pub const BLUETOOTH_COMPANY_ID_EMBEDDED_ELECTRONIC_SOLUTIONS_LTD_DBA_E2SOLUTIONS: u32 = 901;
pub const BLUETOOTH_COMPANY_ID_ATERICA_INC: u32 = 902;
pub const BLUETOOTH_COMPANY_ID_BLUSTOR_PMC_INC: u32 = 903;
pub const BLUETOOTH_COMPANY_ID_KAPSCH_TRAFFICCOM_AB: u32 = 904;
pub const BLUETOOTH_COMPANY_ID_ACTIVEBLU_CORPORATION: u32 = 905;
pub const BLUETOOTH_COMPANY_ID_KOHLER_MIRA_LIMITED: u32 = 906;
pub const BLUETOOTH_COMPANY_ID_NOKE: u32 = 907;
pub const BLUETOOTH_COMPANY_ID_APPION_INC: u32 = 908;
pub const BLUETOOTH_COMPANY_ID_RESMED_LTD: u32 = 909;
pub const BLUETOOTH_COMPANY_ID_CROWNSTONE_BV: u32 = 910;
pub const BLUETOOTH_COMPANY_ID_XIAOMI_INC: u32 = 911;
pub const BLUETOOTH_COMPANY_ID_INFOTECH_SRO: u32 = 912;
pub const BLUETOOTH_COMPANY_ID_THINGSQUARE_AB: u32 = 913;
pub const BLUETOOTH_COMPANY_ID_TANDD: u32 = 914;
pub const BLUETOOTH_COMPANY_ID_LAVAZZA_SPA: u32 = 915;
pub const BLUETOOTH_COMPANY_ID_NETCLEARANCE_SYSTEMS_INC: u32 = 916;
pub const BLUETOOTH_COMPANY_ID_SDATAWAY: u32 = 917;
pub const BLUETOOTH_COMPANY_ID_BLOKS_GMBH: u32 = 918;
pub const BLUETOOTH_COMPANY_ID_LEGO_SYSTEM_A_S: u32 = 919;
pub const BLUETOOTH_COMPANY_ID_THETATRONICS_LTD: u32 = 920;
pub const BLUETOOTH_COMPANY_ID_NIKON_CORPORATION: u32 = 921;
pub const BLUETOOTH_COMPANY_ID_NEST: u32 = 922;
pub const BLUETOOTH_COMPANY_ID_SOUTH_SILICON_VALLEY_MICROELECTRONICS: u32 = 923;
pub const BLUETOOTH_COMPANY_ID_ALE_INTERNATIONAL: u32 = 924;
pub const BLUETOOTH_COMPANY_ID_CAREVIEW_COMMUNICATIONS_INC: u32 = 925;
pub const BLUETOOTH_COMPANY_ID_SCHOOLBOARD_LIMITED: u32 = 926;
pub const BLUETOOTH_COMPANY_ID_MOLEX_CORPORATION: u32 = 927;
pub const BLUETOOTH_COMPANY_ID_IVT_WIRELESS_LIMITED: u32 = 928;
pub const BLUETOOTH_COMPANY_ID_ALPINE_LABS_LLC: u32 = 929;
pub const BLUETOOTH_COMPANY_ID_CANDURA_INSTRUMENTS: u32 = 930;
pub const BLUETOOTH_COMPANY_ID_SMARTMOVT_TECHNOLOGY_CO_LTD: u32 = 931;
pub const BLUETOOTH_COMPANY_ID_TOKEN_ZERO_LTD: u32 = 932;
pub const BLUETOOTH_COMPANY_ID_ACE_CAD_ENTERPRISE_CO_LTD: u32 = 933;
pub const BLUETOOTH_COMPANY_ID_MEDELA_INC: u32 = 934;
pub const BLUETOOTH_COMPANY_ID_AEROSCOUT: u32 = 935;
pub const BLUETOOTH_COMPANY_ID_ESRILLE_INC: u32 = 936;
pub const BLUETOOTH_COMPANY_ID_THINKERLY_SRL: u32 = 937;
pub const BLUETOOTH_COMPANY_ID_EXON_SP_Z_OO: u32 = 938;
pub const BLUETOOTH_COMPANY_ID_MEIZU_TECHNOLOGY_CO_LTD: u32 = 939;
pub const BLUETOOTH_COMPANY_ID_SMABLO_LTD: u32 = 940;
pub const BLUETOOTH_COMPANY_ID_XIQ: u32 = 941;
pub const BLUETOOTH_COMPANY_ID_ALLSWELL_INC: u32 = 942;
pub const BLUETOOTH_COMPANY_ID_COMM_N_SENSE_CORP_DBA_VERIGO: u32 = 943;
pub const BLUETOOTH_COMPANY_ID_VIBRADORM_GMBH: u32 = 944;
pub const BLUETOOTH_COMPANY_ID_OTODATA_WIRELESS_NETWORK_INC: u32 = 945;
pub const BLUETOOTH_COMPANY_ID_PROPAGATION_SYSTEMS_LIMITED: u32 = 946;
pub const BLUETOOTH_COMPANY_ID_MIDWEST_INSTRUMENTS_AND_CONTROLS: u32 = 947;
pub const BLUETOOTH_COMPANY_ID_ALPHA_NODUS_INC: u32 = 948;
pub const BLUETOOTH_COMPANY_ID_PETPOMM_INC: u32 = 949;
pub const BLUETOOTH_COMPANY_ID_MATTEL: u32 = 950;
pub const BLUETOOTH_COMPANY_ID_AIRBLY_INC: u32 = 951;
pub const BLUETOOTH_COMPANY_ID_A_SAFE_LIMITED: u32 = 952;
pub const BLUETOOTH_COMPANY_ID_FREDERIQUE_CONSTANT_SA: u32 = 953;
pub const BLUETOOTH_COMPANY_ID_MAXSCEND_MICROELECTRONICS_COMPANY_LIMITED: u32 = 954;
pub const BLUETOOTH_COMPANY_ID_ABBOTT: u32 = 955;
pub const BLUETOOTH_COMPANY_ID_ASB_BANK_LTD: u32 = 956;
pub const BLUETOOTH_COMPANY_ID_AMADAS: u32 = 957;
pub const BLUETOOTH_COMPANY_ID_APPLIED_SCIENCE_INC: u32 = 958;
pub const BLUETOOTH_COMPANY_ID_ILUMI_SOLUTIONS_INC: u32 = 959;
pub const BLUETOOTH_COMPANY_ID_ARCH_SYSTEMS_INC: u32 = 960;
pub const BLUETOOTH_COMPANY_ID_EMBER_TECHNOLOGIES_INC: u32 = 961;
pub const BLUETOOTH_COMPANY_ID_SNAPCHAT_INC: u32 = 962;
pub const BLUETOOTH_COMPANY_ID_CASAMBI_TECHNOLOGIES_OY: u32 = 963;
pub const BLUETOOTH_COMPANY_ID_PICO_TECHNOLOGY_INC: u32 = 964;
pub const BLUETOOTH_COMPANY_ID_ST_JUDE_MEDICAL_INC: u32 = 965;
pub const BLUETOOTH_COMPANY_ID_INTRICON: u32 = 966;
pub const BLUETOOTH_COMPANY_ID_STRUCTURAL_HEALTH_SYSTEMS_INC: u32 = 967;
pub const BLUETOOTH_COMPANY_ID_AVVEL_INTERNATIONAL: u32 = 968;
pub const BLUETOOTH_COMPANY_ID_GALLAGHER_GROUP: u32 = 969;
pub const BLUETOOTH_COMPANY_ID_IN2THINGS_AUTOMATION_PVT_LTD: u32 = 970;
pub const BLUETOOTH_COMPANY_ID_SYSDEV_SRL: u32 = 971;
pub const BLUETOOTH_COMPANY_ID_VONKIL_TECHNOLOGIES_LTD: u32 = 972;
pub const BLUETOOTH_COMPANY_ID_WYND_TECHNOLOGIES_INC: u32 = 973;
pub const BLUETOOTH_COMPANY_ID_CONTRINEX_SA: u32 = 974;
pub const BLUETOOTH_COMPANY_ID_MIRA_INC: u32 = 975;
pub const BLUETOOTH_COMPANY_ID_WATTEAM_LTD: u32 = 976;
pub const BLUETOOTH_COMPANY_ID_DENSITY_INC: u32 = 977;
pub const BLUETOOTH_COMPANY_ID_IOT_POT_INDIA_PRIVATE_LIMITED: u32 = 978;
pub const BLUETOOTH_COMPANY_ID_SIGMA_CONNECTIVITY_AB: u32 = 979;
pub const BLUETOOTH_COMPANY_ID_PEG_PEREGO_SPA: u32 = 980;
pub const BLUETOOTH_COMPANY_ID_WYZELINK_SYSTEMS_INC: u32 = 981;
pub const BLUETOOTH_COMPANY_ID_YOTA_DEVICES_LTD: u32 = 982;
pub const BLUETOOTH_COMPANY_ID_FINSECUR: u32 = 983;
pub const BLUETOOTH_COMPANY_ID_ZEN_ME_LABS_LTD: u32 = 984;
pub const BLUETOOTH_COMPANY_ID_3IWARE_CO_LTD: u32 = 985;
pub const BLUETOOTH_COMPANY_ID_ENOCEAN_GMBH: u32 = 986;
pub const BLUETOOTH_COMPANY_ID_INSTABEAT_INC: u32 = 987;
pub const BLUETOOTH_COMPANY_ID_NIMA_LABS: u32 = 988;
pub const BLUETOOTH_COMPANY_ID_ANDREAS_STIHL_AG_AND_CO_KG: u32 = 989;
pub const BLUETOOTH_COMPANY_ID_NATHAN_RHOADES_LLC: u32 = 990;
pub const BLUETOOTH_COMPANY_ID_GROB_TECHNOLOGIES_LLC: u32 = 991;
pub const BLUETOOTH_COMPANY_ID_ACTIONS_TECHNOLOGY_CO_LIMITED: u32 = 992;
pub const BLUETOOTH_COMPANY_ID_SPD_DEVELOPMENT_COMPANY_LTD: u32 = 993;
pub const BLUETOOTH_COMPANY_ID_SENSOAN_OY: u32 = 994;
pub const BLUETOOTH_COMPANY_ID_QUALCOMM_LIFE_INC: u32 = 995;
pub const BLUETOOTH_COMPANY_ID_CHIP_ING_AG: u32 = 996;
pub const BLUETOOTH_COMPANY_ID_FFLY4U: u32 = 997;
pub const BLUETOOTH_COMPANY_ID_IOT_INSTRUMENTS_OY: u32 = 998;
pub const BLUETOOTH_COMPANY_ID_TRUE_FITNESS_TECHNOLOGY: u32 = 999;
pub const BLUETOOTH_COMPANY_ID_REINER_KARTENGERAETE_GMBH_AND_CO_KG: u32 = 1000;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_LEMONJOY_TECHNOLOGY_CO_LTD: u32 = 1001;
pub const BLUETOOTH_COMPANY_ID_HELLO_INC: u32 = 1002;
pub const BLUETOOTH_COMPANY_ID_EVOLLVE_INC: u32 = 1003;
pub const BLUETOOTH_COMPANY_ID_JIGOWATTS_INC: u32 = 1004;
pub const BLUETOOTH_COMPANY_ID_BASIC_MICROCOMINC: u32 = 1005;
pub const BLUETOOTH_COMPANY_ID_CUBE_TECHNOLOGIES: u32 = 1006;
pub const BLUETOOTH_COMPANY_ID_FOOLOGRAPHY_GMBH: u32 = 1007;
pub const BLUETOOTH_COMPANY_ID_CLINK: u32 = 1008;
pub const BLUETOOTH_COMPANY_ID_HESTAN_SMART_COOKING_INC: u32 = 1009;
pub const BLUETOOTH_COMPANY_ID_WINDOWMASTER_A_S: u32 = 1010;
pub const BLUETOOTH_COMPANY_ID_FLOWSCAPE_AB: u32 = 1011;
pub const BLUETOOTH_COMPANY_ID_PAL_TECHNOLOGIES_LTD: u32 = 1012;
pub const BLUETOOTH_COMPANY_ID_WHERE_INC: u32 = 1013;
pub const BLUETOOTH_COMPANY_ID_ITON_TECHNOLOGY_CORP: u32 = 1014;
pub const BLUETOOTH_COMPANY_ID_OWL_LABS_INC: u32 = 1015;
pub const BLUETOOTH_COMPANY_ID_ROCKFORD_CORP: u32 = 1016;
pub const BLUETOOTH_COMPANY_ID_BECON_TECHNOLOGIES_COLTD: u32 = 1017;
pub const BLUETOOTH_COMPANY_ID_VYASSOFT_TECHNOLOGIES_INC: u32 = 1018;
pub const BLUETOOTH_COMPANY_ID_NOX_MEDICAL: u32 = 1019;
pub const BLUETOOTH_COMPANY_ID_KIMBERLY_CLARK: u32 = 1020;
pub const BLUETOOTH_COMPANY_ID_TRIMBLE_NAVIGATION_LTD: u32 = 1021;
pub const BLUETOOTH_COMPANY_ID_LITTELFUSE: u32 = 1022;
pub const BLUETOOTH_COMPANY_ID_WITHINGS: u32 = 1023;
pub const BLUETOOTH_COMPANY_ID_I_DEVELOPER_IT_BERATUNG_UG: u32 = 1024;
pub const BLUETOOTH_COMPANY_ID_RELATIONS_INC: u32 = 1025;
pub const BLUETOOTH_COMPANY_ID_SEARS_HOLDINGS_CORPORATION: u32 = 1026;
pub const BLUETOOTH_COMPANY_ID_GANTNER_ELECTRONIC_GMBH: u32 = 1027;
pub const BLUETOOTH_COMPANY_ID_AUTHOMATE_INC: u32 = 1028;
pub const BLUETOOTH_COMPANY_ID_VERTEX_INTERNATIONAL_INC: u32 = 1029;
pub const BLUETOOTH_COMPANY_ID_AIRTAGO: u32 = 1030;
pub const BLUETOOTH_COMPANY_ID_SWISS_AUDIO_SA: u32 = 1031;
pub const BLUETOOTH_COMPANY_ID_TOGETHOME_INC: u32 = 1032;
pub const BLUETOOTH_COMPANY_ID_AXIS: u32 = 1033;
pub const BLUETOOTH_COMPANY_ID_OPENMATICS: u32 = 1034;
pub const BLUETOOTH_COMPANY_ID_JANA_CARE_INC: u32 = 1035;
pub const BLUETOOTH_COMPANY_ID_SENIX_CORPORATION: u32 = 1036;
pub const BLUETOOTH_COMPANY_ID_NORTHSTAR_BATTERY_COMPANY_LLC: u32 = 1037;
pub const BLUETOOTH_COMPANY_ID_SKF_LIMITED: u32 = 1038;
pub const BLUETOOTH_COMPANY_ID_CO_AX_TECHNOLOGY_INC: u32 = 1039;
pub const BLUETOOTH_COMPANY_ID_FENDER_MUSICAL_INSTRUMENTS: u32 = 1040;
pub const BLUETOOTH_COMPANY_ID_LUIDIA_INC: u32 = 1041;
pub const BLUETOOTH_COMPANY_ID_SEFAM: u32 = 1042;
pub const BLUETOOTH_COMPANY_ID_WIRELESS_CABLES_INC: u32 = 1043;
pub const BLUETOOTH_COMPANY_ID_LIGHTNING_PROTECTION_INTERNATIONAL_PTY_LTD: u32 = 1044;
pub const BLUETOOTH_COMPANY_ID_UBER_TECHNOLOGIES_INC: u32 = 1045;
pub const BLUETOOTH_COMPANY_ID_SODA_GMBH: u32 = 1046;
pub const BLUETOOTH_COMPANY_ID_FATIGUE_SCIENCE: u32 = 1047;
pub const BLUETOOTH_COMPANY_ID_RESERVED: u32 = 1048;
pub const BLUETOOTH_COMPANY_ID_NOVALOGY_LTD: u32 = 1049;
pub const BLUETOOTH_COMPANY_ID_FRIDAY_LABS_LIMITED: u32 = 1050;
pub const BLUETOOTH_COMPANY_ID_ORTHOACCEL_TECHNOLOGIES: u32 = 1051;
pub const BLUETOOTH_COMPANY_ID_WATERGURU_INC: u32 = 1052;
pub const BLUETOOTH_COMPANY_ID_BENNING_ELEKTROTECHNIK_UND_ELEKTRONIK_GMBH_AND_CO_KG: u32 = 1053;
pub const BLUETOOTH_COMPANY_ID_DELL_COMPUTER_CORPORATION: u32 = 1054;
pub const BLUETOOTH_COMPANY_ID_KOPIN_CORPORATION: u32 = 1055;
pub const BLUETOOTH_COMPANY_ID_TECBAKERY_GMBH: u32 = 1056;
pub const BLUETOOTH_COMPANY_ID_BACKBONE_LABS_INC: u32 = 1057;
pub const BLUETOOTH_COMPANY_ID_DELSEY_SA: u32 = 1058;
pub const BLUETOOTH_COMPANY_ID_CHARGIFI_LIMITED: u32 = 1059;
pub const BLUETOOTH_COMPANY_ID_TRAINESENSE_LTD: u32 = 1060;
pub const BLUETOOTH_COMPANY_ID_UNIFY_SOFTWARE_AND_SOLUTIONS_GMBH_AND_CO_KG: u32 = 1061;
pub const BLUETOOTH_COMPANY_ID_HUSQVARNA_AB: u32 = 1062;
pub const BLUETOOTH_COMPANY_ID_FOCUS_FLEET_AND_FUEL_MANAGEMENT_INC: u32 = 1063;
pub const BLUETOOTH_COMPANY_ID_SMALLLOOP_LLC: u32 = 1064;
pub const BLUETOOTH_COMPANY_ID_PROLON_INC: u32 = 1065;
pub const BLUETOOTH_COMPANY_ID_BD_MEDICAL: u32 = 1066;
pub const BLUETOOTH_COMPANY_ID_IMICROMED_INCORPORATED: u32 = 1067;
pub const BLUETOOTH_COMPANY_ID_TICTO_NV: u32 = 1068;
pub const BLUETOOTH_COMPANY_ID_MESHTECH_AS: u32 = 1069;
pub const BLUETOOTH_COMPANY_ID_MEMCACHIER_INC: u32 = 1070;
pub const BLUETOOTH_COMPANY_ID_DANFOSS_A_S: u32 = 1071;
pub const BLUETOOTH_COMPANY_ID_SNAPSTYK_INC: u32 = 1072;
pub const BLUETOOTH_COMPANY_ID_AMWAY_CORPORATION: u32 = 1073;
pub const BLUETOOTH_COMPANY_ID_SILK_LABS_INC: u32 = 1074;
pub const BLUETOOTH_COMPANY_ID_PILLSY_INC: u32 = 1075;
pub const BLUETOOTH_COMPANY_ID_HATCH_BABY_INC: u32 = 1076;
pub const BLUETOOTH_COMPANY_ID_BLOCKS_WEARABLES_LTD: u32 = 1077;
pub const BLUETOOTH_COMPANY_ID_DRAYSON_TECHNOLOGIES_LIMITED: u32 = 1078;
pub const BLUETOOTH_COMPANY_ID_EBEST_IOT_INC: u32 = 1079;
pub const BLUETOOTH_COMPANY_ID_HELVAR_LTD: u32 = 1080;
pub const BLUETOOTH_COMPANY_ID_RADIANCE_TECHNOLOGIES: u32 = 1081;
pub const BLUETOOTH_COMPANY_ID_NUHEARA_LIMITED: u32 = 1082;
pub const BLUETOOTH_COMPANY_ID_APPSIDE_CO_LTD: u32 = 1083;
pub const BLUETOOTH_COMPANY_ID_DELAVAL: u32 = 1084;
pub const BLUETOOTH_COMPANY_ID_COILER_CORPORATION: u32 = 1085;
pub const BLUETOOTH_COMPANY_ID_THERMOMEDICS_INC: u32 = 1086;
pub const BLUETOOTH_COMPANY_ID_TENTACLE_SYNC_GMBH: u32 = 1087;
pub const BLUETOOTH_COMPANY_ID_VALENCELL_INC: u32 = 1088;
pub const BLUETOOTH_COMPANY_ID_IPROTOXI_OY: u32 = 1089;
pub const BLUETOOTH_COMPANY_ID_SECOM_CO_LTD: u32 = 1090;
pub const BLUETOOTH_COMPANY_ID_TUCKER_INTERNATIONAL_LLC: u32 = 1091;
pub const BLUETOOTH_COMPANY_ID_METANATE_LIMITED: u32 = 1092;
pub const BLUETOOTH_COMPANY_ID_KOBIAN_CANADA_INC: u32 = 1093;
pub const BLUETOOTH_COMPANY_ID_NETGEAR_INC: u32 = 1094;
pub const BLUETOOTH_COMPANY_ID_FABTRONICS_AUSTRALIA_PTY_LTD: u32 = 1095;
pub const BLUETOOTH_COMPANY_ID_GRAND_CENTRIX_GMBH: u32 = 1096;
pub const BLUETOOTH_COMPANY_ID_1UP_USACOM_LLC: u32 = 1097;
pub const BLUETOOTH_COMPANY_ID_SHIMANO_INC: u32 = 1098;
pub const BLUETOOTH_COMPANY_ID_NAIN_INC: u32 = 1099;
pub const BLUETOOTH_COMPANY_ID_LIFESTYLE_LOCK_LLC: u32 = 1100;
pub const BLUETOOTH_COMPANY_ID_VEGA_GRIESHABER_KG: u32 = 1101;
pub const BLUETOOTH_COMPANY_ID_XTRAVA_INC: u32 = 1102;
pub const BLUETOOTH_COMPANY_ID_TTS_TOOLTECHNIC_SYSTEMS_AG_AND_CO_KG: u32 = 1103;
pub const BLUETOOTH_COMPANY_ID_TEENAGE_ENGINEERING_AB: u32 = 1104;
pub const BLUETOOTH_COMPANY_ID_TUNSTALL_NORDIC_AB: u32 = 1105;
pub const BLUETOOTH_COMPANY_ID_SVEP_DESIGN_CENTER_AB: u32 = 1106;
pub const BLUETOOTH_COMPANY_ID_QORVO_UTRECHT_BV_FORMERLY_GREENPEAK_TECHNOLOGIES_BV: u32 = 1107;
pub const BLUETOOTH_COMPANY_ID_SPHINX_ELECTRONICS_GMBH_AND_CO_KG: u32 = 1108;
pub const BLUETOOTH_COMPANY_ID_ATOMATION: u32 = 1109;
pub const BLUETOOTH_COMPANY_ID_NEMIK_CONSULTING_INC: u32 = 1110;
pub const BLUETOOTH_COMPANY_ID_RF_INNOVATION: u32 = 1111;
pub const BLUETOOTH_COMPANY_ID_MINI_SOLUTION_CO_LTD: u32 = 1112;
pub const BLUETOOTH_COMPANY_ID_LUMENETIX_INC: u32 = 1113;
pub const BLUETOOTH_COMPANY_ID_2048450_ONTARIO_INC: u32 = 1114;
pub const BLUETOOTH_COMPANY_ID_SPACEEK_LTD: u32 = 1115;
pub const BLUETOOTH_COMPANY_ID_DELTA_T_CORPORATION: u32 = 1116;
pub const BLUETOOTH_COMPANY_ID_BOSTON_SCIENTIFIC_CORPORATION: u32 = 1117;
pub const BLUETOOTH_COMPANY_ID_NUVIZ_INC: u32 = 1118;
pub const BLUETOOTH_COMPANY_ID_REAL_TIME_AUTOMATION_INC: u32 = 1119;
pub const BLUETOOTH_COMPANY_ID_KOLIBREE: u32 = 1120;
pub const BLUETOOTH_COMPANY_ID_VHF_ELEKTRONIK_GMBH: u32 = 1121;
pub const BLUETOOTH_COMPANY_ID_BONSAI_SYSTEMS_GMBH: u32 = 1122;
pub const BLUETOOTH_COMPANY_ID_FATHOM_SYSTEMS_INC: u32 = 1123;
pub const BLUETOOTH_COMPANY_ID_BELLMAN_AND_SYMFON: u32 = 1124;
pub const BLUETOOTH_COMPANY_ID_INTERNATIONAL_FORTE_GROUP_LLC: u32 = 1125;
pub const BLUETOOTH_COMPANY_ID_CYCLELABS_SOLUTIONS_INC: u32 = 1126;
pub const BLUETOOTH_COMPANY_ID_CODENEX_OY: u32 = 1127;
pub const BLUETOOTH_COMPANY_ID_KYNESIM_LTD: u32 = 1128;
pub const BLUETOOTH_COMPANY_ID_PALAGO_AB: u32 = 1129;
pub const BLUETOOTH_COMPANY_ID_INSIGMA_INC: u32 = 1130;
pub const BLUETOOTH_COMPANY_ID_PMD_SOLUTIONS: u32 = 1131;
pub const BLUETOOTH_COMPANY_ID_QINGDAO_REALTIME_TECHNOLOGY_CO_LTD: u32 = 1132;
pub const BLUETOOTH_COMPANY_ID_BEGA_GANTENBRINK_LEUCHTEN_KG: u32 = 1133;
pub const BLUETOOTH_COMPANY_ID_PAMBOR_LTD: u32 = 1134;
pub const BLUETOOTH_COMPANY_ID_DEVELCO_PRODUCTS_A_S: u32 = 1135;
pub const BLUETOOTH_COMPANY_ID_IDESIGN_SRL: u32 = 1136;
pub const BLUETOOTH_COMPANY_ID_TIVO_CORP: u32 = 1137;
pub const BLUETOOTH_COMPANY_ID_CONTROL_J_PTY_LTD: u32 = 1138;
pub const BLUETOOTH_COMPANY_ID_STEELCASE_INC: u32 = 1139;
pub const BLUETOOTH_COMPANY_ID_IAPARTMENT_CO_LTD: u32 = 1140;
pub const BLUETOOTH_COMPANY_ID_ICOM_INC: u32 = 1141;
pub const BLUETOOTH_COMPANY_ID_OXSTREN_WEARABLE_TECHNOLOGIES_PRIVATE_LIMITED: u32 = 1142;
pub const BLUETOOTH_COMPANY_ID_BLUE_SPARK_TECHNOLOGIES: u32 = 1143;
pub const BLUETOOTH_COMPANY_ID_FARSITE_COMMUNICATIONS_LIMITED: u32 = 1144;
pub const BLUETOOTH_COMPANY_ID_MYWERK_SYSTEM_GMBH: u32 = 1145;
pub const BLUETOOTH_COMPANY_ID_SINOSUN_TECHNOLOGY_CO_LTD: u32 = 1146;
pub const BLUETOOTH_COMPANY_ID_MIYOSHI_ELECTRONICS_CORPORATION: u32 = 1147;
pub const BLUETOOTH_COMPANY_ID_POWERMAT_LTD: u32 = 1148;
pub const BLUETOOTH_COMPANY_ID_OCCLY_LLC: u32 = 1149;
pub const BLUETOOTH_COMPANY_ID_OURHUB_DEV_IVS: u32 = 1150;
pub const BLUETOOTH_COMPANY_ID_PRO_MARK_INC: u32 = 1151;
pub const BLUETOOTH_COMPANY_ID_DYNOMETRICS_INC: u32 = 1152;
pub const BLUETOOTH_COMPANY_ID_QUINTRAX_LIMITED: u32 = 1153;
pub const BLUETOOTH_COMPANY_ID_POS_TUNING_UDO_VOSSHENRICH_GMBH_AND_CO_KG: u32 = 1154;
pub const BLUETOOTH_COMPANY_ID_MULTI_CARE_SYSTEMS_BV: u32 = 1155;
pub const BLUETOOTH_COMPANY_ID_REVOL_TECHNOLOGIES_INC: u32 = 1156;
pub const BLUETOOTH_COMPANY_ID_SKIDATA_AG: u32 = 1157;
pub const BLUETOOTH_COMPANY_ID_DEV_TECNOLOGIA_INDUSTRIA_COMERCIO_E_MANUTENCAO_DE_EQUIPAMENTOS_LTDA_ME : u32 = 1158 ;
pub const BLUETOOTH_COMPANY_ID_CENTRICA_CONNECTED_HOME: u32 = 1159;
pub const BLUETOOTH_COMPANY_ID_AUTOMOTIVE_DATA_SOLUTIONS_INC: u32 = 1160;
pub const BLUETOOTH_COMPANY_ID_IGARASHI_ENGINEERING: u32 = 1161;
pub const BLUETOOTH_COMPANY_ID_TAELEK_OY: u32 = 1162;
pub const BLUETOOTH_COMPANY_ID_CP_ELECTRONICS_LIMITED: u32 = 1163;
pub const BLUETOOTH_COMPANY_ID_VECTRONIX_AG: u32 = 1164;
pub const BLUETOOTH_COMPANY_ID_S_LABS_SP_Z_OO: u32 = 1165;
pub const BLUETOOTH_COMPANY_ID_COMPANION_MEDICAL_INC: u32 = 1166;
pub const BLUETOOTH_COMPANY_ID_BLUEKITCHEN_GMBH: u32 = 1167;
pub const BLUETOOTH_COMPANY_ID_MATTING_AB: u32 = 1168;
pub const BLUETOOTH_COMPANY_ID_SOREX_WIRELESS_SOLUTIONS_GMBH: u32 = 1169;
pub const BLUETOOTH_COMPANY_ID_ADC_TECHNOLOGY_INC: u32 = 1170;
pub const BLUETOOTH_COMPANY_ID_LYNXEMI_PTE_LTD: u32 = 1171;
pub const BLUETOOTH_COMPANY_ID_SENNHEISER_ELECTRONIC_GMBH_AND_CO_KG: u32 = 1172;
pub const BLUETOOTH_COMPANY_ID_LMT_MERCER_GROUP_INC: u32 = 1173;
pub const BLUETOOTH_COMPANY_ID_POLYMORPHIC_LABS_LLC: u32 = 1174;
pub const BLUETOOTH_COMPANY_ID_COCHLEAR_LIMITED: u32 = 1175;
pub const BLUETOOTH_COMPANY_ID_METER_GROUP_INC_USA: u32 = 1176;
pub const BLUETOOTH_COMPANY_ID_RUUVI_INNOVATIONS_LTD: u32 = 1177;
pub const BLUETOOTH_COMPANY_ID_SITUNE_AS: u32 = 1178;
pub const BLUETOOTH_COMPANY_ID_NVISTI_LLC: u32 = 1179;
pub const BLUETOOTH_COMPANY_ID_DYOCEAN: u32 = 1180;
pub const BLUETOOTH_COMPANY_ID_UHLMANN_AND_ZACHER_GMBH: u32 = 1181;
pub const BLUETOOTH_COMPANY_ID_AND_XOR_LLC: u32 = 1182;
pub const BLUETOOTH_COMPANY_ID_TICTOTE_AB: u32 = 1183;
pub const BLUETOOTH_COMPANY_ID_VYPIN_LLC: u32 = 1184;
pub const BLUETOOTH_COMPANY_ID_PNI_SENSOR_CORPORATION: u32 = 1185;
pub const BLUETOOTH_COMPANY_ID_OVRENGINEERED_LLC: u32 = 1186;
pub const BLUETOOTH_COMPANY_ID_GT_TRONICS_HK_LTD: u32 = 1187;
pub const BLUETOOTH_COMPANY_ID_HERBERT_WALDMANN_GMBH_AND_CO_KG: u32 = 1188;
pub const BLUETOOTH_COMPANY_ID_GUANGZHOU_FIIO_ELECTRONICS_TECHNOLOGY_COLTD: u32 = 1189;
pub const BLUETOOTH_COMPANY_ID_VINETECH_CO_LTD: u32 = 1190;
pub const BLUETOOTH_COMPANY_ID_DALLAS_LOGIC_CORPORATION: u32 = 1191;
pub const BLUETOOTH_COMPANY_ID_BIOTEX_INC: u32 = 1192;
pub const BLUETOOTH_COMPANY_ID_DISCOVERY_SOUND_TECHNOLOGY_LLC: u32 = 1193;
pub const BLUETOOTH_COMPANY_ID_LINKIO_SAS: u32 = 1194;
pub const BLUETOOTH_COMPANY_ID_HARBORTRONICS_INC: u32 = 1195;
pub const BLUETOOTH_COMPANY_ID_UNDAGRID_BV: u32 = 1196;
pub const BLUETOOTH_COMPANY_ID_SHURE_INC: u32 = 1197;
pub const BLUETOOTH_COMPANY_ID_ERM_ELECTRONIC_SYSTEMS_LTD: u32 = 1198;
pub const BLUETOOTH_COMPANY_ID_BIOROWER_HANDELSAGENTUR_GMBH: u32 = 1199;
pub const BLUETOOTH_COMPANY_ID_WEBA_SPORT_UND_MED_ARTIKEL_GMBH: u32 = 1200;
pub const BLUETOOTH_COMPANY_ID_KARTOGRAPHERS_TECHNOLOGIES_PVT_LTD: u32 = 1201;
pub const BLUETOOTH_COMPANY_ID_THE_SHADOW_ON_THE_MOON: u32 = 1202;
pub const BLUETOOTH_COMPANY_ID_MOBIKE_LIMITED: u32 = 1203;
pub const BLUETOOTH_COMPANY_ID_INUHEAT_GROUP_AB: u32 = 1204;
pub const BLUETOOTH_COMPANY_ID_SWIFTRONIX_AB: u32 = 1205;
pub const BLUETOOTH_COMPANY_ID_DIAGNOPTICS_TECHNOLOGIES: u32 = 1206;
pub const BLUETOOTH_COMPANY_ID_ANALOG_DEVICES_INC: u32 = 1207;
pub const BLUETOOTH_COMPANY_ID_SORAA_INC: u32 = 1208;
pub const BLUETOOTH_COMPANY_ID_CSR_BUILDING_PRODUCTS_LIMITED: u32 = 1209;
pub const BLUETOOTH_COMPANY_ID_CRESTRON_ELECTRONICS_INC: u32 = 1210;
pub const BLUETOOTH_COMPANY_ID_NEATEBOX_LTD: u32 = 1211;
pub const BLUETOOTH_COMPANY_ID_DRAEGERWERK_AG_AND_CO_KGAA: u32 = 1212;
pub const BLUETOOTH_COMPANY_ID_ALBYNMEDICAL: u32 = 1213;
pub const BLUETOOTH_COMPANY_ID_AVEROS_FZCO: u32 = 1214;
pub const BLUETOOTH_COMPANY_ID_VIT_INITIATIVE_LLC: u32 = 1215;
pub const BLUETOOTH_COMPANY_ID_STATSPORTS_INTERNATIONAL: u32 = 1216;
pub const BLUETOOTH_COMPANY_ID_SOSPITAS_SRO: u32 = 1217;
pub const BLUETOOTH_COMPANY_ID_DMET_PRODUCTS_CORP: u32 = 1218;
pub const BLUETOOTH_COMPANY_ID_MANTRACOURT_ELECTRONICS_LIMITED: u32 = 1219;
pub const BLUETOOTH_COMPANY_ID_TEAM_HUTCHINS_AB: u32 = 1220;
pub const BLUETOOTH_COMPANY_ID_SEIBERT_WILLIAMS_GLASS_LLC: u32 = 1221;
pub const BLUETOOTH_COMPANY_ID_INSTA_GMBH: u32 = 1222;
pub const BLUETOOTH_COMPANY_ID_SVANTEK_SP_Z_OO: u32 = 1223;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_FLYCO_ELECTRICAL_APPLIANCE_CO_LTD: u32 = 1224;
pub const BLUETOOTH_COMPANY_ID_THORNWAVE_LABS_INC: u32 = 1225;
pub const BLUETOOTH_COMPANY_ID_STEINER_OPTIK_GMBH: u32 = 1226;
pub const BLUETOOTH_COMPANY_ID_NOVO_NORDISK_A_S: u32 = 1227;
pub const BLUETOOTH_COMPANY_ID_ENFLUX_INC: u32 = 1228;
pub const BLUETOOTH_COMPANY_ID_SAFETECH_PRODUCTS_LLC: u32 = 1229;
pub const BLUETOOTH_COMPANY_ID_GOOOLED_SRL: u32 = 1230;
pub const BLUETOOTH_COMPANY_ID_DOM_SICHERHEITSTECHNIK_GMBH_AND_CO_KG: u32 = 1231;
pub const BLUETOOTH_COMPANY_ID_OLYMPUS_CORPORATION: u32 = 1232;
pub const BLUETOOTH_COMPANY_ID_KTS_GMBH: u32 = 1233;
pub const BLUETOOTH_COMPANY_ID_ANLOQ_TECHNOLOGIES_INC: u32 = 1234;
pub const BLUETOOTH_COMPANY_ID_QUEERCON_INC: u32 = 1235;
pub const BLUETOOTH_COMPANY_ID_5TH_ELEMENT_LTD: u32 = 1236;
pub const BLUETOOTH_COMPANY_ID_GOOEE_LIMITED: u32 = 1237;
pub const BLUETOOTH_COMPANY_ID_LUGLOC_LLC: u32 = 1238;
pub const BLUETOOTH_COMPANY_ID_BLINCAM_INC: u32 = 1239;
pub const BLUETOOTH_COMPANY_ID_FUJIFILM_CORPORATION: u32 = 1240;
pub const BLUETOOTH_COMPANY_ID_RANDMCNALLY: u32 = 1241;
pub const BLUETOOTH_COMPANY_ID_FRANCESCHI_MARINA_SNC: u32 = 1242;
pub const BLUETOOTH_COMPANY_ID_ENGINEERED_AUDIO_LLC: u32 = 1243;
pub const BLUETOOTH_COMPANY_ID_IOTTIVE_PRIVATE_LIMITED: u32 = 1244;
pub const BLUETOOTH_COMPANY_ID_4MOD_TECHNOLOGY: u32 = 1245;
pub const BLUETOOTH_COMPANY_ID_LUTRON_ELECTRONICS_CO_INC: u32 = 1246;
pub const BLUETOOTH_COMPANY_ID_EMERSON: u32 = 1247;
pub const BLUETOOTH_COMPANY_ID_GUARDTEC_INC: u32 = 1248;
pub const BLUETOOTH_COMPANY_ID_REACTEC_LIMITED: u32 = 1249;
pub const BLUETOOTH_COMPANY_ID_ELLIEGRID: u32 = 1250;
pub const BLUETOOTH_COMPANY_ID_UNDER_ARMOUR: u32 = 1251;
pub const BLUETOOTH_COMPANY_ID_WOODENSHARK: u32 = 1252;
pub const BLUETOOTH_COMPANY_ID_AVACK_OY: u32 = 1253;
pub const BLUETOOTH_COMPANY_ID_SMART_SOLUTION_TECHNOLOGY_INC: u32 = 1254;
pub const BLUETOOTH_COMPANY_ID_REHABTRONICS_INC: u32 = 1255;
pub const BLUETOOTH_COMPANY_ID_STABILO_INTERNATIONAL: u32 = 1256;
pub const BLUETOOTH_COMPANY_ID_BUSCH_JAEGER_ELEKTRO_GMBH: u32 = 1257;
pub const BLUETOOTH_COMPANY_ID_PACIFIC_BIOSCIENCE_LABORATORIES_INC: u32 = 1258;
pub const BLUETOOTH_COMPANY_ID_BIRD_HOME_AUTOMATION_GMBH: u32 = 1259;
pub const BLUETOOTH_COMPANY_ID_MOTOROLA_SOLUTIONS: u32 = 1260;
pub const BLUETOOTH_COMPANY_ID_R9_TECHNOLOGY_INC: u32 = 1261;
pub const BLUETOOTH_COMPANY_ID_AUXIVIA: u32 = 1262;
pub const BLUETOOTH_COMPANY_ID_DAISYWORKS_INC: u32 = 1263;
pub const BLUETOOTH_COMPANY_ID_KOSI_LIMITED: u32 = 1264;
pub const BLUETOOTH_COMPANY_ID_THEBEN_AG: u32 = 1265;
pub const BLUETOOTH_COMPANY_ID_INDREAMER_TECHSOL_PRIVATE_LIMITED: u32 = 1266;
pub const BLUETOOTH_COMPANY_ID_CEREVAST_MEDICAL: u32 = 1267;
pub const BLUETOOTH_COMPANY_ID_ZANCOMPUTE_INC: u32 = 1268;
pub const BLUETOOTH_COMPANY_ID_PIRELLI_TYRE_SPA: u32 = 1269;
pub const BLUETOOTH_COMPANY_ID_MCLEAR_LIMITED: u32 = 1270;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_HUIDING_TECHNOLOGY_COLTD: u32 = 1271;
pub const BLUETOOTH_COMPANY_ID_CONVERGENCE_SYSTEMS_LIMITED: u32 = 1272;
pub const BLUETOOTH_COMPANY_ID_INTERACTIO: u32 = 1273;
pub const BLUETOOTH_COMPANY_ID_ANDROTEC_GMBH: u32 = 1274;
pub const BLUETOOTH_COMPANY_ID_BENCHMARK_DRIVES_GMBH_AND_CO_KG: u32 = 1275;
pub const BLUETOOTH_COMPANY_ID_SWINGLYNC_L_L_C: u32 = 1276;
pub const BLUETOOTH_COMPANY_ID_TAPKEY_GMBH: u32 = 1277;
pub const BLUETOOTH_COMPANY_ID_WOOSIM_SYSTEMS_INC: u32 = 1278;
pub const BLUETOOTH_COMPANY_ID_MICROSEMI_CORPORATION: u32 = 1279;
pub const BLUETOOTH_COMPANY_ID_WILIOT_LTD: u32 = 1280;
pub const BLUETOOTH_COMPANY_ID_POLARIS_IND: u32 = 1281;
pub const BLUETOOTH_COMPANY_ID_SPECIFI_KALI_LLC: u32 = 1282;
pub const BLUETOOTH_COMPANY_ID_LOCOROLL_INC: u32 = 1283;
pub const BLUETOOTH_COMPANY_ID_PHYPLUS_INC: u32 = 1284;
pub const BLUETOOTH_COMPANY_ID_INPLAY_INC: u32 = 1285;
pub const BLUETOOTH_COMPANY_ID_HAGER: u32 = 1286;
pub const BLUETOOTH_COMPANY_ID_YELLOWCOG: u32 = 1287;
pub const BLUETOOTH_COMPANY_ID_AXES_SYSTEM_SP_Z_O_O: u32 = 1288;
pub const BLUETOOTH_COMPANY_ID_MYLIFTER_INC: u32 = 1289;
pub const BLUETOOTH_COMPANY_ID_SHAKE_ON_BV: u32 = 1290;
pub const BLUETOOTH_COMPANY_ID_VIBRISSA_INC: u32 = 1291;
pub const BLUETOOTH_COMPANY_ID_OSRAM_GMBH: u32 = 1292;
pub const BLUETOOTH_COMPANY_ID_TRSYSTEMS_GMBH: u32 = 1293;
pub const BLUETOOTH_COMPANY_ID_YICHIP_MICROELECTRONICS_COLTD: u32 = 1294;
pub const BLUETOOTH_COMPANY_ID_FOUNDATION_ENGINEERING_LLC: u32 = 1295;
pub const BLUETOOTH_COMPANY_ID_UNI_ELECTRONICS_INC: u32 = 1296;
pub const BLUETOOTH_COMPANY_ID_BROOKFIELD_EQUINOX_LLC: u32 = 1297;
pub const BLUETOOTH_COMPANY_ID_SOPROD_SA: u32 = 1298;
pub const BLUETOOTH_COMPANY_ID_9974091_CANADA_INC: u32 = 1299;
pub const BLUETOOTH_COMPANY_ID_FIBRO_GMBH: u32 = 1300;
pub const BLUETOOTH_COMPANY_ID_RB_CONTROLS_CO_LTD: u32 = 1301;
pub const BLUETOOTH_COMPANY_ID_FOOTMARKS: u32 = 1302;
pub const BLUETOOTH_COMPANY_ID_AMTRONIC_SVERIGE_AB: u32 = 1303;
pub const BLUETOOTH_COMPANY_ID_MAMORIOINC: u32 = 1304;
pub const BLUETOOTH_COMPANY_ID_TYTO_LIFE_LLC: u32 = 1305;
pub const BLUETOOTH_COMPANY_ID_LEICA_CAMERA_AG: u32 = 1306;
pub const BLUETOOTH_COMPANY_ID_ANGEE_TECHNOLOGIES_LTD: u32 = 1307;
pub const BLUETOOTH_COMPANY_ID_EDPS: u32 = 1308;
pub const BLUETOOTH_COMPANY_ID_OFF_LINE_CO_LTD: u32 = 1309;
pub const BLUETOOTH_COMPANY_ID_DETECT_BLUE_LIMITED: u32 = 1310;
pub const BLUETOOTH_COMPANY_ID_SETEC_PTY_LTD: u32 = 1311;
pub const BLUETOOTH_COMPANY_ID_TARGET_CORPORATION: u32 = 1312;
pub const BLUETOOTH_COMPANY_ID_IAI_CORPORATION: u32 = 1313;
pub const BLUETOOTH_COMPANY_ID_NS_TECH_INC: u32 = 1314;
pub const BLUETOOTH_COMPANY_ID_MTG_CO_LTD: u32 = 1315;
pub const BLUETOOTH_COMPANY_ID_HANGZHOU_IMAGIC_TECHNOLOGY_CO_LTD: u32 = 1316;
pub const BLUETOOTH_COMPANY_ID_HONGKONG_NANO_IC_TECHNOLOGIES_CO_LIMITED: u32 = 1317;
pub const BLUETOOTH_COMPANY_ID_HONEYWELL_INTERNATIONAL_INC: u32 = 1318;
pub const BLUETOOTH_COMPANY_ID_ALBRECHT_JUNG: u32 = 1319;
pub const BLUETOOTH_COMPANY_ID_LUNERA_LIGHTING_INC: u32 = 1320;
pub const BLUETOOTH_COMPANY_ID_LUMEN_UAB: u32 = 1321;
pub const BLUETOOTH_COMPANY_ID_KEYNES_CONTROLS_LTD: u32 = 1322;
pub const BLUETOOTH_COMPANY_ID_NOVARTIS_AG: u32 = 1323;
pub const BLUETOOTH_COMPANY_ID_GEOSATIS_SA: u32 = 1324;
pub const BLUETOOTH_COMPANY_ID_EXFO_INC: u32 = 1325;
pub const BLUETOOTH_COMPANY_ID_LEDVANCE_GMBH: u32 = 1326;
pub const BLUETOOTH_COMPANY_ID_CENTER_ID_CORP: u32 = 1327;
pub const BLUETOOTH_COMPANY_ID_ADOLENE_INC: u32 = 1328;
pub const BLUETOOTH_COMPANY_ID_DANDM_HOLDINGS_INC: u32 = 1329;
pub const BLUETOOTH_COMPANY_ID_CRESCO_WIRELESS_INC: u32 = 1330;
pub const BLUETOOTH_COMPANY_ID_NURA_OPERATIONS_PTY_LTD: u32 = 1331;
pub const BLUETOOTH_COMPANY_ID_FRONTIERGADGET_INC: u32 = 1332;
pub const BLUETOOTH_COMPANY_ID_SMART_COMPONENT_TECHNOLOGIES_LIMITED: u32 = 1333;
pub const BLUETOOTH_COMPANY_ID_ZTR_CONTROL_SYSTEMS_LLC: u32 = 1334;
pub const BLUETOOTH_COMPANY_ID_METALOGICS_CORPORATION: u32 = 1335;
pub const BLUETOOTH_COMPANY_ID_MEDELA_AG: u32 = 1336;
pub const BLUETOOTH_COMPANY_ID_OPPLE_LIGHTING_CO_LTD: u32 = 1337;
pub const BLUETOOTH_COMPANY_ID_SAVITECH_CORP: u32 = 1338;
pub const BLUETOOTH_COMPANY_ID_PRODIGY: u32 = 1339;
pub const BLUETOOTH_COMPANY_ID_SCREENOVATE_TECHNOLOGIES_LTD: u32 = 1340;
pub const BLUETOOTH_COMPANY_ID_TESA_SA: u32 = 1341;
pub const BLUETOOTH_COMPANY_ID_CLIM8_LIMITED: u32 = 1342;
pub const BLUETOOTH_COMPANY_ID_SILERGY_CORP: u32 = 1343;
pub const BLUETOOTH_COMPANY_ID_SILVERPLUS_INC: u32 = 1344;
pub const BLUETOOTH_COMPANY_ID_SHARKNET_SRL: u32 = 1345;
pub const BLUETOOTH_COMPANY_ID_MIST_SYSTEMS_INC: u32 = 1346;
pub const BLUETOOTH_COMPANY_ID_MIWA_LOCK_COLTD: u32 = 1347;
pub const BLUETOOTH_COMPANY_ID_ORTHOSENSOR_INC: u32 = 1348;
pub const BLUETOOTH_COMPANY_ID_CANDY_HOOVER_GROUP_SRL: u32 = 1349;
pub const BLUETOOTH_COMPANY_ID_APEXAR_TECHNOLOGIES_SA: u32 = 1350;
pub const BLUETOOTH_COMPANY_ID_LOGICDATA_DOO: u32 = 1351;
pub const BLUETOOTH_COMPANY_ID_KNICK_ELEKTRONISCHE_MESSGERAETE_GMBH_AND_CO_KG: u32 = 1352;
pub const BLUETOOTH_COMPANY_ID_SMART_TECHNOLOGIES_AND_INVESTMENT_LIMITED: u32 = 1353;
pub const BLUETOOTH_COMPANY_ID_LINOUGH_INC: u32 = 1354;
pub const BLUETOOTH_COMPANY_ID_ADVANCED_ELECTRONIC_DESIGNS_INC: u32 = 1355;
pub const BLUETOOTH_COMPANY_ID_CAREFREE_SCOTT_FETZER_CO_INC: u32 = 1356;
pub const BLUETOOTH_COMPANY_ID_SENSOME: u32 = 1357;
pub const BLUETOOTH_COMPANY_ID_FORTRONIK_STORITVE_DOO: u32 = 1358;
pub const BLUETOOTH_COMPANY_ID_SINNOZ: u32 = 1359;
pub const BLUETOOTH_COMPANY_ID_VERSA_NETWORKS_INC: u32 = 1360;
pub const BLUETOOTH_COMPANY_ID_SYLERO: u32 = 1361;
pub const BLUETOOTH_COMPANY_ID_AVEMPACE_SARL: u32 = 1362;
pub const BLUETOOTH_COMPANY_ID_NINTENDO_CO_LTD: u32 = 1363;
pub const BLUETOOTH_COMPANY_ID_NATIONAL_INSTRUMENTS: u32 = 1364;
pub const BLUETOOTH_COMPANY_ID_KROHNE_MESSTECHNIK_GMBH: u32 = 1365;
pub const BLUETOOTH_COMPANY_ID_OTODYNAMICS_LTD: u32 = 1366;
pub const BLUETOOTH_COMPANY_ID_ARWIN_TECHNOLOGY_LIMITED: u32 = 1367;
pub const BLUETOOTH_COMPANY_ID_BENEGEAR_INC: u32 = 1368;
pub const BLUETOOTH_COMPANY_ID_NEWCON_OPTIK: u32 = 1369;
pub const BLUETOOTH_COMPANY_ID_CANDY_HOUSE_INC: u32 = 1370;
pub const BLUETOOTH_COMPANY_ID_FRANKLIN_TECHNOLOGY_INC: u32 = 1371;
pub const BLUETOOTH_COMPANY_ID_LELY: u32 = 1372;
pub const BLUETOOTH_COMPANY_ID_VALVE_CORPORATION: u32 = 1373;
pub const BLUETOOTH_COMPANY_ID_HEKATRON_VERTRIEBS_GMBH: u32 = 1374;
pub const BLUETOOTH_COMPANY_ID_PROTECH_SAS_DI_GIRARDI_ANDREA_AND_C: u32 = 1375;
pub const BLUETOOTH_COMPANY_ID_SARITA_CARETECH_APS: u32 = 1376;
pub const BLUETOOTH_COMPANY_ID_FINDER_SPA: u32 = 1377;
pub const BLUETOOTH_COMPANY_ID_THALMIC_LABS_INC: u32 = 1378;
pub const BLUETOOTH_COMPANY_ID_STEINEL_VERTRIEB_GMBH: u32 = 1379;
pub const BLUETOOTH_COMPANY_ID_BEGHELLI_SPA: u32 = 1380;
pub const BLUETOOTH_COMPANY_ID_BEIJING_SMARTSPACE_TECHNOLOGIES_INC: u32 = 1381;
pub const BLUETOOTH_COMPANY_ID_CORE_TRANSPORT_TECHNOLOGIES_NZ_LIMITED: u32 = 1382;
pub const BLUETOOTH_COMPANY_ID_XIAMEN_EVERESPORTS_GOODS_CO_LTD: u32 = 1383;
pub const BLUETOOTH_COMPANY_ID_BODYPORT_INC: u32 = 1384;
pub const BLUETOOTH_COMPANY_ID_AUDIONICS_SYSTEM_INC: u32 = 1385;
pub const BLUETOOTH_COMPANY_ID_FLIPNAVI_COLTD: u32 = 1386;
pub const BLUETOOTH_COMPANY_ID_RION_CO_LTD: u32 = 1387;
pub const BLUETOOTH_COMPANY_ID_LONG_RANGE_SYSTEMS_LLC: u32 = 1388;
pub const BLUETOOTH_COMPANY_ID_REDMOND_INDUSTRIAL_GROUP_LLC: u32 = 1389;
pub const BLUETOOTH_COMPANY_ID_VIZPIN_INC: u32 = 1390;
pub const BLUETOOTH_COMPANY_ID_BIKEFINDER_AS: u32 = 1391;
pub const BLUETOOTH_COMPANY_ID_CONSUMER_SLEEP_SOLUTIONS_LLC: u32 = 1392;
pub const BLUETOOTH_COMPANY_ID_PSIKICK_INC: u32 = 1393;
pub const BLUETOOTH_COMPANY_ID_ANTTAILCOM: u32 = 1394;
pub const BLUETOOTH_COMPANY_ID_LIGHTING_SCIENCE_GROUP_CORP: u32 = 1395;
pub const BLUETOOTH_COMPANY_ID_AFFORDABLE_ELECTRONICS_INC: u32 = 1396;
pub const BLUETOOTH_COMPANY_ID_INTEGRAL_MEMROY_PLC: u32 = 1397;
pub const BLUETOOTH_COMPANY_ID_GLOBALSTAR_INC: u32 = 1398;
pub const BLUETOOTH_COMPANY_ID_TRUE_WEARABLES_INC: u32 = 1399;
pub const BLUETOOTH_COMPANY_ID_WELLINGTON_DRIVE_TECHNOLOGIES_LTD: u32 = 1400;
pub const BLUETOOTH_COMPANY_ID_ENSEMBLE_TECH_PRIVATE_LIMITED: u32 = 1401;
pub const BLUETOOTH_COMPANY_ID_OMNI_REMOTES: u32 = 1402;
pub const BLUETOOTH_COMPANY_ID_DURACELL_US_OPERATIONS_INC: u32 = 1403;
pub const BLUETOOTH_COMPANY_ID_TOOR_TECHNOLOGIES_LLC: u32 = 1404;
pub const BLUETOOTH_COMPANY_ID_INSTINCT_PERFORMANCE: u32 = 1405;
pub const BLUETOOTH_COMPANY_ID_BECO_INC: u32 = 1406;
pub const BLUETOOTH_COMPANY_ID_SCUF_GAMING_INTERNATIONAL_LLC: u32 = 1407;
pub const BLUETOOTH_COMPANY_ID_ARANZ_MEDICAL_LIMITED: u32 = 1408;
pub const BLUETOOTH_COMPANY_ID_LYS_TECHNOLOGIES_LTD: u32 = 1409;
pub const BLUETOOTH_COMPANY_ID_BREAKWALL_ANALYTICS_LLC: u32 = 1410;
pub const BLUETOOTH_COMPANY_ID_CODE_BLUE_COMMUNICATIONS: u32 = 1411;
pub const BLUETOOTH_COMPANY_ID_GIRA_GIERSIEPEN_GMBH_AND_CO_KG: u32 = 1412;
pub const BLUETOOTH_COMPANY_ID_HEARING_LAB_TECHNOLOGY: u32 = 1413;
pub const BLUETOOTH_COMPANY_ID_LEGRAND: u32 = 1414;
pub const BLUETOOTH_COMPANY_ID_DERICHS_GMBH: u32 = 1415;
pub const BLUETOOTH_COMPANY_ID_ALT_TEKNIK_LLC: u32 = 1416;
pub const BLUETOOTH_COMPANY_ID_STAR_TECHNOLOGIES: u32 = 1417;
pub const BLUETOOTH_COMPANY_ID_START_TODAY_COLTD: u32 = 1418;
pub const BLUETOOTH_COMPANY_ID_MAXIM_INTEGRATED_PRODUCTS: u32 = 1419;
pub const BLUETOOTH_COMPANY_ID_MERCK_KOMMANDITGESELLSCHAFT_AUF_AKTIEN: u32 = 1420;
pub const BLUETOOTH_COMPANY_ID_JUNGHEINRICH_AKTIENGESELLSCHAFT: u32 = 1421;
pub const BLUETOOTH_COMPANY_ID_OCULUS_VR_LLC: u32 = 1422;
pub const BLUETOOTH_COMPANY_ID_HENDON_SEMICONDUCTORS_PTY_LTD: u32 = 1423;
pub const BLUETOOTH_COMPANY_ID_PUR3_LTD: u32 = 1424;
pub const BLUETOOTH_COMPANY_ID_VIASAT_GROUP_SPA: u32 = 1425;
pub const BLUETOOTH_COMPANY_ID_IZITHERM: u32 = 1426;
pub const BLUETOOTH_COMPANY_ID_SPAULDING_CLINICAL_RESEARCH: u32 = 1427;
pub const BLUETOOTH_COMPANY_ID_KOHLER_COMPANY: u32 = 1428;
pub const BLUETOOTH_COMPANY_ID_INOR_PROCESS_AB: u32 = 1429;
pub const BLUETOOTH_COMPANY_ID_MY_SMART_BLINDS: u32 = 1430;
pub const BLUETOOTH_COMPANY_ID_RADIOPULSE_INC: u32 = 1431;
pub const BLUETOOTH_COMPANY_ID_RAPITAG_GMBH: u32 = 1432;
pub const BLUETOOTH_COMPANY_ID_LAZLO326_LLC: u32 = 1433;
pub const BLUETOOTH_COMPANY_ID_TELEDYNE_LECROY_INC: u32 = 1434;
pub const BLUETOOTH_COMPANY_ID_DATAFLOW_SYSTEMS_LIMITED: u32 = 1435;
pub const BLUETOOTH_COMPANY_ID_MACROGIGA_ELECTRONICS: u32 = 1436;
pub const BLUETOOTH_COMPANY_ID_TANDEM_DIABETES_CARE: u32 = 1437;
pub const BLUETOOTH_COMPANY_ID_POLYCOM_INC: u32 = 1438;
pub const BLUETOOTH_COMPANY_ID_FISHER_AND_PAYKEL_HEALTHCARE: u32 = 1439;
pub const BLUETOOTH_COMPANY_ID_RCP_SOFTWARE_OY: u32 = 1440;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_XIAOYI_TECHNOLOGY_COLTD: u32 = 1441;
pub const BLUETOOTH_COMPANY_ID_ADHERIUM_LIMITED: u32 = 1442;
pub const BLUETOOTH_COMPANY_ID_AXIOMWARE_SYSTEMS_INCORPORATED: u32 = 1443;
pub const BLUETOOTH_COMPANY_ID_O_E_M_CONTROLS_INC: u32 = 1444;
pub const BLUETOOTH_COMPANY_ID_KIIROO_BV: u32 = 1445;
pub const BLUETOOTH_COMPANY_ID_TELECON_MOBILE_LIMITED: u32 = 1446;
pub const BLUETOOTH_COMPANY_ID_SONOS_INC: u32 = 1447;
pub const BLUETOOTH_COMPANY_ID_TOM_ALLEBRANDI_CONSULTING: u32 = 1448;
pub const BLUETOOTH_COMPANY_ID_MONIDOR: u32 = 1449;
pub const BLUETOOTH_COMPANY_ID_TRAMEX_LIMITED: u32 = 1450;
pub const BLUETOOTH_COMPANY_ID_NOFENCE_AS: u32 = 1451;
pub const BLUETOOTH_COMPANY_ID_GOERTEK_DYNAUDIO_CO_LTD: u32 = 1452;
pub const BLUETOOTH_COMPANY_ID_INIA: u32 = 1453;
pub const BLUETOOTH_COMPANY_ID_CARMATE_MFGCOLTD: u32 = 1454;
pub const BLUETOOTH_COMPANY_ID_OV_LOOP_INC: u32 = 1455;
pub const BLUETOOTH_COMPANY_ID_NEWTEC_GMBH: u32 = 1456;
pub const BLUETOOTH_COMPANY_ID_MEDALLION_INSTRUMENTATION_SYSTEMS: u32 = 1457;
pub const BLUETOOTH_COMPANY_ID_CAREL_INDUSTRIES_SPA: u32 = 1458;
pub const BLUETOOTH_COMPANY_ID_PARABIT_SYSTEMS_INC: u32 = 1459;
pub const BLUETOOTH_COMPANY_ID_WHITE_HORSE_SCIENTIFIC_LTD: u32 = 1460;
pub const BLUETOOTH_COMPANY_ID_VERISILICON: u32 = 1461;
pub const BLUETOOTH_COMPANY_ID_ELECS_INDUSTRY_COLTD: u32 = 1462;
pub const BLUETOOTH_COMPANY_ID_BEIJING_PINECONE_ELECTRONICS_COLTD: u32 = 1463;
pub const BLUETOOTH_COMPANY_ID_AMBYSTOMA_LABS_INC: u32 = 1464;
pub const BLUETOOTH_COMPANY_ID_SUZHOU_PAIRLINK_NETWORK_TECHNOLOGY: u32 = 1465;
pub const BLUETOOTH_COMPANY_ID_IGLOOHOME: u32 = 1466;
pub const BLUETOOTH_COMPANY_ID_OXFORD_METRICS_PLC: u32 = 1467;
pub const BLUETOOTH_COMPANY_ID_LEVITON_MFG_CO_INC: u32 = 1468;
pub const BLUETOOTH_COMPANY_ID_ULC_ROBOTICS_INC: u32 = 1469;
pub const BLUETOOTH_COMPANY_ID_RFID_GLOBAL_BY_SOFTWORK_SRL: u32 = 1470;
pub const BLUETOOTH_COMPANY_ID_REAL_WORLD_SYSTEMS_CORPORATION: u32 = 1471;
pub const BLUETOOTH_COMPANY_ID_NALU_MEDICAL_INC: u32 = 1472;
pub const BLUETOOTH_COMPANY_ID_PIENGINEERING: u32 = 1473;
pub const BLUETOOTH_COMPANY_ID_GROTE_INDUSTRIES: u32 = 1474;
pub const BLUETOOTH_COMPANY_ID_RUNTIME_INC: u32 = 1475;
pub const BLUETOOTH_COMPANY_ID_CODECOUP_SP_Z_OO_SP_K: u32 = 1476;
pub const BLUETOOTH_COMPANY_ID_SELVE_GMBH_AND_CO_KG: u32 = 1477;
pub const BLUETOOTH_COMPANY_ID_SMART_ANIMAL_TRAINING_SYSTEMS_LLC: u32 = 1478;
pub const BLUETOOTH_COMPANY_ID_LIPPERT_COMPONENTS_INC: u32 = 1479;
pub const BLUETOOTH_COMPANY_ID_SOMFY_SAS: u32 = 1480;
pub const BLUETOOTH_COMPANY_ID_TBS_ELECTRONICS_BV: u32 = 1481;
pub const BLUETOOTH_COMPANY_ID_MHL_CUSTOM_INC: u32 = 1482;
pub const BLUETOOTH_COMPANY_ID_LUCENTWEAR_LLC: u32 = 1483;
pub const BLUETOOTH_COMPANY_ID_WATTS_ELECTRONICS: u32 = 1484;
pub const BLUETOOTH_COMPANY_ID_RJ_BRANDS_LLC: u32 = 1485;
pub const BLUETOOTH_COMPANY_ID_V_ZUG_LTD: u32 = 1486;
pub const BLUETOOTH_COMPANY_ID_BIOWATCH_SA: u32 = 1487;
pub const BLUETOOTH_COMPANY_ID_ANOVA_APPLIED_ELECTRONICS: u32 = 1488;
pub const BLUETOOTH_COMPANY_ID_LINDAB_AB: u32 = 1489;
pub const BLUETOOTH_COMPANY_ID_FROGBLUE_TECHNOLOGY_GMBH: u32 = 1490;
pub const BLUETOOTH_COMPANY_ID_ACURABLE_LIMITED: u32 = 1491;
pub const BLUETOOTH_COMPANY_ID_LAMPLIGHT_CO_LTD: u32 = 1492;
pub const BLUETOOTH_COMPANY_ID_TEGAM_INC: u32 = 1493;
pub const BLUETOOTH_COMPANY_ID_ZHUHAI_JIELI_TECHNOLOGY_COLTD: u32 = 1494;
pub const BLUETOOTH_COMPANY_ID_MODUMIO_AG: u32 = 1495;
pub const BLUETOOTH_COMPANY_ID_FARM_JENNY_LLC: u32 = 1496;
pub const BLUETOOTH_COMPANY_ID_TOYO_ELECTRONICS_CORPORATION: u32 = 1497;
pub const BLUETOOTH_COMPANY_ID_APPLIED_NEURAL_RESEARCH_CORP: u32 = 1498;
pub const BLUETOOTH_COMPANY_ID_AVID_IDENTIFICATION_SYSTEMS_INC: u32 = 1499;
pub const BLUETOOTH_COMPANY_ID_PETRONICS_INC: u32 = 1500;
pub const BLUETOOTH_COMPANY_ID_ESSENTIM_GMBH: u32 = 1501;
pub const BLUETOOTH_COMPANY_ID_QT_MEDICAL_INC: u32 = 1502;
pub const BLUETOOTH_COMPANY_ID_VIRTUALCLINICDIRECT_LIMITED: u32 = 1503;
pub const BLUETOOTH_COMPANY_ID_VIPER_DESIGN_LLC: u32 = 1504;
pub const BLUETOOTH_COMPANY_ID_HUMAN_INCORPORATED: u32 = 1505;
pub const BLUETOOTH_COMPANY_ID_STAPPTRONICS_GMBH: u32 = 1506;
pub const BLUETOOTH_COMPANY_ID_ELEMENTAL_MACHINES_INC: u32 = 1507;
pub const BLUETOOTH_COMPANY_ID_TAIYO_YUDEN_CO_LTD: u32 = 1508;
pub const BLUETOOTH_COMPANY_ID_INEO_ENERGYAND_SYSTEMS: u32 = 1509;
pub const BLUETOOTH_COMPANY_ID_MOTION_INSTRUMENTS_INC: u32 = 1510;
pub const BLUETOOTH_COMPANY_ID_PRESSUREPRO: u32 = 1511;
pub const BLUETOOTH_COMPANY_ID_COWBOY: u32 = 1512;
pub const BLUETOOTH_COMPANY_ID_ICONMOBILE_GMBH: u32 = 1513;
pub const BLUETOOTH_COMPANY_ID_ACS_CONTROL_SYSTEM_GMBH: u32 = 1514;
pub const BLUETOOTH_COMPANY_ID_BAYERISCHE_MOTOREN_WERKE_AG: u32 = 1515;
pub const BLUETOOTH_COMPANY_ID_GYCOM_SVENSKA_AB: u32 = 1516;
pub const BLUETOOTH_COMPANY_ID_FUJI_XEROX_CO_LTD: u32 = 1517;
pub const BLUETOOTH_COMPANY_ID_GLIDE_INC: u32 = 1518;
pub const BLUETOOTH_COMPANY_ID_SIKOM_AS: u32 = 1519;
pub const BLUETOOTH_COMPANY_ID_BEKEN: u32 = 1520;
pub const BLUETOOTH_COMPANY_ID_THE_LINUX_FOUNDATION: u32 = 1521;
pub const BLUETOOTH_COMPANY_ID_TRY_AND_E_COLTD: u32 = 1522;
pub const BLUETOOTH_COMPANY_ID_SEESCAN: u32 = 1523;
pub const BLUETOOTH_COMPANY_ID_CLEARITY_LLC: u32 = 1524;
pub const BLUETOOTH_COMPANY_ID_GS_TAG: u32 = 1525;
pub const BLUETOOTH_COMPANY_ID_DPTECHNICS: u32 = 1526;
pub const BLUETOOTH_COMPANY_ID_TRACMO_INC: u32 = 1527;
pub const BLUETOOTH_COMPANY_ID_ANKI_INC: u32 = 1528;
pub const BLUETOOTH_COMPANY_ID_HAGLEITNER_HYGIENE_INTERNATIONAL_GMBH: u32 = 1529;
pub const BLUETOOTH_COMPANY_ID_KONAMI_SPORTS_LIFE_CO_LTD: u32 = 1530;
pub const BLUETOOTH_COMPANY_ID_ARBLET_INC: u32 = 1531;
pub const BLUETOOTH_COMPANY_ID_MASBANDO_GMBH: u32 = 1532;
pub const BLUETOOTH_COMPANY_ID_INNOSEIS: u32 = 1533;
pub const BLUETOOTH_COMPANY_ID_NIKO_NV: u32 = 1534;
pub const BLUETOOTH_COMPANY_ID_WELLNOMICS_LTD: u32 = 1535;
pub const BLUETOOTH_COMPANY_ID_IROBOT_CORPORATION: u32 = 1536;
pub const BLUETOOTH_COMPANY_ID_SCHRADER_ELECTRONICS: u32 = 1537;
pub const BLUETOOTH_COMPANY_ID_GEBERIT_INTERNATIONAL_AG: u32 = 1538;
pub const BLUETOOTH_COMPANY_ID_FOURTH_EVOLUTION_INC: u32 = 1539;
pub const BLUETOOTH_COMPANY_ID_CELL2JACK_LLC: u32 = 1540;
pub const BLUETOOTH_COMPANY_ID_FMW_ELECTRONIC_FUTTERER_U_MAIER_WOLF_OHG: u32 = 1541;
pub const BLUETOOTH_COMPANY_ID_JOHN_DEERE: u32 = 1542;
pub const BLUETOOTH_COMPANY_ID_ROOKERY_TECHNOLOGY_LTD: u32 = 1543;
pub const BLUETOOTH_COMPANY_ID_KEYSAFE_CLOUD: u32 = 1544;
pub const BLUETOOTH_COMPANY_ID_BUCHI_LABORTECHNIK_AG: u32 = 1545;
pub const BLUETOOTH_COMPANY_ID_IQAIR_AG: u32 = 1546;
pub const BLUETOOTH_COMPANY_ID_TRIAX_TECHNOLOGIES_INC: u32 = 1547;
pub const BLUETOOTH_COMPANY_ID_VUZIX_CORPORATION: u32 = 1548;
pub const BLUETOOTH_COMPANY_ID_TDK_CORPORATION: u32 = 1549;
pub const BLUETOOTH_COMPANY_ID_BLUEAIR_AB: u32 = 1550;
pub const BLUETOOTH_COMPANY_ID_SIGNIFY_NETHERLANDS: u32 = 1551;
pub const BLUETOOTH_COMPANY_ID_ADH_GUARDIAN_USA_LLC: u32 = 1552;
pub const BLUETOOTH_COMPANY_ID_BEURER_GMBH: u32 = 1553;
pub const BLUETOOTH_COMPANY_ID_PLAYFINITY_AS: u32 = 1554;
pub const BLUETOOTH_COMPANY_ID_HANS_DINSLAGE_GMBH: u32 = 1555;
pub const BLUETOOTH_COMPANY_ID_ONASSET_INTELLIGENCE_INC: u32 = 1556;
pub const BLUETOOTH_COMPANY_ID_INTER_ACTION_CORPORATION: u32 = 1557;
pub const BLUETOOTH_COMPANY_ID_OS42_UG: u32 = 1558;
pub const BLUETOOTH_COMPANY_ID_WIZCONNECTED_COMPANY_LIMITED: u32 = 1559;
pub const BLUETOOTH_COMPANY_ID_AUDIO_TECHNICA_CORPORATION: u32 = 1560;
pub const BLUETOOTH_COMPANY_ID_SIX_GUYS_LABS_SRO: u32 = 1561;
pub const BLUETOOTH_COMPANY_ID_RW_BECKETT_CORPORATION: u32 = 1562;
pub const BLUETOOTH_COMPANY_ID_SILEX_TECHNOLOGY_INC: u32 = 1563;
pub const BLUETOOTH_COMPANY_ID_UNIVATIONS_LIMITED: u32 = 1564;
pub const BLUETOOTH_COMPANY_ID_SENS_INNOVATION_APS: u32 = 1565;
pub const BLUETOOTH_COMPANY_ID_DIAMOND_KINETICS_INC: u32 = 1566;
pub const BLUETOOTH_COMPANY_ID_PHRAME_INC: u32 = 1567;
pub const BLUETOOTH_COMPANY_ID_FORCIOT_OY: u32 = 1568;
pub const BLUETOOTH_COMPANY_ID_NOORDUNG_DOO: u32 = 1569;
pub const BLUETOOTH_COMPANY_ID_BEAM_LABS_LLC: u32 = 1570;
pub const BLUETOOTH_COMPANY_ID_PHILADELPHIA_SCIENTIFIC_LIMITED: u32 = 1571;
pub const BLUETOOTH_COMPANY_ID_BIOVOTION_AG: u32 = 1572;
pub const BLUETOOTH_COMPANY_ID_SQUARE_PANDA_INC: u32 = 1573;
pub const BLUETOOTH_COMPANY_ID_AMPLIFICO: u32 = 1574;
pub const BLUETOOTH_COMPANY_ID_WEG_SA: u32 = 1575;
pub const BLUETOOTH_COMPANY_ID_ENSTO_OY: u32 = 1576;
pub const BLUETOOTH_COMPANY_ID_PHONEPE_PVT_LTD: u32 = 1577;
pub const BLUETOOTH_COMPANY_ID_LUNATICO_ASTRONOMIA_SL: u32 = 1578;
pub const BLUETOOTH_COMPANY_ID_MINEBEAMITSUMI_INC: u32 = 1579;
pub const BLUETOOTH_COMPANY_ID_ASPION_GMBH: u32 = 1580;
pub const BLUETOOTH_COMPANY_ID_VOSSLOH_SCHWABE_DEUTSCHLAND_GMBH: u32 = 1581;
pub const BLUETOOTH_COMPANY_ID_PROCEPT: u32 = 1582;
pub const BLUETOOTH_COMPANY_ID_ONKYO_CORPORATION: u32 = 1583;
pub const BLUETOOTH_COMPANY_ID_ASTHREA_DOO: u32 = 1584;
pub const BLUETOOTH_COMPANY_ID_FORTIORI_DESIGN_LLC: u32 = 1585;
pub const BLUETOOTH_COMPANY_ID_HUGO_MULLER_GMBH_AND_CO_KG: u32 = 1586;
pub const BLUETOOTH_COMPANY_ID_WANGI_LAI_PLT: u32 = 1587;
pub const BLUETOOTH_COMPANY_ID_FANSTEL_CORP: u32 = 1588;
pub const BLUETOOTH_COMPANY_ID_CROOKWOOD: u32 = 1589;
pub const BLUETOOTH_COMPANY_ID_ELECTRONICA_INTEGRAL_DE_SONIDO_SA: u32 = 1590;
pub const BLUETOOTH_COMPANY_ID_GIP_INNOVATION_TOOLS_GMBH: u32 = 1591;
pub const BLUETOOTH_COMPANY_ID_LX_SOLUTIONS_PTY_LIMITED: u32 = 1592;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_MINEW_TECHNOLOGIES_CO_LTD: u32 = 1593;
pub const BLUETOOTH_COMPANY_ID_PROLOJIK_LIMITED: u32 = 1594;
pub const BLUETOOTH_COMPANY_ID_KROMEK_GROUP_PLC: u32 = 1595;
pub const BLUETOOTH_COMPANY_ID_CONTEC_MEDICAL_SYSTEMS_CO_LTD: u32 = 1596;
pub const BLUETOOTH_COMPANY_ID_XRADIO_TECHNOLOGY_COLTD: u32 = 1597;
pub const BLUETOOTH_COMPANY_ID_THE_INDOOR_LAB_LLC: u32 = 1598;
pub const BLUETOOTH_COMPANY_ID_LDL_TECHNOLOGY: u32 = 1599;
pub const BLUETOOTH_COMPANY_ID_PARKIFI: u32 = 1600;
pub const BLUETOOTH_COMPANY_ID_REVENUE_COLLECTION_SYSTEMS_FRANCE_SAS: u32 = 1601;
pub const BLUETOOTH_COMPANY_ID_BLUETRUM_TECHNOLOGY_COLTD: u32 = 1602;
pub const BLUETOOTH_COMPANY_ID_MAKITA_CORPORATION: u32 = 1603;
pub const BLUETOOTH_COMPANY_ID_APOGEE_INSTRUMENTS: u32 = 1604;
pub const BLUETOOTH_COMPANY_ID_BM3: u32 = 1605;
pub const BLUETOOTH_COMPANY_ID_SGV_GROUP_HOLDING_GMBH_AND_CO_KG: u32 = 1606;
pub const BLUETOOTH_COMPANY_ID_MED_EL: u32 = 1607;
pub const BLUETOOTH_COMPANY_ID_ULTUNE_TECHNOLOGIES: u32 = 1608;
pub const BLUETOOTH_COMPANY_ID_RYEEX_TECHNOLOGY_COLTD: u32 = 1609;
pub const BLUETOOTH_COMPANY_ID_OPEN_RESEARCH_INSTITUTE_INC: u32 = 1610;
pub const BLUETOOTH_COMPANY_ID_SCALE_TEC_LTD: u32 = 1611;
pub const BLUETOOTH_COMPANY_ID_ZUMTOBEL_GROUP_AG: u32 = 1612;
pub const BLUETOOTH_COMPANY_ID_ILOQ_OY: u32 = 1613;
pub const BLUETOOTH_COMPANY_ID_KRUXWORKS_TECHNOLOGIES_PRIVATE_LIMITED: u32 = 1614;
pub const BLUETOOTH_COMPANY_ID_DIGITAL_MATTER_PTY_LTD: u32 = 1615;
pub const BLUETOOTH_COMPANY_ID_CORAVIN_INC: u32 = 1616;
pub const BLUETOOTH_COMPANY_ID_STASIS_LABS_INC: u32 = 1617;
pub const BLUETOOTH_COMPANY_ID_ITZ_INNOVATIONS__UND_TECHNOLOGIEZENTRUM_GMBH: u32 = 1618;
pub const BLUETOOTH_COMPANY_ID_MEGGITT_SA: u32 = 1619;
pub const BLUETOOTH_COMPANY_ID_LEDLENSER_GMBH_AND_CO_KG: u32 = 1620;
pub const BLUETOOTH_COMPANY_ID_RENISHAW_PLC: u32 = 1621;
pub const BLUETOOTH_COMPANY_ID_ZHUHAI_ADVANPRO_TECHNOLOGY_COMPANY_LIMITED: u32 = 1622;
pub const BLUETOOTH_COMPANY_ID_MESHTRONIX_LIMITED: u32 = 1623;
pub const BLUETOOTH_COMPANY_ID_PAYEX_NORGE_AS: u32 = 1624;
pub const BLUETOOTH_COMPANY_ID_UNSEEN_TECHNOLOGIES_OY: u32 = 1625;
pub const BLUETOOTH_COMPANY_ID_ZOUND_INDUSTRIES_INTERNATIONAL_AB: u32 = 1626;
pub const BLUETOOTH_COMPANY_ID_SESAM_SOLUTIONS_BV: u32 = 1627;
pub const BLUETOOTH_COMPANY_ID_PIXART_IMAGING_INC: u32 = 1628;
pub const BLUETOOTH_COMPANY_ID_PANDUIT_CORP: u32 = 1629;
pub const BLUETOOTH_COMPANY_ID_ALO_AB: u32 = 1630;
pub const BLUETOOTH_COMPANY_ID_RICOH_COMPANY_LTD: u32 = 1631;
pub const BLUETOOTH_COMPANY_ID_RTC_INDUSTRIES_INC: u32 = 1632;
pub const BLUETOOTH_COMPANY_ID_MODE_LIGHTING_LIMITED: u32 = 1633;
pub const BLUETOOTH_COMPANY_ID_PARTICLE_INDUSTRIES_INC: u32 = 1634;
pub const BLUETOOTH_COMPANY_ID_ADVANCED_TELEMETRY_SYSTEMS_INC: u32 = 1635;
pub const BLUETOOTH_COMPANY_ID_RHA_TECHNOLOGIES_LTD: u32 = 1636;
pub const BLUETOOTH_COMPANY_ID_PURE_INTERNATIONAL_LIMITED: u32 = 1637;
pub const BLUETOOTH_COMPANY_ID_WTO_WERKZEUG_EINRICHTUNGEN_GMBH: u32 = 1638;
pub const BLUETOOTH_COMPANY_ID_SPARK_TECHNOLOGY_LABS_INC: u32 = 1639;
pub const BLUETOOTH_COMPANY_ID_BLEB_TECHNOLOGY_SRL: u32 = 1640;
pub const BLUETOOTH_COMPANY_ID_LIVANOVA_USA_INC: u32 = 1641;
pub const BLUETOOTH_COMPANY_ID_BRADY_WORLDWIDE_INC: u32 = 1642;
pub const BLUETOOTH_COMPANY_ID_DEWERTOKIN_GMBH: u32 = 1643;
pub const BLUETOOTH_COMPANY_ID_ZTOVE_APS: u32 = 1644;
pub const BLUETOOTH_COMPANY_ID_VENSO_ECOSOLUTIONS_AB: u32 = 1645;
pub const BLUETOOTH_COMPANY_ID_EUROTRONIK_KRANJ_DOO: u32 = 1646;
pub const BLUETOOTH_COMPANY_ID_HUG_TECHNOLOGY_LTD: u32 = 1647;
pub const BLUETOOTH_COMPANY_ID_GEMA_SWITZERLAND_GMBH: u32 = 1648;
pub const BLUETOOTH_COMPANY_ID_BUZZ_PRODUCTS_LTD: u32 = 1649;
pub const BLUETOOTH_COMPANY_ID_KOPI: u32 = 1650;
pub const BLUETOOTH_COMPANY_ID_INNOVA_IDEAS_LIMITED: u32 = 1651;
pub const BLUETOOTH_COMPANY_ID_BESPOON: u32 = 1652;
pub const BLUETOOTH_COMPANY_ID_DECO_ENTERPRISES_INC: u32 = 1653;
pub const BLUETOOTH_COMPANY_ID_EXPAI_SOLUTIONS_PRIVATE_LIMITED: u32 = 1654;
pub const BLUETOOTH_COMPANY_ID_INNOVATION_FIRST_INC: u32 = 1655;
pub const BLUETOOTH_COMPANY_ID_SABIK_OFFSHORE_GMBH: u32 = 1656;
pub const BLUETOOTH_COMPANY_ID_4IIII_INNOVATIONS_INC: u32 = 1657;
pub const BLUETOOTH_COMPANY_ID_THE_ENERGY_CONSERVATORY_INC: u32 = 1658;
pub const BLUETOOTH_COMPANY_ID_IFARM_INC: u32 = 1659;
pub const BLUETOOTH_COMPANY_ID_TILE_INC: u32 = 1660;
pub const BLUETOOTH_COMPANY_ID_FORM_ATHLETICA_INC: u32 = 1661;
pub const BLUETOOTH_COMPANY_ID_MBIENTLAB_INC: u32 = 1662;
pub const BLUETOOTH_COMPANY_ID_NETGRID_SNC_DI_BISSOLI_MATTEO_CAMPOREALE_SIMONE_TOGNETTI_FEDERICO:
    u32 = 1663;
pub const BLUETOOTH_COMPANY_ID_MANNKIND_CORPORATION: u32 = 1664;
pub const BLUETOOTH_COMPANY_ID_TRADE_FIDES_AS: u32 = 1665;
pub const BLUETOOTH_COMPANY_ID_PHOTRON_LIMITED: u32 = 1666;
pub const BLUETOOTH_COMPANY_ID_ELTAKO_GMBH: u32 = 1667;
pub const BLUETOOTH_COMPANY_ID_DERMALAPPS_LLC: u32 = 1668;
pub const BLUETOOTH_COMPANY_ID_GREENWALD_INDUSTRIES: u32 = 1669;
pub const BLUETOOTH_COMPANY_ID_INQS_CO_LTD: u32 = 1670;
pub const BLUETOOTH_COMPANY_ID_CHERRY_GMBH: u32 = 1671;
pub const BLUETOOTH_COMPANY_ID_AMSTED_DIGITAL_SOLUTIONS_INC: u32 = 1672;
pub const BLUETOOTH_COMPANY_ID_TACX_BV: u32 = 1673;
pub const BLUETOOTH_COMPANY_ID_RAYTAC_CORPORATION: u32 = 1674;
pub const BLUETOOTH_COMPANY_ID_JIANGSU_TERANOVO_TECH_CO_LTD: u32 = 1675;
pub const BLUETOOTH_COMPANY_ID_CHANGZHOU_SOUND_DRAGON_ELECTRONICS_AND_ACOUSTICS_CO_LTD: u32 = 1676;
pub const BLUETOOTH_COMPANY_ID_JETBEEP_INC: u32 = 1677;
pub const BLUETOOTH_COMPANY_ID_RAZER_INC: u32 = 1678;
pub const BLUETOOTH_COMPANY_ID_JRM_GROUP_LIMITED: u32 = 1679;
pub const BLUETOOTH_COMPANY_ID_ECCRINE_SYSTEMS_INC: u32 = 1680;
pub const BLUETOOTH_COMPANY_ID_CURIE_POINT_AB: u32 = 1681;
pub const BLUETOOTH_COMPANY_ID_GEORG_FISCHER_AG: u32 = 1682;
pub const BLUETOOTH_COMPANY_ID_HACH_DANAHER: u32 = 1683;
pub const BLUETOOTH_COMPANY_ID_TANDA_LABORATORIES_LLC: u32 = 1684;
pub const BLUETOOTH_COMPANY_ID_KOKI_HOLDINGS_CO_LTD: u32 = 1685;
pub const BLUETOOTH_COMPANY_ID_GUNAKAR_PRIVATE_LIMITED: u32 = 1686;
pub const BLUETOOTH_COMPANY_ID_STEMCO_PRODUCTS_INC: u32 = 1687;
pub const BLUETOOTH_COMPANY_ID_WOOD_IT_SECURITY_LLC: u32 = 1688;
pub const BLUETOOTH_COMPANY_ID_RANDOMLAB_SAS: u32 = 1689;
pub const BLUETOOTH_COMPANY_ID_ADERO_INC: u32 = 1690;
pub const BLUETOOTH_COMPANY_ID_DRAGONCHIP_LIMITED: u32 = 1691;
pub const BLUETOOTH_COMPANY_ID_NOOMI_AB: u32 = 1692;
pub const BLUETOOTH_COMPANY_ID_VAKAROS_LLC: u32 = 1693;
pub const BLUETOOTH_COMPANY_ID_DELTA_ELECTRONICS_INC: u32 = 1694;
pub const BLUETOOTH_COMPANY_ID_FLOWMOTION_TECHNOLOGIES_AS: u32 = 1695;
pub const BLUETOOTH_COMPANY_ID_OBIQ_LOCATION_TECHNOLOGY_INC: u32 = 1696;
pub const BLUETOOTH_COMPANY_ID_CARDO_SYSTEMS_LTD: u32 = 1697;
pub const BLUETOOTH_COMPANY_ID_GLOBALWORX_GMBH: u32 = 1698;
pub const BLUETOOTH_COMPANY_ID_NYMBUS_LLC: u32 = 1699;
pub const BLUETOOTH_COMPANY_ID_SANYO_TECHNO_SOLUTIONS_TOTTORI_CO_LTD: u32 = 1700;
pub const BLUETOOTH_COMPANY_ID_TEKZITEL_PTY_LTD: u32 = 1701;
pub const BLUETOOTH_COMPANY_ID_ROAMBEE_CORPORATION: u32 = 1702;
pub const BLUETOOTH_COMPANY_ID_CHIPSEA_TECHNOLOGIES_CORP: u32 = 1703;
pub const BLUETOOTH_COMPANY_ID_GD_MIDEA_AIR_CONDITIONING_EQUIPMENT_CO_LTD: u32 = 1704;
pub const BLUETOOTH_COMPANY_ID_SOUNDMAX_ELECTRONICS_LIMITED: u32 = 1705;
pub const BLUETOOTH_COMPANY_ID_PRODUAL_OY: u32 = 1706;
pub const BLUETOOTH_COMPANY_ID_HMS_INDUSTRIAL_NETWORKS_AB: u32 = 1707;
pub const BLUETOOTH_COMPANY_ID_INGCHIPS_TECHNOLOGY_CO_LTD: u32 = 1708;
pub const BLUETOOTH_COMPANY_ID_INNOVASEA_SYSTEMS_INC: u32 = 1709;
pub const BLUETOOTH_COMPANY_ID_SENSEQ_INC: u32 = 1710;
pub const BLUETOOTH_COMPANY_ID_SHOOF_TECHNOLOGIES: u32 = 1711;
pub const BLUETOOTH_COMPANY_ID_BRK_BRANDS_INC: u32 = 1712;
pub const BLUETOOTH_COMPANY_ID_SIMPLISAFE_INC: u32 = 1713;
pub const BLUETOOTH_COMPANY_ID_TUSSOCK_INNOVATION_2013_LIMITED: u32 = 1714;
pub const BLUETOOTH_COMPANY_ID_THE_HABLAB_APS: u32 = 1715;
pub const BLUETOOTH_COMPANY_ID_SENCILION_OY: u32 = 1716;
pub const BLUETOOTH_COMPANY_ID_WABILOGIC_LTD: u32 = 1717;
pub const BLUETOOTH_COMPANY_ID_SOCIOMETRIC_SOLUTIONS_INC: u32 = 1718;
pub const BLUETOOTH_COMPANY_ID_ICOGNIZE_GMBH: u32 = 1719;
pub const BLUETOOTH_COMPANY_ID_SHADECRAFT_INC: u32 = 1720;
pub const BLUETOOTH_COMPANY_ID_BEFLEX_INC: u32 = 1721;
pub const BLUETOOTH_COMPANY_ID_BEACONZONE_LTD: u32 = 1722;
pub const BLUETOOTH_COMPANY_ID_LEAFTRONIX_ANALOGIC_SOLUTIONS_PRIVATE_LIMITED: u32 = 1723;
pub const BLUETOOTH_COMPANY_ID_TWS_SRL: u32 = 1724;
pub const BLUETOOTH_COMPANY_ID_ABB_OY: u32 = 1725;
pub const BLUETOOTH_COMPANY_ID_HITSEED_OY: u32 = 1726;
pub const BLUETOOTH_COMPANY_ID_DELCOM_PRODUCTS_INC: u32 = 1727;
pub const BLUETOOTH_COMPANY_ID_CAME_SPA: u32 = 1728;
pub const BLUETOOTH_COMPANY_ID_ALARMCOM_HOLDINGS_INC: u32 = 1729;
pub const BLUETOOTH_COMPANY_ID_MEASURLOGIC_INC: u32 = 1730;
pub const BLUETOOTH_COMPANY_ID_KING_I_ELECTRONICSCOLTD: u32 = 1731;
pub const BLUETOOTH_COMPANY_ID_DREAM_LABS_GMBH: u32 = 1732;
pub const BLUETOOTH_COMPANY_ID_URBAN_COMPASS_INC: u32 = 1733;
pub const BLUETOOTH_COMPANY_ID_SIMM_TRONIC_LIMITED: u32 = 1734;
pub const BLUETOOTH_COMPANY_ID_SOMATIX_INC: u32 = 1735;
pub const BLUETOOTH_COMPANY_ID_STORZ_AND_BICKEL_GMBH_AND_CO_KG: u32 = 1736;
pub const BLUETOOTH_COMPANY_ID_MYLAPS_BV: u32 = 1737;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_ZHONGGUANG_INFOTECH_TECHNOLOGY_DEVELOPMENT_CO_LTD: u32 =
    1738;
pub const BLUETOOTH_COMPANY_ID_DYEWARE_LLC: u32 = 1739;
pub const BLUETOOTH_COMPANY_ID_DONGGUAN_SMARTACTION_TECHNOLOGY_COLTD: u32 = 1740;
pub const BLUETOOTH_COMPANY_ID_DIG_CORPORATION: u32 = 1741;
pub const BLUETOOTH_COMPANY_ID_FIOR_AND_GENTZ: u32 = 1742;
pub const BLUETOOTH_COMPANY_ID_BELPARTS_NV: u32 = 1743;
pub const BLUETOOTH_COMPANY_ID_ETEKCITY_CORPORATION: u32 = 1744;
pub const BLUETOOTH_COMPANY_ID_MEYER_SOUND_LABORATORIES_INCORPORATED: u32 = 1745;
pub const BLUETOOTH_COMPANY_ID_CEOTRONICS_AG: u32 = 1746;
pub const BLUETOOTH_COMPANY_ID_TRITEQ_LOCK_AND_SECURITY_LLC: u32 = 1747;
pub const BLUETOOTH_COMPANY_ID_DYNAKODE_TECHNOLOGY_PRIVATE_LIMITED: u32 = 1748;
pub const BLUETOOTH_COMPANY_ID_SENSIRION_AG: u32 = 1749;
pub const BLUETOOTH_COMPANY_ID_JCT_HEALTHCARE_PTY_LTD: u32 = 1750;
pub const BLUETOOTH_COMPANY_ID_FUBA_AUTOMOTIVE_ELECTRONICS_GMBH: u32 = 1751;
pub const BLUETOOTH_COMPANY_ID_AW_COMPANY: u32 = 1752;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_MOUNTAIN_VIEW_SILICON_COLTD: u32 = 1753;
pub const BLUETOOTH_COMPANY_ID_ZLIIDE_TECHNOLOGIES_APS: u32 = 1754;
pub const BLUETOOTH_COMPANY_ID_AUTOMATIC_LABS_INC: u32 = 1755;
pub const BLUETOOTH_COMPANY_ID_INDUSTRIAL_NETWORK_CONTROLS_LLC: u32 = 1756;
pub const BLUETOOTH_COMPANY_ID_INTELLITHINGS_LTD: u32 = 1757;
pub const BLUETOOTH_COMPANY_ID_NAVCAST_INC: u32 = 1758;
pub const BLUETOOTH_COMPANY_ID_HUBBELL_LIGHTING_INC: u32 = 1759;
pub const BLUETOOTH_COMPANY_ID_AVAYA: u32 = 1760;
pub const BLUETOOTH_COMPANY_ID_MILESTONE_AV_TECHNOLOGIES_LLC: u32 = 1761;
pub const BLUETOOTH_COMPANY_ID_ALANGO_TECHNOLOGIES_LTD: u32 = 1762;
pub const BLUETOOTH_COMPANY_ID_SPINLOCK_LTD: u32 = 1763;
pub const BLUETOOTH_COMPANY_ID_ALUNA: u32 = 1764;
pub const BLUETOOTH_COMPANY_ID_OPTEX_COLTD: u32 = 1765;
pub const BLUETOOTH_COMPANY_ID_NIHON_DENGYO_KOUSAKU: u32 = 1766;
pub const BLUETOOTH_COMPANY_ID_VELUX_A_S: u32 = 1767;
pub const BLUETOOTH_COMPANY_ID_ALMENDO_TECHNOLOGIES_GMBH: u32 = 1768;
pub const BLUETOOTH_COMPANY_ID_ZMARTFUN_ELECTRONICS_INC: u32 = 1769;
pub const BLUETOOTH_COMPANY_ID_SAFELINE_SWEDEN_AB: u32 = 1770;
pub const BLUETOOTH_COMPANY_ID_HOUSTON_RADAR_LLC: u32 = 1771;
pub const BLUETOOTH_COMPANY_ID_SIGUR: u32 = 1772;
pub const BLUETOOTH_COMPANY_ID_J_NEADES_LTD: u32 = 1773;
pub const BLUETOOTH_COMPANY_ID_AVANTIS_SYSTEMS_LIMITED: u32 = 1774;
pub const BLUETOOTH_COMPANY_ID_ALCARE_CO_LTD: u32 = 1775;
pub const BLUETOOTH_COMPANY_ID_CHARGY_TECHNOLOGIES_SL: u32 = 1776;
pub const BLUETOOTH_COMPANY_ID_SHIBUTANI_CO_LTD: u32 = 1777;
pub const BLUETOOTH_COMPANY_ID_TRAPPER_DATA_AB: u32 = 1778;
pub const BLUETOOTH_COMPANY_ID_ALFRED_INTERNATIONAL_INC: u32 = 1779;
pub const BLUETOOTH_COMPANY_ID_NEAR_FIELD_SOLUTIONS_LTD: u32 = 1780;
pub const BLUETOOTH_COMPANY_ID_VIGIL_TECHNOLOGIES_INC: u32 = 1781;
pub const BLUETOOTH_COMPANY_ID_VITULO_PLUS_BV: u32 = 1782;
pub const BLUETOOTH_COMPANY_ID_WILKA_SCHLIESSTECHNIK_GMBH: u32 = 1783;
pub const BLUETOOTH_COMPANY_ID_BODYPLUS_TECHNOLOGY_COLTD: u32 = 1784;
pub const BLUETOOTH_COMPANY_ID_HAPPYBRUSH_GMBH: u32 = 1785;
pub const BLUETOOTH_COMPANY_ID_ENEQUI_AB: u32 = 1786;
pub const BLUETOOTH_COMPANY_ID_SARTORIUS_AG: u32 = 1787;
pub const BLUETOOTH_COMPANY_ID_TOM_COMMUNICATION_INDUSTRIAL_COLTD: u32 = 1788;
pub const BLUETOOTH_COMPANY_ID_ESS_EMBEDDED_SYSTEM_SOLUTIONS_INC: u32 = 1789;
pub const BLUETOOTH_COMPANY_ID_MAHR_GMBH: u32 = 1790;
pub const BLUETOOTH_COMPANY_ID_REDPINE_SIGNALS_INC: u32 = 1791;
pub const BLUETOOTH_COMPANY_ID_TRAQFREQ_LLC: u32 = 1792;
pub const BLUETOOTH_COMPANY_ID_PAFERS_TECH: u32 = 1793;
pub const BLUETOOTH_COMPANY_ID_AKCIJU_SABIEDRIBA__SAF_TEHNIKA_: u32 = 1794;
pub const BLUETOOTH_COMPANY_ID_BEIJING_JINGDONG_CENTURY_TRADING_CO_LTD: u32 = 1795;
pub const BLUETOOTH_COMPANY_ID_JBX_DESIGNS_INC: u32 = 1796;
pub const BLUETOOTH_COMPANY_ID_AB_ELECTROLUX: u32 = 1797;
pub const BLUETOOTH_COMPANY_ID_WERNHER_VON_BRAUN_CENTER_FOR_ASDVANCED_RESEARCH: u32 = 1798;
pub const BLUETOOTH_COMPANY_ID_ESSITY_HYGIENE_AND_HEALTH_AKTIEBOLAG: u32 = 1799;
pub const BLUETOOTH_COMPANY_ID_BE_INTERACTIVE_CO_LTD: u32 = 1800;
pub const BLUETOOTH_COMPANY_ID_CAREWEAR_CORP: u32 = 1801;
pub const BLUETOOTH_COMPANY_ID_HUF_HLSBECK_AND_FRST_GMBH_AND_CO_KG: u32 = 1802;
pub const BLUETOOTH_COMPANY_ID_ELEMENT_PRODUCTS_INC: u32 = 1803;
pub const BLUETOOTH_COMPANY_ID_BEIJING_WINNER_MICROELECTRONICS_COLTD: u32 = 1804;
pub const BLUETOOTH_COMPANY_ID_SMARTSNUGG_PTY_LTD: u32 = 1805;
pub const BLUETOOTH_COMPANY_ID_FIVECO_SARL: u32 = 1806;
pub const BLUETOOTH_COMPANY_ID_CALIFORNIA_THINGS_INC: u32 = 1807;
pub const BLUETOOTH_COMPANY_ID_AUDIODO_AB: u32 = 1808;
pub const BLUETOOTH_COMPANY_ID_ABAX_AS: u32 = 1809;
pub const BLUETOOTH_COMPANY_ID_BULL_GROUP_COMPANY_LIMITED: u32 = 1810;
pub const BLUETOOTH_COMPANY_ID_RESPIRI_LIMITED: u32 = 1811;
pub const BLUETOOTH_COMPANY_ID_MINDPEACE_SAFETY_LLC: u32 = 1812;
pub const BLUETOOTH_COMPANY_ID_VGYAN_SOLUTIONS: u32 = 1813;
pub const BLUETOOTH_COMPANY_ID_ALTONICS: u32 = 1814;
pub const BLUETOOTH_COMPANY_ID_IQSQUARE_BV: u32 = 1815;
pub const BLUETOOTH_COMPANY_ID_IDIBAIX_ENGINNEERING: u32 = 1816;
pub const BLUETOOTH_COMPANY_ID_ECSG: u32 = 1817;
pub const BLUETOOTH_COMPANY_ID_REVSMART_WEARABLE_HK_CO_LTD: u32 = 1818;
pub const BLUETOOTH_COMPANY_ID_PRECOR: u32 = 1819;
pub const BLUETOOTH_COMPANY_ID_F5_SPORTS_INC: u32 = 1820;
pub const BLUETOOTH_COMPANY_ID_EXOTIC_SYSTEMS: u32 = 1821;
pub const BLUETOOTH_COMPANY_ID_DONGGUAN_HELE_ELECTRONICS_CO_LTD: u32 = 1822;
pub const BLUETOOTH_COMPANY_ID_DONGGUAN_LIESHENG_ELECTRONIC_COLTD: u32 = 1823;
pub const BLUETOOTH_COMPANY_ID_OCULEVE_INC: u32 = 1824;
pub const BLUETOOTH_COMPANY_ID_CLOVER_NETWORK_INC: u32 = 1825;
pub const BLUETOOTH_COMPANY_ID_XIAMEN_EHOLDER_ELECTRONICS_COLTD: u32 = 1826;
pub const BLUETOOTH_COMPANY_ID_FORD_MOTOR_COMPANY: u32 = 1827;
pub const BLUETOOTH_COMPANY_ID_GUANGZHOU_SUPERSOUND_INFORMATION_TECHNOLOGY_COLTD: u32 = 1828;
pub const BLUETOOTH_COMPANY_ID_TEDEE_SP_Z_OO: u32 = 1829;
pub const BLUETOOTH_COMPANY_ID_PHC_CORPORATION: u32 = 1830;
pub const BLUETOOTH_COMPANY_ID_STALKIT_AS: u32 = 1831;
pub const BLUETOOTH_COMPANY_ID_ELI_LILLY_AND_COMPANY: u32 = 1832;
pub const BLUETOOTH_COMPANY_ID_SWARALINK_TECHNOLOGIES: u32 = 1833;
pub const BLUETOOTH_COMPANY_ID_JMR_EMBEDDED_SYSTEMS_GMBH: u32 = 1834;
pub const BLUETOOTH_COMPANY_ID_BITKEY_INC: u32 = 1835;
pub const BLUETOOTH_COMPANY_ID_GWA_HYGIENE_GMBH: u32 = 1836;
pub const BLUETOOTH_COMPANY_ID_SAFERA_OY: u32 = 1837;
pub const BLUETOOTH_COMPANY_ID_OPEN_PLATFORM_SYSTEMS_LLC: u32 = 1838;
pub const BLUETOOTH_COMPANY_ID_ONEPLUS_ELECTRONICS_CO_LTD: u32 = 1839;
pub const BLUETOOTH_COMPANY_ID_WILDLIFE_ACOUSTICS_INC: u32 = 1840;
pub const BLUETOOTH_COMPANY_ID_ABLIC_INC: u32 = 1841;
pub const BLUETOOTH_COMPANY_ID_DAIRY_TECH_INC: u32 = 1842;
pub const BLUETOOTH_COMPANY_ID_IGUANAVATION_INC: u32 = 1843;
pub const BLUETOOTH_COMPANY_ID_DIUS_COMPUTING_PTY_LTD: u32 = 1844;
pub const BLUETOOTH_COMPANY_ID_UPRIGHT_TECHNOLOGIES_LTD: u32 = 1845;
pub const BLUETOOTH_COMPANY_ID_FRANCISFUND_LLC: u32 = 1846;
pub const BLUETOOTH_COMPANY_ID_LLC_NAVITEK: u32 = 1847;
pub const BLUETOOTH_COMPANY_ID_GLASS_SECURITY_PTE_LTD: u32 = 1848;
pub const BLUETOOTH_COMPANY_ID_JIANGSU_QINHENG_CO_LTD: u32 = 1849;
pub const BLUETOOTH_COMPANY_ID_CHANDLER_SYSTEMS_INC: u32 = 1850;
pub const BLUETOOTH_COMPANY_ID_FANTINI_COSMI_SPA: u32 = 1851;
pub const BLUETOOTH_COMPANY_ID_ACUBIT_APS: u32 = 1852;
pub const BLUETOOTH_COMPANY_ID_BEIJING_HAO_HENG_TIAN_TECH_CO_LTD: u32 = 1853;
pub const BLUETOOTH_COMPANY_ID_BLUEPACK_SRL: u32 = 1854;
pub const BLUETOOTH_COMPANY_ID_BEIJING_UNISOC_TECHNOLOGIES_CO_LTD: u32 = 1855;
pub const BLUETOOTH_COMPANY_ID_HITIQ_LIMITED: u32 = 1856;
pub const BLUETOOTH_COMPANY_ID_MAC_SRL: u32 = 1857;
pub const BLUETOOTH_COMPANY_ID_DML_LLC: u32 = 1858;
pub const BLUETOOTH_COMPANY_ID_SANOFI: u32 = 1859;
pub const BLUETOOTH_COMPANY_ID_SOCOMEC: u32 = 1860;
pub const BLUETOOTH_COMPANY_ID_WIZNOVA_INC: u32 = 1861;
pub const BLUETOOTH_COMPANY_ID_SEITEC_ELEKTRONIK_GMBH: u32 = 1862;
pub const BLUETOOTH_COMPANY_ID_OR_TECHNOLOGIES_PTY_LTD: u32 = 1863;
pub const BLUETOOTH_COMPANY_ID_GUANGZHOU_KUGOU_COMPUTER_TECHNOLOGY_COLTD: u32 = 1864;
pub const BLUETOOTH_COMPANY_ID_DIAODIAO_TECHNOLOGY_CO_LTD: u32 = 1865;
pub const BLUETOOTH_COMPANY_ID_ILLUSORY_STUDIOS_LLC: u32 = 1866;
pub const BLUETOOTH_COMPANY_ID_SARVAVID_SOFTWARE_SOLUTIONS_LLP: u32 = 1867;
pub const BLUETOOTH_COMPANY_ID_IOPOOL_SA: u32 = 1868;
pub const BLUETOOTH_COMPANY_ID_AMTECH_SYSTEMS_LLC: u32 = 1869;
pub const BLUETOOTH_COMPANY_ID_EAGLE_DETECTION_SA: u32 = 1870;
pub const BLUETOOTH_COMPANY_ID_MEDIATECH_SRL: u32 = 1871;
pub const BLUETOOTH_COMPANY_ID_HAMILTON_PROFESSIONAL_SERVICES_OF_CANADA_INCORPORATED: u32 = 1872;
pub const BLUETOOTH_COMPANY_ID_CHANGSHA_JEMO_IC_DESIGN_COLTD: u32 = 1873;
pub const BLUETOOTH_COMPANY_ID_ELATEC_GMBH: u32 = 1874;
pub const BLUETOOTH_COMPANY_ID_JLG_INDUSTRIES_INC: u32 = 1875;
pub const BLUETOOTH_COMPANY_ID_MICHAEL_PARKIN: u32 = 1876;
pub const BLUETOOTH_COMPANY_ID_BROTHER_INDUSTRIES_LTD: u32 = 1877;
pub const BLUETOOTH_COMPANY_ID_LUMENS_FOR_LESS_INC: u32 = 1878;
pub const BLUETOOTH_COMPANY_ID_ELA_INNOVATION: u32 = 1879;
pub const BLUETOOTH_COMPANY_ID_UMANSENSE_AB: u32 = 1880;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_INGEEK_CYBER_SECURITY_CO_LTD: u32 = 1881;
pub const BLUETOOTH_COMPANY_ID_HARMAN_COLTD: u32 = 1882;
pub const BLUETOOTH_COMPANY_ID_SMART_SENSOR_DEVICES_AB: u32 = 1883;
pub const BLUETOOTH_COMPANY_ID_ANTITRONICS_INC: u32 = 1884;
pub const BLUETOOTH_COMPANY_ID_RHOMBUS_SYSTEMS_INC: u32 = 1885;
pub const BLUETOOTH_COMPANY_ID_KATERRA_INC: u32 = 1886;
pub const BLUETOOTH_COMPANY_ID_REMOTE_SOLUTION_CO_LTD: u32 = 1887;
pub const BLUETOOTH_COMPANY_ID_VIMAR_SPA: u32 = 1888;
pub const BLUETOOTH_COMPANY_ID_MANTIS_TECH_LLC: u32 = 1889;
pub const BLUETOOTH_COMPANY_ID_TEROPTA_LTD: u32 = 1890;
pub const BLUETOOTH_COMPANY_ID_PIKOLIN_SL: u32 = 1891;
pub const BLUETOOTH_COMPANY_ID_WWZN_INFORMATION_TECHNOLOGY_COMPANY_LIMITED: u32 = 1892;
pub const BLUETOOTH_COMPANY_ID_VOXX_INTERNATIONAL: u32 = 1893;
pub const BLUETOOTH_COMPANY_ID_ART_AND_PROGRAM_INC: u32 = 1894;
pub const BLUETOOTH_COMPANY_ID_NITTO_DENKO_ASIA_TECHNICAL_CENTRE_PTE_LTD: u32 = 1895;
pub const BLUETOOTH_COMPANY_ID_PELOTON_INTERACTIVE_INC: u32 = 1896;
pub const BLUETOOTH_COMPANY_ID_FORCE_IMPACT_TECHNOLOGIES: u32 = 1897;
pub const BLUETOOTH_COMPANY_ID_DMAC_MOBILE_DEVELOPMENTS_LLC: u32 = 1898;
pub const BLUETOOTH_COMPANY_ID_ENGINEERED_MEDICAL_TECHNOLOGIES: u32 = 1899;
pub const BLUETOOTH_COMPANY_ID_NOODLE_TECHNOLOGY_INC: u32 = 1900;
pub const BLUETOOTH_COMPANY_ID_GRAESSLIN_GMBH: u32 = 1901;
pub const BLUETOOTH_COMPANY_ID_WUQI_TECHNOLOGIES_INC: u32 = 1902;
pub const BLUETOOTH_COMPANY_ID_SUCCESSFUL_ENDEAVOURS_PTY_LTD: u32 = 1903;
pub const BLUETOOTH_COMPANY_ID_INNOCON_MEDICAL_APS: u32 = 1904;
pub const BLUETOOTH_COMPANY_ID_CORVEX_CONNECTED_SAFETY: u32 = 1905;
pub const BLUETOOTH_COMPANY_ID_THIRDWAYV_INC: u32 = 1906;
pub const BLUETOOTH_COMPANY_ID_ECHOFLEX_SOLUTIONS_INC: u32 = 1907;
pub const BLUETOOTH_COMPANY_ID_C_MAX_ASIA_LIMITED: u32 = 1908;
pub const BLUETOOTH_COMPANY_ID_4EBUSINESS_GMBH: u32 = 1909;
pub const BLUETOOTH_COMPANY_ID_CYBER_TRANSPORT_CONTROL_GMBH: u32 = 1910;
pub const BLUETOOTH_COMPANY_ID_CUE: u32 = 1911;
pub const BLUETOOTH_COMPANY_ID_KOAMTAC_INC: u32 = 1912;
pub const BLUETOOTH_COMPANY_ID_LOOPSHORE_OY: u32 = 1913;
pub const BLUETOOTH_COMPANY_ID_NIRUHA_SYSTEMS_PRIVATE_LIMITED: u32 = 1914;
pub const BLUETOOTH_COMPANY_ID_AMATERZ_INC: u32 = 1915;
pub const BLUETOOTH_COMPANY_ID_RADIUS_CO_LTD: u32 = 1916;
pub const BLUETOOTH_COMPANY_ID_SENSORITY_SRO: u32 = 1917;
pub const BLUETOOTH_COMPANY_ID_SPARKAGE_INC: u32 = 1918;
pub const BLUETOOTH_COMPANY_ID_GLENVIEW_SOFTWARE_CORPORATION: u32 = 1919;
pub const BLUETOOTH_COMPANY_ID_FINCH_TECHNOLOGIES_LTD: u32 = 1920;
pub const BLUETOOTH_COMPANY_ID_QINGPING_TECHNOLOGY_CO_LTD: u32 = 1921;
pub const BLUETOOTH_COMPANY_ID_DEVICEDRIVE_AS: u32 = 1922;
pub const BLUETOOTH_COMPANY_ID_ESEMBER_LIMITED_LIABILITY_COMPANY: u32 = 1923;
pub const BLUETOOTH_COMPANY_ID_AUDIFON_GMBH_AND_CO_KG: u32 = 1924;
pub const BLUETOOTH_COMPANY_ID_O2_MICRO_INC: u32 = 1925;
pub const BLUETOOTH_COMPANY_ID_HLP_CONTROLS_PTY_LIMITED: u32 = 1926;
pub const BLUETOOTH_COMPANY_ID_PANGAEA_SOLUTION: u32 = 1927;
pub const BLUETOOTH_COMPANY_ID_BUBBLYNET_LLC: u32 = 1928;
pub const BLUETOOTH_COMPANY_ID_THE_WILDFLOWER_FOUNDATION: u32 = 1930;
pub const BLUETOOTH_COMPANY_ID_OPTIKAM_TECH_INC: u32 = 1931;
pub const BLUETOOTH_COMPANY_ID_MINIBREW_HOLDING_BV: u32 = 1932;
pub const BLUETOOTH_COMPANY_ID_CYBEX_GMBH: u32 = 1933;
pub const BLUETOOTH_COMPANY_ID_FUJIMIC_NIIGATA_INC: u32 = 1934;
pub const BLUETOOTH_COMPANY_ID_HANNA_INSTRUMENTS_INC: u32 = 1935;
pub const BLUETOOTH_COMPANY_ID_KOMPAN_A_S: u32 = 1936;
pub const BLUETOOTH_COMPANY_ID_SCOSCHE_INDUSTRIES_INC: u32 = 1937;
pub const BLUETOOTH_COMPANY_ID_PROVO_CRAFT: u32 = 1938;
pub const BLUETOOTH_COMPANY_ID_AEV_SPOL_S_RO: u32 = 1939;
pub const BLUETOOTH_COMPANY_ID_THE_COCA_COLA_COMPANY: u32 = 1940;
pub const BLUETOOTH_COMPANY_ID_GASTEC_CORPORATION: u32 = 1941;
pub const BLUETOOTH_COMPANY_ID_STARLEAF_LTD: u32 = 1942;
pub const BLUETOOTH_COMPANY_ID_WATER_ID_GMBH: u32 = 1943;
pub const BLUETOOTH_COMPANY_ID_HOLOKIT_INC: u32 = 1944;
pub const BLUETOOTH_COMPANY_ID_PLANTCHOIR_INC: u32 = 1945;
pub const BLUETOOTH_COMPANY_ID_GUANGDONG_OPPO_MOBILE_TELECOMMUNICATIONS_CORP_LTD: u32 = 1946;
pub const BLUETOOTH_COMPANY_ID_CST_ELECTRONICS_LIMITED: u32 = 1947;
pub const BLUETOOTH_COMPANY_ID_SKY_UK_LIMITED: u32 = 1948;
pub const BLUETOOTH_COMPANY_ID_DIGIBALE_PTY_LTD: u32 = 1949;
pub const BLUETOOTH_COMPANY_ID_SMARTLOXX_GMBH: u32 = 1950;
pub const BLUETOOTH_COMPANY_ID_PUNE_SCIENTIFIC_LLP: u32 = 1951;
pub const BLUETOOTH_COMPANY_ID_REGENT_BELEUCHTUNGSKORPER_AG: u32 = 1952;
pub const BLUETOOTH_COMPANY_ID_APOLLO_NEUROSCIENCE_INC: u32 = 1953;
pub const BLUETOOTH_COMPANY_ID_ROKU_INC: u32 = 1954;
pub const BLUETOOTH_COMPANY_ID_COMCAST_CABLE: u32 = 1955;
pub const BLUETOOTH_COMPANY_ID_XIAMEN_MAGE_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 1956;
pub const BLUETOOTH_COMPANY_ID_RAB_LIGHTING_INC: u32 = 1957;
pub const BLUETOOTH_COMPANY_ID_MUSEN_CONNECT_INC: u32 = 1958;
pub const BLUETOOTH_COMPANY_ID_ZUME_INC: u32 = 1959;
pub const BLUETOOTH_COMPANY_ID_CONBEE_GMBH: u32 = 1960;
pub const BLUETOOTH_COMPANY_ID_BRUEL_AND_KJAER_SOUND_AND_VIBRATION: u32 = 1961;
pub const BLUETOOTH_COMPANY_ID_THE_KROGER_CO: u32 = 1962;
pub const BLUETOOTH_COMPANY_ID_GRANITE_RIVER_SOLUTIONS_INC: u32 = 1963;
pub const BLUETOOTH_COMPANY_ID_LOUPEDECK_OY: u32 = 1964;
pub const BLUETOOTH_COMPANY_ID_NEW_H3C_TECHNOLOGIES_COLTD: u32 = 1965;
pub const BLUETOOTH_COMPANY_ID_AUREA_SOLUCOES_TECNOLOGICAS_LTDA: u32 = 1966;
pub const BLUETOOTH_COMPANY_ID_HONG_KONG_BOUFFALO_LAB_LIMITED: u32 = 1967;
pub const BLUETOOTH_COMPANY_ID_GV_CONCEPTS_INC: u32 = 1968;
pub const BLUETOOTH_COMPANY_ID_THOMAS_DYNAMICS_LLC: u32 = 1969;
pub const BLUETOOTH_COMPANY_ID_MOECO_IOT_INC: u32 = 1970;
pub const BLUETOOTH_COMPANY_ID_2N_TELEKOMUNIKACE_AS: u32 = 1971;
pub const BLUETOOTH_COMPANY_ID_HORMANN_KG_ANTRIEBSTECHNIK: u32 = 1972;
pub const BLUETOOTH_COMPANY_ID_CRONO_CHIP_SL: u32 = 1973;
pub const BLUETOOTH_COMPANY_ID_SOUNDBRENNER_LIMITED: u32 = 1974;
pub const BLUETOOTH_COMPANY_ID_ETABLISSEMENTS_GEORGES_RENAULT: u32 = 1975;
pub const BLUETOOTH_COMPANY_ID_ISWIP: u32 = 1976;
pub const BLUETOOTH_COMPANY_ID_EPONA_BIOTEC_LIMITED: u32 = 1977;
pub const BLUETOOTH_COMPANY_ID_BATTERY_BIZ_INC: u32 = 1978;
pub const BLUETOOTH_COMPANY_ID_EPIC_SRL: u32 = 1979;
pub const BLUETOOTH_COMPANY_ID_KD_CIRCUITS_LLC: u32 = 1980;
pub const BLUETOOTH_COMPANY_ID_GENEDRIVE_DIAGNOSTICS_LTD: u32 = 1981;
pub const BLUETOOTH_COMPANY_ID_AXENTIA_TECHNOLOGIES_AB: u32 = 1982;
pub const BLUETOOTH_COMPANY_ID_REGULA_LTD: u32 = 1983;
pub const BLUETOOTH_COMPANY_ID_BIRAL_AG: u32 = 1984;
pub const BLUETOOTH_COMPANY_ID_AW_CHESTERTON_COMPANY: u32 = 1985;
pub const BLUETOOTH_COMPANY_ID_RADINN_AB: u32 = 1986;
pub const BLUETOOTH_COMPANY_ID_CIMTECHNIQUES_INC: u32 = 1987;
pub const BLUETOOTH_COMPANY_ID_JOHNSON_HEALTH_TECH_NA: u32 = 1988;
pub const BLUETOOTH_COMPANY_ID_JUNE_LIFE_INC: u32 = 1989;
pub const BLUETOOTH_COMPANY_ID_BLUENETICS_GMBH: u32 = 1990;
pub const BLUETOOTH_COMPANY_ID_IACONICDESIGN_INC: u32 = 1991;
pub const BLUETOOTH_COMPANY_ID_WRLDS_CREATIONS_AB: u32 = 1992;
pub const BLUETOOTH_COMPANY_ID_SKULLCANDY_INC: u32 = 1993;
pub const BLUETOOTH_COMPANY_ID_MODUL_SYSTEM_HH_AB: u32 = 1994;
pub const BLUETOOTH_COMPANY_ID_WEST_PHARMACEUTICAL_SERVICES_INC: u32 = 1995;
pub const BLUETOOTH_COMPANY_ID_BARNACLE_SYSTEMS_INC: u32 = 1996;
pub const BLUETOOTH_COMPANY_ID_SMART_WAVE_TECHNOLOGIES_CANADA_INC: u32 = 1997;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_TOP_CHIP_MICROELECTRONICS_TECH_CO_LTD: u32 = 1998;
pub const BLUETOOTH_COMPANY_ID_NEOSENSORY_INC: u32 = 1999;
pub const BLUETOOTH_COMPANY_ID_HANGZHOU_TUYA_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 2000;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_PANCHIP_MICROELECTRONICS_CO_LTD: u32 = 2001;
pub const BLUETOOTH_COMPANY_ID_REACT_ACCESSIBILITY_LIMITED: u32 = 2002;
pub const BLUETOOTH_COMPANY_ID_LIVNEX_COLTD: u32 = 2003;
pub const BLUETOOTH_COMPANY_ID_KANO_COMPUTING_LIMITED: u32 = 2004;
pub const BLUETOOTH_COMPANY_ID_HOOTS_CLASSIC_GMBH: u32 = 2005;
pub const BLUETOOTH_COMPANY_ID_ECOBEE_INC: u32 = 2006;
pub const BLUETOOTH_COMPANY_ID_NANJING_QINHENG_MICROELECTRONICS_CO_LTD: u32 = 2007;
pub const BLUETOOTH_COMPANY_ID_SOLUTIONS_AMBRA_INC: u32 = 2008;
pub const BLUETOOTH_COMPANY_ID_MICRO_DESIGN_INC: u32 = 2009;
pub const BLUETOOTH_COMPANY_ID_STARLITE_CO_LTD: u32 = 2010;
pub const BLUETOOTH_COMPANY_ID_REMEDEE_LABS: u32 = 2011;
pub const BLUETOOTH_COMPANY_ID_THINGOS_GMBH: u32 = 2012;
pub const BLUETOOTH_COMPANY_ID_LINEAR_CIRCUITS: u32 = 2013;
pub const BLUETOOTH_COMPANY_ID_UNLIMITED_ENGINEERING_SL: u32 = 2014;
pub const BLUETOOTH_COMPANY_ID_SNAP_ON_INCORPORATED: u32 = 2015;
pub const BLUETOOTH_COMPANY_ID_EDIFIER_INTERNATIONAL_LIMITED: u32 = 2016;
pub const BLUETOOTH_COMPANY_ID_LUCIE_LABS: u32 = 2017;
pub const BLUETOOTH_COMPANY_ID_ALFRED_KAERCHER_SE_AND_CO_KG: u32 = 2018;
pub const BLUETOOTH_COMPANY_ID_AUDIOWISE_TECHNOLOGY_INC: u32 = 2019;
pub const BLUETOOTH_COMPANY_ID_GEEKSME_SL: u32 = 2020;
pub const BLUETOOTH_COMPANY_ID_MINUT_INC: u32 = 2021;
pub const BLUETOOTH_COMPANY_ID_AUTOGROW_SYSTEMS_LIMITED: u32 = 2022;
pub const BLUETOOTH_COMPANY_ID_KOMFORT_IQ_INC: u32 = 2023;
pub const BLUETOOTH_COMPANY_ID_PACKETCRAFT_INC: u32 = 2024;
pub const BLUETOOTH_COMPANY_ID_HFELE_GMBH_AND_CO_KG: u32 = 2025;
pub const BLUETOOTH_COMPANY_ID_SHAPELOG_INC: u32 = 2026;
pub const BLUETOOTH_COMPANY_ID_NOVABASE_SRL: u32 = 2027;
pub const BLUETOOTH_COMPANY_ID_FRECCE_LLC: u32 = 2028;
pub const BLUETOOTH_COMPANY_ID_JOULE_IQ_INC: u32 = 2029;
pub const BLUETOOTH_COMPANY_ID_KIDZTEK_LLC: u32 = 2030;
pub const BLUETOOTH_COMPANY_ID_AKTIEBOLAGET_SANDVIK_COROMANT: u32 = 2031;
pub const BLUETOOTH_COMPANY_ID_E_MOOLACOM_PTY_LTD: u32 = 2032;
pub const BLUETOOTH_COMPANY_ID_ZIMI_INNOVATIONS_PTY_LTD: u32 = 2033;
pub const BLUETOOTH_COMPANY_ID_SERENE_GROUP_INC: u32 = 2034;
pub const BLUETOOTH_COMPANY_ID_DIGISINE_ENERGYTECH_CO_LTD: u32 = 2035;
pub const BLUETOOTH_COMPANY_ID_MEDIRLAB_ORVOSBIOLOGIAI_FEJLESZTO_KORLATOLT_FELELOSSEGU_TARSASAG:
    u32 = 2036;
pub const BLUETOOTH_COMPANY_ID_BYTON_NORTH_AMERICA_CORPORATION: u32 = 2037;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_TONLISCIENCE_AND_TECHNOLOGY_DEVELOPMENT_COLTD: u32 = 2038;
pub const BLUETOOTH_COMPANY_ID_CESAR_SYSTEMS_LTD: u32 = 2039;
pub const BLUETOOTH_COMPANY_ID_QUIP_NYC_INC: u32 = 2040;
pub const BLUETOOTH_COMPANY_ID_DIRECT_COMMUNICATION_SOLUTIONS_INC: u32 = 2041;
pub const BLUETOOTH_COMPANY_ID_KLIPSCH_GROUP_INC: u32 = 2042;
pub const BLUETOOTH_COMPANY_ID_ACCESS_CO_LTD: u32 = 2043;
pub const BLUETOOTH_COMPANY_ID_RENAULT_SA: u32 = 2044;
pub const BLUETOOTH_COMPANY_ID_JSK_CO_LTD: u32 = 2045;
pub const BLUETOOTH_COMPANY_ID_BIROTA: u32 = 2046;
pub const BLUETOOTH_COMPANY_ID_MAXON_MOTOR_LTD: u32 = 2047;
pub const BLUETOOTH_COMPANY_ID_OPTEK: u32 = 2048;
pub const BLUETOOTH_COMPANY_ID_CRONUS_ELECTRONICS_LTD: u32 = 2049;
pub const BLUETOOTH_COMPANY_ID_NANTSOUND_INC: u32 = 2050;
pub const BLUETOOTH_COMPANY_ID_DOMINTELL_SA: u32 = 2051;
pub const BLUETOOTH_COMPANY_ID_ANDON_HEALTH_COLTD: u32 = 2052;
pub const BLUETOOTH_COMPANY_ID_URBANMINDED_LTD: u32 = 2053;
pub const BLUETOOTH_COMPANY_ID_TYRI_SWEDEN_AB: u32 = 2054;
pub const BLUETOOTH_COMPANY_ID_ECD_ELECTRONIC_COMPONENTS_GMBH_DRESDEN: u32 = 2055;
pub const BLUETOOTH_COMPANY_ID_SISTEMAS_KERN_SOCIEDAD_ANMINA: u32 = 2056;
pub const BLUETOOTH_COMPANY_ID_TRULLI_AUDIO: u32 = 2057;
pub const BLUETOOTH_COMPANY_ID_ALTANEOS: u32 = 2058;
pub const BLUETOOTH_COMPANY_ID_NANOLEAF_CANADA_LIMITED: u32 = 2059;
pub const BLUETOOTH_COMPANY_ID_INGY_BV: u32 = 2060;
pub const BLUETOOTH_COMPANY_ID_AZBIL_CO: u32 = 2061;
pub const BLUETOOTH_COMPANY_ID_TATTCOM_LLC: u32 = 2062;
pub const BLUETOOTH_COMPANY_ID_PARADOX_ENGINEERING_SA: u32 = 2063;
pub const BLUETOOTH_COMPANY_ID_LECO_CORPORATION: u32 = 2064;
pub const BLUETOOTH_COMPANY_ID_BECKER_ANTRIEBE_GMBH: u32 = 2065;
pub const BLUETOOTH_COMPANY_ID_MSTREAM_TECHNOLOGIES_INC: u32 = 2066;
pub const BLUETOOTH_COMPANY_ID_FLEXTRONICS_INTERNATIONAL_USA_INC: u32 = 2067;
pub const BLUETOOTH_COMPANY_ID_OSSUR_HF: u32 = 2068;
pub const BLUETOOTH_COMPANY_ID_SKC_INC: u32 = 2069;
pub const BLUETOOTH_COMPANY_ID_SPICA_SYSTEMS_LLC: u32 = 2070;
pub const BLUETOOTH_COMPANY_ID_WANGS_ALLIANCE_CORPORATION: u32 = 2071;
pub const BLUETOOTH_COMPANY_ID_TATWAH_SA: u32 = 2072;
pub const BLUETOOTH_COMPANY_ID_HUNTER_DOUGLAS_INC: u32 = 2073;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_CONEX: u32 = 2074;
pub const BLUETOOTH_COMPANY_ID_DIM3: u32 = 2075;
pub const BLUETOOTH_COMPANY_ID_BOBRICK_WASHROOM_EQUIPMENT_INC: u32 = 2076;
pub const BLUETOOTH_COMPANY_ID_POTRYKUS_HOLDINGS_AND_DEVELOPMENT_LLC: u32 = 2077;
pub const BLUETOOTH_COMPANY_ID_INFORM_TECHNOLOGY_GMBH: u32 = 2078;
pub const BLUETOOTH_COMPANY_ID_ESENSELAB_LTD: u32 = 2079;
pub const BLUETOOTH_COMPANY_ID_BRILLIANT_HOME_TECHNOLOGY_INC: u32 = 2080;
pub const BLUETOOTH_COMPANY_ID_INOVA_GEOPHYSICAL_INC: u32 = 2081;
pub const BLUETOOTH_COMPANY_ID_ADAFRUIT_INDUSTRIES: u32 = 2082;
pub const BLUETOOTH_COMPANY_ID_NEXITE_LTD: u32 = 2083;
pub const BLUETOOTH_COMPANY_ID_8POWER_LIMITED: u32 = 2084;
pub const BLUETOOTH_COMPANY_ID_CME_PTE_LTD: u32 = 2085;
pub const BLUETOOTH_COMPANY_ID_HYUNDAI_MOTOR_COMPANY: u32 = 2086;
pub const BLUETOOTH_COMPANY_ID_KICKMAKER: u32 = 2087;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_SUISHENG_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 2088;
pub const BLUETOOTH_COMPANY_ID_HEXAGON: u32 = 2089;
pub const BLUETOOTH_COMPANY_ID_MITUTOYO_CORPORATION: u32 = 2090;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_FITCARE_ELECTRONICS_COLTD: u32 = 2091;
pub const BLUETOOTH_COMPANY_ID_INGICS_TECHNOLOGY_CO_LTD: u32 = 2092;
pub const BLUETOOTH_COMPANY_ID_INCUS_PERFORMANCE_LTD: u32 = 2093;
pub const BLUETOOTH_COMPANY_ID_ABB_SPA: u32 = 2094;
pub const BLUETOOTH_COMPANY_ID_BLIPPIT_AB: u32 = 2095;
pub const BLUETOOTH_COMPANY_ID_CORE_HEALTH_AND_FITNESS_LLC: u32 = 2096;
pub const BLUETOOTH_COMPANY_ID_FOXBLE_LLC: u32 = 2097;
pub const BLUETOOTH_COMPANY_ID_INTERMOTIVEINC: u32 = 2098;
pub const BLUETOOTH_COMPANY_ID_CONNEQTECH_BV: u32 = 2099;
pub const BLUETOOTH_COMPANY_ID_RIKEN_KEIKI_CO_LTD: u32 = 2100;
pub const BLUETOOTH_COMPANY_ID_CANOPY_GROWTH_CORPORATION: u32 = 2101;
pub const BLUETOOTH_COMPANY_ID_BITWARDS_OY: u32 = 2102;
pub const BLUETOOTH_COMPANY_ID_VIVO_MOBILE_COMMUNICATION_CO_LTD: u32 = 2103;
pub const BLUETOOTH_COMPANY_ID_ETYMOTIC_RESEARCH_INC: u32 = 2104;
pub const BLUETOOTH_COMPANY_ID_A_PUISSANCE_3: u32 = 2105;
pub const BLUETOOTH_COMPANY_ID_BPW_BERGISCHE_ACHSEN_KOMMANDITGESELLSCHAFT: u32 = 2106;
pub const BLUETOOTH_COMPANY_ID_PIAGGIO_FAST_FORWARD: u32 = 2107;
pub const BLUETOOTH_COMPANY_ID_BEERTECH_LTD: u32 = 2108;
pub const BLUETOOTH_COMPANY_ID_TOKENIZE_INC: u32 = 2109;
pub const BLUETOOTH_COMPANY_ID_ZORACHKA_LTD: u32 = 2110;
pub const BLUETOOTH_COMPANY_ID_D_LINK_CORP: u32 = 2111;
pub const BLUETOOTH_COMPANY_ID_DOWN_RANGE_SYSTEMS_LLC: u32 = 2112;
pub const BLUETOOTH_COMPANY_ID_GENERAL_LUMINAIRE_CO_LTD: u32 = 2113;
pub const BLUETOOTH_COMPANY_ID_TANGSHAN_HONGJIA_ELECTRONIC_TECHNOLOGY_CO_LTD: u32 = 2114;
pub const BLUETOOTH_COMPANY_ID_FRAGRANCE_DELIVERY_TECHNOLOGIES_LTD: u32 = 2115;
pub const BLUETOOTH_COMPANY_ID_PEPPERL_AND_FUCHS_GMBH: u32 = 2116;
pub const BLUETOOTH_COMPANY_ID_DOMETIC_CORPORATION: u32 = 2117;
pub const BLUETOOTH_COMPANY_ID_USOUND_GMBH: u32 = 2118;
pub const BLUETOOTH_COMPANY_ID_DNANUDGE_LIMITED: u32 = 2119;
pub const BLUETOOTH_COMPANY_ID_JUJU_JOINTS_CANADA_CORP: u32 = 2120;
pub const BLUETOOTH_COMPANY_ID_DOPPLE_TECHNOLOGIES_BV: u32 = 2121;
pub const BLUETOOTH_COMPANY_ID_ARCOM: u32 = 2122;
pub const BLUETOOTH_COMPANY_ID_BIOTECHWARE_SRL: u32 = 2123;
pub const BLUETOOTH_COMPANY_ID_ORSO_INC: u32 = 2124;
pub const BLUETOOTH_COMPANY_ID_SAFEPORT: u32 = 2125;
pub const BLUETOOTH_COMPANY_ID_CAROL_COLE_COMPANY: u32 = 2126;
pub const BLUETOOTH_COMPANY_ID_EMBEDDED_FITNESS_BV: u32 = 2127;
pub const BLUETOOTH_COMPANY_ID_YEALINK_NETWORK_TECHNOLOGY_COLTD: u32 = 2128;
pub const BLUETOOTH_COMPANY_ID_SUBECA_INC: u32 = 2129;
pub const BLUETOOTH_COMPANY_ID_COGNOSOS_INC: u32 = 2130;
pub const BLUETOOTH_COMPANY_ID_PEKTRON_GROUP_LIMITED: u32 = 2131;
pub const BLUETOOTH_COMPANY_ID_TAP_SOUND_SYSTEM: u32 = 2132;
pub const BLUETOOTH_COMPANY_ID_HELIOS_HOCKEY_INC: u32 = 2133;
pub const BLUETOOTH_COMPANY_ID_CANOPY_GROWTH_CORPORATION2: u32 = 2134;
pub const BLUETOOTH_COMPANY_ID_PARSYL_INC: u32 = 2135;
pub const BLUETOOTH_COMPANY_ID_SOUNDBOKS: u32 = 2136;
pub const BLUETOOTH_COMPANY_ID_BLUEUP: u32 = 2137;
pub const BLUETOOTH_COMPANY_ID_DAKATECH: u32 = 2138;
pub const BLUETOOTH_COMPANY_ID_RICOH_ELECTRONIC_DEVICES_CO_LTD: u32 = 2139;
pub const BLUETOOTH_COMPANY_ID_ACOS_COLTD: u32 = 2140;
pub const BLUETOOTH_COMPANY_ID_GUILIN_ZHISHEN_INFORMATION_TECHNOLOGY_COLTD: u32 = 2141;
pub const BLUETOOTH_COMPANY_ID_KROG_SYSTEMS_LLC: u32 = 2142;
pub const BLUETOOTH_COMPANY_ID_COMPEGPS_TEAMSOCIEDAD_LIMITADA: u32 = 2143;
pub const BLUETOOTH_COMPANY_ID_ALFLEX_PRODUCTS_BV: u32 = 2144;
pub const BLUETOOTH_COMPANY_ID_SMARTSENSOR_LABS_LTD: u32 = 2145;
pub const BLUETOOTH_COMPANY_ID_SMARTDRIVE_INC: u32 = 2146;
pub const BLUETOOTH_COMPANY_ID_YO_TRONICS_TECHNOLOGY_CO_LTD: u32 = 2147;
pub const BLUETOOTH_COMPANY_ID_RAFAELMICRO: u32 = 2148;
pub const BLUETOOTH_COMPANY_ID_EMERGENCY_LIGHTING_PRODUCTS_LIMITED: u32 = 2149;
pub const BLUETOOTH_COMPANY_ID_LAONZ_COLTD: u32 = 2150;
pub const BLUETOOTH_COMPANY_ID_WESTERN_DIGITAL_TECHOLOGIES_INC: u32 = 2151;
pub const BLUETOOTH_COMPANY_ID_WIOSENSE_GMBH_AND_CO_KG: u32 = 2152;
pub const BLUETOOTH_COMPANY_ID_EVVA_SICHERHEITSTECHNOLOGIE_GMBH: u32 = 2153;
pub const BLUETOOTH_COMPANY_ID_ODIC_INCORPORATED: u32 = 2154;
pub const BLUETOOTH_COMPANY_ID_PACIFIC_TRACK_LLC: u32 = 2155;
pub const BLUETOOTH_COMPANY_ID_REVVO_TECHNOLOGIES_INC: u32 = 2156;
pub const BLUETOOTH_COMPANY_ID_BIOMETRIKA_DOO: u32 = 2157;
pub const BLUETOOTH_COMPANY_ID_VORWERK_ELEKTROWERKE_GMBH_AND_CO_KG: u32 = 2158;
pub const BLUETOOTH_COMPANY_ID_TRACKUNIT_A_S: u32 = 2159;
pub const BLUETOOTH_COMPANY_ID_WYZE_LABS_INC: u32 = 2160;
pub const BLUETOOTH_COMPANY_ID_DENSION_ELEKTRONIKAI_KFT: u32 = 2161;
pub const BLUETOOTH_COMPANY_ID_11_HEALTH_AND_TECHNOLOGIES_LIMITED: u32 = 2162;
pub const BLUETOOTH_COMPANY_ID_INNOPHASE_INCORPORATED: u32 = 2163;
pub const BLUETOOTH_COMPANY_ID_TREEGREEN_LIMITED: u32 = 2164;
pub const BLUETOOTH_COMPANY_ID_BERNER_INTERNATIONAL_LLC: u32 = 2165;
pub const BLUETOOTH_COMPANY_ID_SMARTRESQ_APS: u32 = 2166;
pub const BLUETOOTH_COMPANY_ID_TOME_INC: u32 = 2167;
pub const BLUETOOTH_COMPANY_ID_THE_CHAMBERLAIN_GROUP_INC: u32 = 2168;
pub const BLUETOOTH_COMPANY_ID_MIZUNO_CORPORATION: u32 = 2169;
pub const BLUETOOTH_COMPANY_ID_ZRF_LLC: u32 = 2170;
pub const BLUETOOTH_COMPANY_ID_BYSTAMP: u32 = 2171;
pub const BLUETOOTH_COMPANY_ID_CROSSCAN_GMBH: u32 = 2172;
pub const BLUETOOTH_COMPANY_ID_KONFTEL_AB: u32 = 2173;
pub const BLUETOOTH_COMPANY_ID_1BARNET_LIMITED: u32 = 2174;
pub const BLUETOOTH_COMPANY_ID_PHILLIPS_CONNECT_TECHNOLOGIES_LLC: u32 = 2175;
pub const BLUETOOTH_COMPANY_ID_IMAGILABS_AB: u32 = 2176;
pub const BLUETOOTH_COMPANY_ID_OPTALERT: u32 = 2177;
pub const BLUETOOTH_COMPANY_ID_PSYONIC_INC: u32 = 2178;
pub const BLUETOOTH_COMPANY_ID_WINTERSTEIGER_AG: u32 = 2179;
pub const BLUETOOTH_COMPANY_ID_CONTROLID_INDUSTRIA_COMERCIO_DE_HARDWARE_E_SERVICOS_DE_TECNOLOGIA_LTDA : u32 = 2180 ;
pub const BLUETOOTH_COMPANY_ID_LEVOLOR_INC: u32 = 2181;
pub const BLUETOOTH_COMPANY_ID_XSENS_TECHNOLOGIES_BV: u32 = 2182;
pub const BLUETOOTH_COMPANY_ID_HYDRO_GEAR_LIMITED_PARTNERSHIP: u32 = 2183;
pub const BLUETOOTH_COMPANY_ID_ENPOINTE_FENCING_PTY_LTD: u32 = 2184;
pub const BLUETOOTH_COMPANY_ID_XANTHIO: u32 = 2185;
pub const BLUETOOTH_COMPANY_ID_SCLAK_SRL: u32 = 2186;
pub const BLUETOOTH_COMPANY_ID_TRICORDER_ARRAAY_TECHNOLOGIES_LLC: u32 = 2187;
pub const BLUETOOTH_COMPANY_ID_GB_SOLUTION_COLTD: u32 = 2188;
pub const BLUETOOTH_COMPANY_ID_SOLITON_SYSTEMS_KK: u32 = 2189;
pub const BLUETOOTH_COMPANY_ID_GIGA_TMS_INC: u32 = 2190;
pub const BLUETOOTH_COMPANY_ID_TAIT_INTERNATIONAL_LIMITED: u32 = 2191;
pub const BLUETOOTH_COMPANY_ID_NICHIEI_INTEC_CO_LTD: u32 = 2192;
pub const BLUETOOTH_COMPANY_ID_SMARTWIRELESS_GMBH_AND_CO_KG: u32 = 2193;
pub const BLUETOOTH_COMPANY_ID_INGENIEURBUERO_BIRNFELD_UG: u32 = 2194;
pub const BLUETOOTH_COMPANY_ID_MAYTRONICS_LTD: u32 = 2195;
pub const BLUETOOTH_COMPANY_ID_EPIFIT: u32 = 2196;
pub const BLUETOOTH_COMPANY_ID_GIMER_MEDICAL: u32 = 2197;
pub const BLUETOOTH_COMPANY_ID_NOKIAN_RENKAAT_OYJ: u32 = 2198;
pub const BLUETOOTH_COMPANY_ID_CURRENT_LIGHTING_SOLUTIONS_LLC: u32 = 2199;
pub const BLUETOOTH_COMPANY_ID_SENSIBO_INC: u32 = 2200;
pub const BLUETOOTH_COMPANY_ID_SFS_UNIMARKET_AG: u32 = 2201;
pub const BLUETOOTH_COMPANY_ID_PRIVATE_LIMITED_COMPANY__TELTONIKA_: u32 = 2202;
pub const BLUETOOTH_COMPANY_ID_SAUCON_TECHNOLOGIES: u32 = 2203;
pub const BLUETOOTH_COMPANY_ID_EMBEDDED_DEVICES_CO_COMPANY: u32 = 2204;
pub const BLUETOOTH_COMPANY_ID_J_JADE_ENTERPRISE_LLC: u32 = 2205;
pub const BLUETOOTH_COMPANY_ID_I_SENS_INC: u32 = 2206;
pub const BLUETOOTH_COMPANY_ID_WITSCHI_ELECTRONIC_LTD: u32 = 2207;
pub const BLUETOOTH_COMPANY_ID_ACLARA_TECHNOLOGIES_LLC: u32 = 2208;
pub const BLUETOOTH_COMPANY_ID_EXEO_TECH_CORPORATION: u32 = 2209;
pub const BLUETOOTH_COMPANY_ID_EPIC_SYSTEMS_CO_LTD: u32 = 2210;
pub const BLUETOOTH_COMPANY_ID_HOFFMANN_SE: u32 = 2211;
pub const BLUETOOTH_COMPANY_ID_REALME_CHONGQING_MOBILE_TELECOMMUNICATIONS_CORP_LTD: u32 = 2212;
pub const BLUETOOTH_COMPANY_ID_UMEHEAL_LTD: u32 = 2213;
pub const BLUETOOTH_COMPANY_ID_INTELLIGENCEWORKS_INC: u32 = 2214;
pub const BLUETOOTH_COMPANY_ID_TGR_1618_LIMITED: u32 = 2215;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_KFCUBE_INC: u32 = 2216;
pub const BLUETOOTH_COMPANY_ID_FRAUNHOFER_IIS: u32 = 2217;
pub const BLUETOOTH_COMPANY_ID_SZ_DJI_TECHNOLOGY_COLTD: u32 = 2218;
pub const BLUETOOTH_COMPANY_ID_COBURN_TECHNOLOGY_LLC: u32 = 2219;
pub const BLUETOOTH_COMPANY_ID_TOPRE_CORPORATION: u32 = 2220;
pub const BLUETOOTH_COMPANY_ID_KAYAMATICS_LIMITED: u32 = 2221;
pub const BLUETOOTH_COMPANY_ID_MOTICON_REGO_AG: u32 = 2222;
pub const BLUETOOTH_COMPANY_ID_POLIDEA_SP_Z_OO: u32 = 2223;
pub const BLUETOOTH_COMPANY_ID_TRIVEDI_ADVANCED_TECHNOLOGIES_LLC: u32 = 2224;
pub const BLUETOOTH_COMPANY_ID_CORE_VISION_BV: u32 = 2225;
pub const BLUETOOTH_COMPANY_ID_PF_SCHWEISSTECHNOLOGIE_GMBH: u32 = 2226;
pub const BLUETOOTH_COMPANY_ID_IONIQ_SKINCARE_GMBH_AND_CO_KG: u32 = 2227;
pub const BLUETOOTH_COMPANY_ID_SENGLED_CO_LTD: u32 = 2228;
pub const BLUETOOTH_COMPANY_ID_TRANSFERFI: u32 = 2229;
pub const BLUETOOTH_COMPANY_ID_BOEHRINGER_INGELHEIM_VETMEDICA_GMBH: u32 = 2230;
pub const BLUETOOTH_COMPANY_ID_ABB_INC: u32 = 2231;
pub const BLUETOOTH_COMPANY_ID_CHECK_TECHNOLOGY_SOLUTIONS_LLC: u32 = 2232;
pub const BLUETOOTH_COMPANY_ID_U_SHIN_LTD: u32 = 2233;
pub const BLUETOOTH_COMPANY_ID_HYPER_ICE_INC: u32 = 2234;
pub const BLUETOOTH_COMPANY_ID_TOKAI_RIKA_COLTD: u32 = 2235;
pub const BLUETOOTH_COMPANY_ID_PREVAYL_LIMITED: u32 = 2236;
pub const BLUETOOTH_COMPANY_ID_BF1SYSTEMS_LIMITED: u32 = 2237;
pub const BLUETOOTH_COMPANY_ID_UBISYS_TECHNOLOGIES_GMBH: u32 = 2238;
pub const BLUETOOTH_COMPANY_ID_SIRC_CO_LTD: u32 = 2239;
pub const BLUETOOTH_COMPANY_ID_ACCENT_ADVANCED_SYSTEMS_SLU: u32 = 2240;
pub const BLUETOOTH_COMPANY_ID_RAYDENEARTH_LTD: u32 = 2241;
pub const BLUETOOTH_COMPANY_ID_LINDINVENT_AB: u32 = 2242;
pub const BLUETOOTH_COMPANY_ID_CHIPOLO_DOO: u32 = 2243;
pub const BLUETOOTH_COMPANY_ID_CELLASSIST_LLC: u32 = 2244;
pub const BLUETOOTH_COMPANY_ID_J_WAGNER_GMBH: u32 = 2245;
pub const BLUETOOTH_COMPANY_ID_INTEGRA_OPTICS_INC: u32 = 2246;
pub const BLUETOOTH_COMPANY_ID_MONADNOCK_SYSTEMS_LTD: u32 = 2247;
pub const BLUETOOTH_COMPANY_ID_LITEBOXER_TECHNOLOGIES_INC: u32 = 2248;
pub const BLUETOOTH_COMPANY_ID_NOVENTA_AG: u32 = 2249;
pub const BLUETOOTH_COMPANY_ID_NUBIA_TECHNOLOGY_COLTD: u32 = 2250;
pub const BLUETOOTH_COMPANY_ID_JT_INNOVATIONS_LIMITED: u32 = 2251;
pub const BLUETOOTH_COMPANY_ID_TGM_TECHNOLOGY_CO_LTD: u32 = 2252;
pub const BLUETOOTH_COMPANY_ID_IFLY: u32 = 2253;
pub const BLUETOOTH_COMPANY_ID_ZIMI_CORPORATION: u32 = 2254;
pub const BLUETOOTH_COMPANY_ID_BETTERNOTSTEALMYBIKE_UG: u32 = 2255;
pub const BLUETOOTH_COMPANY_ID_ESTOM_INFOTECH_KFT: u32 = 2256;
pub const BLUETOOTH_COMPANY_ID_SENSOVIUM_INC: u32 = 2257;
pub const BLUETOOTH_COMPANY_ID_VIRSCIENT_LIMITED: u32 = 2258;
pub const BLUETOOTH_COMPANY_ID_NOVEL_BITS_LLC: u32 = 2259;
pub const BLUETOOTH_COMPANY_ID_ADATA_TECHNOLOGY_CO_LTD: u32 = 2260;
pub const BLUETOOTH_COMPANY_ID_KEYES: u32 = 2261;
pub const BLUETOOTH_COMPANY_ID_NOME_OY: u32 = 2262;
pub const BLUETOOTH_COMPANY_ID_INOVONICS_CORP: u32 = 2263;
pub const BLUETOOTH_COMPANY_ID_WARES: u32 = 2264;
pub const BLUETOOTH_COMPANY_ID_POINTR_LABS_LIMITED: u32 = 2265;
pub const BLUETOOTH_COMPANY_ID_MIRIDIA_TECHNOLOGY_INCORPORATED: u32 = 2266;
pub const BLUETOOTH_COMPANY_ID_TERTIUM_TECHNOLOGY: u32 = 2267;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_AUKEY_E_BUSINESS_CO_LTD: u32 = 2268;
pub const BLUETOOTH_COMPANY_ID_CODE_Q: u32 = 2269;
pub const BLUETOOTH_COMPANY_ID_TYCO_ELECTRONICS_CORPORATION_A_TE_CONNECTIVITY_LTD_COMPANY: u32 =
    2270;
pub const BLUETOOTH_COMPANY_ID_IRIS_OHYAMA_COLTD: u32 = 2271;
pub const BLUETOOTH_COMPANY_ID_PHILIA_TECHNOLOGY: u32 = 2272;
pub const BLUETOOTH_COMPANY_ID_KOZO_KEIKAKU_ENGINEERING_INC: u32 = 2273;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_SIMO_TECHNOLOGY_CO_LTD: u32 = 2274;
pub const BLUETOOTH_COMPANY_ID_REPUBLIC_WIRELESS_INC: u32 = 2275;
pub const BLUETOOTH_COMPANY_ID_RASHIDOV_LTD: u32 = 2276;
pub const BLUETOOTH_COMPANY_ID_CROWD_CONNECTED_LTD: u32 = 2277;
pub const BLUETOOTH_COMPANY_ID_ENESO_TECNOLOGIA_DE_ADAPTACION_SL: u32 = 2278;
pub const BLUETOOTH_COMPANY_ID_BARROT_TECHNOLOGY_LIMITED: u32 = 2279;
pub const BLUETOOTH_COMPANY_ID_NAONEXT: u32 = 2280;
pub const BLUETOOTH_COMPANY_ID_TAIWAN_INTELLIGENT_HOME_CORP: u32 = 2281;
pub const BLUETOOTH_COMPANY_ID_COWBELL_ENGINEERING_COLTD: u32 = 2282;
pub const BLUETOOTH_COMPANY_ID_BEIJING_BIG_MOMENT_TECHNOLOGY_CO_LTD: u32 = 2283;
pub const BLUETOOTH_COMPANY_ID_DENSO_CORPORATION: u32 = 2284;
pub const BLUETOOTH_COMPANY_ID_IMI_HYDRONIC_ENGINEERING_INTERNATIONAL_SA: u32 = 2285;
pub const BLUETOOTH_COMPANY_ID_ASKEY: u32 = 2286;
pub const BLUETOOTH_COMPANY_ID_CUMULUS_DIGITAL_SYSTEMS_INC: u32 = 2287;
pub const BLUETOOTH_COMPANY_ID_JOOVV_INC: u32 = 2288;
pub const BLUETOOTH_COMPANY_ID_THE_LS_STARRETT_COMPANY: u32 = 2289;
pub const BLUETOOTH_COMPANY_ID_MICROOLED: u32 = 2290;
pub const BLUETOOTH_COMPANY_ID_PSP_PAULI_SERVICES_AND_PRODUCTS_GMBH: u32 = 2291;
pub const BLUETOOTH_COMPANY_ID_KODIMO_TECHNOLOGIES_COMPANY_LIMITED: u32 = 2292;
pub const BLUETOOTH_COMPANY_ID_TYMTIX_TECHNOLOGIES_PRIVATE_LIMITED: u32 = 2293;
pub const BLUETOOTH_COMPANY_ID_DERMAL_PHOTONICS_CORPORATION: u32 = 2294;
pub const BLUETOOTH_COMPANY_ID_MTD_PRODUCTS_INC_AND_AFFILIATES: u32 = 2295;
pub const BLUETOOTH_COMPANY_ID_INSTAGRID_GMBH: u32 = 2296;
pub const BLUETOOTH_COMPANY_ID_SPACELABS_MEDICAL_INC: u32 = 2297;
pub const BLUETOOTH_COMPANY_ID_TROO_CORPORATION: u32 = 2298;
pub const BLUETOOTH_COMPANY_ID_DARKGLASS_ELECTRONICS_OY: u32 = 2299;
pub const BLUETOOTH_COMPANY_ID_HILL_ROM: u32 = 2300;
pub const BLUETOOTH_COMPANY_ID_BIOINTELLISENSE_INC: u32 = 2301;
pub const BLUETOOTH_COMPANY_ID_KETRONIXS_SDN_BHD: u32 = 2302;
pub const BLUETOOTH_COMPANY_ID_PLASTIMOLD_PRODUCTS_INC: u32 = 2303;
pub const BLUETOOTH_COMPANY_ID_BEIJING_ZIZAI_TECHNOLOGY_CO_LTD: u32 = 2304;
pub const BLUETOOTH_COMPANY_ID_LUCIMED: u32 = 2305;
pub const BLUETOOTH_COMPANY_ID_TSC_AUTO_ID_TECHNOLOGY_CO_LTD: u32 = 2306;
pub const BLUETOOTH_COMPANY_ID_DATAMARS_INC: u32 = 2307;
pub const BLUETOOTH_COMPANY_ID_SUNCORPORATION: u32 = 2308;
pub const BLUETOOTH_COMPANY_ID_YANDEX_SERVICES_AG: u32 = 2309;
pub const BLUETOOTH_COMPANY_ID_SCOPE_LOGISTICAL_SOLUTIONS: u32 = 2310;
pub const BLUETOOTH_COMPANY_ID_USER_HELLO_LLC: u32 = 2311;
pub const BLUETOOTH_COMPANY_ID_PINPOINT_INNOVATIONS_LIMITED: u32 = 2312;
pub const BLUETOOTH_COMPANY_ID_70MAI_COLTD: u32 = 2313;
pub const BLUETOOTH_COMPANY_ID_ZHUHAI_HOKSI_TECHNOLOGY_COLTD: u32 = 2314;
pub const BLUETOOTH_COMPANY_ID_EMBR_LABS_INC: u32 = 2315;
pub const BLUETOOTH_COMPANY_ID_RADIAWAVE_TECHNOLOGIES_COLTD: u32 = 2316;
pub const BLUETOOTH_COMPANY_ID_IOT_INVENT_GMBH: u32 = 2317;
pub const BLUETOOTH_COMPANY_ID_OPTIMUSIOT_TECH_LLP: u32 = 2318;
pub const BLUETOOTH_COMPANY_ID_VC_INC: u32 = 2319;
pub const BLUETOOTH_COMPANY_ID_ASR_MICROELECTRONICS_CO_LTD: u32 = 2320;
pub const BLUETOOTH_COMPANY_ID_DOUGLAS_LIGHTING_CONTROLS_INC: u32 = 2321;
pub const BLUETOOTH_COMPANY_ID_NERBIO_MEDICAL_SOFTWARE_PLATFORMS_INC: u32 = 2322;
pub const BLUETOOTH_COMPANY_ID_BRAVEHEART_WIRELESS_INC: u32 = 2323;
pub const BLUETOOTH_COMPANY_ID_INEO_SENSE: u32 = 2324;
pub const BLUETOOTH_COMPANY_ID_HONDA_MOTOR_CO_LTD: u32 = 2325;
pub const BLUETOOTH_COMPANY_ID_AMBIENT_SENSORS_LLC: u32 = 2326;
pub const BLUETOOTH_COMPANY_ID_ASR_MICROELECTRONICSCO_LTD: u32 = 2327;
pub const BLUETOOTH_COMPANY_ID_TECHNOSPHERE_LABS_PVT_LTD: u32 = 2328;
pub const BLUETOOTH_COMPANY_ID_NO_SMD_LIMITED: u32 = 2329;
pub const BLUETOOTH_COMPANY_ID_ALBERTRONIC_BV: u32 = 2330;
pub const BLUETOOTH_COMPANY_ID_LUMINOSTICS_INC: u32 = 2331;
pub const BLUETOOTH_COMPANY_ID_OBLAMATIK_AG: u32 = 2332;
pub const BLUETOOTH_COMPANY_ID_INNOKIND_INC: u32 = 2333;
pub const BLUETOOTH_COMPANY_ID_MELBOT_STUDIOS_SOCIEDAD_LIMITADA: u32 = 2334;
pub const BLUETOOTH_COMPANY_ID_MYZEE_TECHNOLOGY: u32 = 2335;
pub const BLUETOOTH_COMPANY_ID_OMNISENSE_LIMITED: u32 = 2336;
pub const BLUETOOTH_COMPANY_ID_KAHA_PTE_LTD: u32 = 2337;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_MXCHIP_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 2338;
pub const BLUETOOTH_COMPANY_ID_JSB_TECH_PTE_LTD: u32 = 2339;
pub const BLUETOOTH_COMPANY_ID_FUNDACION_TECNALIA_RESEARCH_AND_INNOVATION: u32 = 2340;
pub const BLUETOOTH_COMPANY_ID_YUKAI_ENGINEERING_INC: u32 = 2341;
pub const BLUETOOTH_COMPANY_ID_GOOLIGUM_TECHNOLOGIES_PTY_LTD: u32 = 2342;
pub const BLUETOOTH_COMPANY_ID_ROOQ_GMBH: u32 = 2343;
pub const BLUETOOTH_COMPANY_ID_AIRISTA: u32 = 2344;
pub const BLUETOOTH_COMPANY_ID_QINGDAO_HAIER_TECHNOLOGY_CO_LTD: u32 = 2345;
pub const BLUETOOTH_COMPANY_ID_SAPPL_VERWALTUNGS__UND_BETRIEBS_GMBH: u32 = 2346;
pub const BLUETOOTH_COMPANY_ID_TEKHOME: u32 = 2347;
pub const BLUETOOTH_COMPANY_ID_PCI_PRIVATE_LIMITED: u32 = 2348;
pub const BLUETOOTH_COMPANY_ID_LEGGETT_AND_PLATT_INCORPORATED: u32 = 2349;
pub const BLUETOOTH_COMPANY_ID_PS_GMBH: u32 = 2350;
pub const BLUETOOTH_COMPANY_ID_COBO_SPA: u32 = 2351;
pub const BLUETOOTH_COMPANY_ID_JAMES_WALKER_ROTABOLT_LIMITED: u32 = 2352;
pub const BLUETOOTH_COMPANY_ID_BREATHINGS_CO_LTD: u32 = 2353;
pub const BLUETOOTH_COMPANY_ID_BARVISION_LLC: u32 = 2354;
pub const BLUETOOTH_COMPANY_ID_SRAM: u32 = 2355;
pub const BLUETOOTH_COMPANY_ID_KITESPRING_INC: u32 = 2356;
pub const BLUETOOTH_COMPANY_ID_RECONNECT_INC: u32 = 2357;
pub const BLUETOOTH_COMPANY_ID_ELEKON_AG: u32 = 2358;
pub const BLUETOOTH_COMPANY_ID_REALTHINGKS_GMBH: u32 = 2359;
pub const BLUETOOTH_COMPANY_ID_HENWAY_TECHNOLOGIES_LTD: u32 = 2360;
pub const BLUETOOTH_COMPANY_ID_ASTEM_COLTD: u32 = 2361;
pub const BLUETOOTH_COMPANY_ID_LINKEDSEMI_MICROELECTRONICS_CO_LTD: u32 = 2362;
pub const BLUETOOTH_COMPANY_ID_ENSESO_LLC: u32 = 2363;
pub const BLUETOOTH_COMPANY_ID_XENOMA_INC: u32 = 2364;
pub const BLUETOOTH_COMPANY_ID_ADOLF_WUERTH_GMBH_AND_CO_KG: u32 = 2365;
pub const BLUETOOTH_COMPANY_ID_CATALYFT_LABS_INC: u32 = 2366;
pub const BLUETOOTH_COMPANY_ID_JEPICO_CORPORATION: u32 = 2367;
pub const BLUETOOTH_COMPANY_ID_HERO_WORKOUT_GMBH: u32 = 2368;
pub const BLUETOOTH_COMPANY_ID_RIVIAN_AUTOMOTIVE_LLC: u32 = 2369;
pub const BLUETOOTH_COMPANY_ID_TRANSSION_HOLDINGS_LIMITED: u32 = 2370;
pub const BLUETOOTH_COMPANY_ID_INOVONICS_CORP2: u32 = 2371;
pub const BLUETOOTH_COMPANY_ID_AGITRON_DOO: u32 = 2372;
pub const BLUETOOTH_COMPANY_ID_GLOBE_CO_LTD: u32 = 2373;
pub const BLUETOOTH_COMPANY_ID_AMC_INTERNATIONAL_ALFA_METALCRAFT_CORPORATION_AG: u32 = 2374;
pub const BLUETOOTH_COMPANY_ID_FIRST_LIGHT_TECHNOLOGIES_LTD: u32 = 2375;
pub const BLUETOOTH_COMPANY_ID_WEARABLE_LINK_LIMITED: u32 = 2376;
pub const BLUETOOTH_COMPANY_ID_METRONOM_HEALTH_EUROPE: u32 = 2377;
pub const BLUETOOTH_COMPANY_ID_ZWIFT_INC: u32 = 2378;
pub const BLUETOOTH_COMPANY_ID_KINDEVA_DRUG_DELIVERY_LP: u32 = 2379;
pub const BLUETOOTH_COMPANY_ID_GIMMISYS_GMBH: u32 = 2380;
pub const BLUETOOTH_COMPANY_ID_TKLABS_INC: u32 = 2381;
pub const BLUETOOTH_COMPANY_ID_PASSIVEBOLT_INC: u32 = 2382;
pub const BLUETOOTH_COMPANY_ID_LIMITED_LIABILITY_COMPANY__MIKROTIKLS_: u32 = 2383;
pub const BLUETOOTH_COMPANY_ID_CAPETECH: u32 = 2384;
pub const BLUETOOTH_COMPANY_ID_PPRS: u32 = 2385;
pub const BLUETOOTH_COMPANY_ID_APPTRICITY_CORPORATION: u32 = 2386;
pub const BLUETOOTH_COMPANY_ID_LOGILUBE_LLC: u32 = 2387;
pub const BLUETOOTH_COMPANY_ID_JULBO: u32 = 2388;
pub const BLUETOOTH_COMPANY_ID_BREVILLE_GROUP: u32 = 2389;
pub const BLUETOOTH_COMPANY_ID_KERLINK: u32 = 2390;
pub const BLUETOOTH_COMPANY_ID_OHSUNG_ELECTRONICS: u32 = 2391;
pub const BLUETOOTH_COMPANY_ID_ZTE_CORPORATION: u32 = 2392;
pub const BLUETOOTH_COMPANY_ID_HERDDOGG_INC: u32 = 2393;
pub const BLUETOOTH_COMPANY_ID_SELEKT_BILGISAYAR_LLETISIM_URUNLERI_LNSAAT_SANAYI_VE_TICARET_LIMITED_SIRKETI : u32 = 2394 ;
pub const BLUETOOTH_COMPANY_ID_LISMORE_INSTRUMENTS_LIMITED: u32 = 2395;
pub const BLUETOOTH_COMPANY_ID_LOGILUBE_LLC2: u32 = 2396;
pub const BLUETOOTH_COMPANY_ID_ETC: u32 = 2397;
pub const BLUETOOTH_COMPANY_ID_BIOECHONET_INC: u32 = 2398;
pub const BLUETOOTH_COMPANY_ID_NUANCE_HEARING_LTD: u32 = 2399;
pub const BLUETOOTH_COMPANY_ID_SENA_TECHNOLOGIES_INC: u32 = 2400;
pub const BLUETOOTH_COMPANY_ID_LINKURA_AB: u32 = 2401;
pub const BLUETOOTH_COMPANY_ID_GL_SOLUTIONS_KK: u32 = 2402;
pub const BLUETOOTH_COMPANY_ID_MOONBIRD_BV: u32 = 2403;
pub const BLUETOOTH_COMPANY_ID_COUNTRYMATE_TECHNOLOGY_LIMITED: u32 = 2404;
pub const BLUETOOTH_COMPANY_ID_ASAHI_KASEI_CORPORATION: u32 = 2405;
pub const BLUETOOTH_COMPANY_ID_POINTGUARD_LLC: u32 = 2406;
pub const BLUETOOTH_COMPANY_ID_NEO_MATERIALS_AND_CONSULTING_INC: u32 = 2407;
pub const BLUETOOTH_COMPANY_ID_ACTEV_MOTORS_INC: u32 = 2408;
pub const BLUETOOTH_COMPANY_ID_WOAN_TECHNOLOGY_CO_LTD: u32 = 2409;
pub const BLUETOOTH_COMPANY_ID_DRICOS_INC: u32 = 2410;
pub const BLUETOOTH_COMPANY_ID_GUIDE_ID_BV: u32 = 2411;
pub const BLUETOOTH_COMPANY_ID_9374_7319_QUEBEC_INC: u32 = 2412;
pub const BLUETOOTH_COMPANY_ID_GUNWERKS_LLC: u32 = 2413;
pub const BLUETOOTH_COMPANY_ID_BAND_INDUSTRIES_INC: u32 = 2414;
pub const BLUETOOTH_COMPANY_ID_LUND_MOTION_PRODUCTS_INC: u32 = 2415;
pub const BLUETOOTH_COMPANY_ID_IBA_DOSIMETRY_GMBH: u32 = 2416;
pub const BLUETOOTH_COMPANY_ID_GA: u32 = 2417;
pub const BLUETOOTH_COMPANY_ID_CLOSED_JOINT_STOCK_COMPANY__ZAVOD_FLOMETR_: u32 = 2418;
pub const BLUETOOTH_COMPANY_ID_POPIT_OY: u32 = 2419;
pub const BLUETOOTH_COMPANY_ID_ABEYE: u32 = 2420;
pub const BLUETOOTH_COMPANY_ID_BLUEIOT_TECHNOLOGY_COLTD: u32 = 2421;
pub const BLUETOOTH_COMPANY_ID_FAUNA_AUDIO_GMBH: u32 = 2422;
pub const BLUETOOTH_COMPANY_ID_TOYOTA_MOTOR_CORPORATION: u32 = 2423;
pub const BLUETOOTH_COMPANY_ID_ZIFFEREINS_GMBH_AND_CO_KG: u32 = 2424;
pub const BLUETOOTH_COMPANY_ID_BIOTRONIK_SE_AND_CO_KG: u32 = 2425;
pub const BLUETOOTH_COMPANY_ID_CORE_CORPORATION: u32 = 2426;
pub const BLUETOOTH_COMPANY_ID_CTEK_SWEDEN_AB: u32 = 2427;
pub const BLUETOOTH_COMPANY_ID_THORLEY_INDUSTRIES_LLC: u32 = 2428;
pub const BLUETOOTH_COMPANY_ID_CLB_BV: u32 = 2429;
pub const BLUETOOTH_COMPANY_ID_SONICSENSORY_INC: u32 = 2430;
pub const BLUETOOTH_COMPANY_ID_ISEMAR_SRL: u32 = 2431;
pub const BLUETOOTH_COMPANY_ID_DEKRA_TESTING_AND_CERTIFICATION_SAU: u32 = 2432;
pub const BLUETOOTH_COMPANY_ID_BERNARD_KRONE_HOLDING_SE_AND_COKG: u32 = 2433;
pub const BLUETOOTH_COMPANY_ID_ELPRO_BUCHS_AG: u32 = 2434;
pub const BLUETOOTH_COMPANY_ID_FEEDBACK_SPORTS_LLC: u32 = 2435;
pub const BLUETOOTH_COMPANY_ID_TERATRON_GMBH: u32 = 2436;
pub const BLUETOOTH_COMPANY_ID_LUMOS_HEALTH_INC: u32 = 2437;
pub const BLUETOOTH_COMPANY_ID_CELLO_HILL_LLC: u32 = 2438;
pub const BLUETOOTH_COMPANY_ID_TSE_BRAKES_INC: u32 = 2439;
pub const BLUETOOTH_COMPANY_ID_BHM_TECH_PRODUKTIONSGESELLSCHAFT_MBH: u32 = 2440;
pub const BLUETOOTH_COMPANY_ID_WIKA_ALEXANDER_WIEGAND_SE_AND_COKG: u32 = 2441;
pub const BLUETOOTH_COMPANY_ID_BIOVIGIL: u32 = 2442;
pub const BLUETOOTH_COMPANY_ID_MEQUONIC_ENGINEERING_SL: u32 = 2443;
pub const BLUETOOTH_COMPANY_ID_BGRID_BV: u32 = 2444;
pub const BLUETOOTH_COMPANY_ID_C3_WIRELESS_LLC: u32 = 2445;
pub const BLUETOOTH_COMPANY_ID_ADVEEZ: u32 = 2446;
pub const BLUETOOTH_COMPANY_ID_AKTIEBOLAGET_REGIN: u32 = 2447;
pub const BLUETOOTH_COMPANY_ID_ANTON_PAAR_GMBH: u32 = 2448;
pub const BLUETOOTH_COMPANY_ID_TELENOR_ASA: u32 = 2449;
pub const BLUETOOTH_COMPANY_ID_BIG_KAISER_PRECISION_TOOLING_LTD: u32 = 2450;
pub const BLUETOOTH_COMPANY_ID_ABSOLUTE_AUDIO_LABS_BV: u32 = 2451;
pub const BLUETOOTH_COMPANY_ID_VT42_PTY_LTD: u32 = 2452;
pub const BLUETOOTH_COMPANY_ID_BRONKHORST_HIGH_TECH_BV: u32 = 2453;
pub const BLUETOOTH_COMPANY_ID_C_AND_E_FEIN_GMBH: u32 = 2454;
pub const BLUETOOTH_COMPANY_ID_NEXTMIND: u32 = 2455;
pub const BLUETOOTH_COMPANY_ID_PIXIE_DUST_TECHNOLOGIES_INC: u32 = 2456;
pub const BLUETOOTH_COMPANY_ID_ETACTICA_EHF: u32 = 2457;
pub const BLUETOOTH_COMPANY_ID_NEW_AUDIO_LLC: u32 = 2458;
pub const BLUETOOTH_COMPANY_ID_SENDUM_WIRELESS_CORPORATION: u32 = 2459;
pub const BLUETOOTH_COMPANY_ID_DEISTER_ELECTRONIC_GMBH: u32 = 2460;
pub const BLUETOOTH_COMPANY_ID_YKK_AP_INC: u32 = 2461;
pub const BLUETOOTH_COMPANY_ID_STEP_ONE_LIMITED: u32 = 2462;
pub const BLUETOOTH_COMPANY_ID_KOYA_MEDICAL_INC: u32 = 2463;
pub const BLUETOOTH_COMPANY_ID_PROOF_DIAGNOSTICS_INC: u32 = 2464;
pub const BLUETOOTH_COMPANY_ID_VOS_SYSTEMS_LLC: u32 = 2465;
pub const BLUETOOTH_COMPANY_ID_ENGAGENOW_DATA_SCIENCES_PRIVATE_LIMITED: u32 = 2466;
pub const BLUETOOTH_COMPANY_ID_ARDUINO_SA: u32 = 2467;
pub const BLUETOOTH_COMPANY_ID_KUMHO_ELECTRICS_INC: u32 = 2468;
pub const BLUETOOTH_COMPANY_ID_SECURITY_ENHANCEMENT_SYSTEMS_LLC: u32 = 2469;
pub const BLUETOOTH_COMPANY_ID_BEIJING_ELECTRIC_VEHICLE_COLTD: u32 = 2470;
pub const BLUETOOTH_COMPANY_ID_PAYBUDDY_APS: u32 = 2471;
pub const BLUETOOTH_COMPANY_ID_KHN_SOLUTIONS_INC: u32 = 2472;
pub const BLUETOOTH_COMPANY_ID_NIPPON_CERAMIC_COLTD: u32 = 2473;
pub const BLUETOOTH_COMPANY_ID_PHOTODYNAMIC_INCORPORATED: u32 = 2474;
pub const BLUETOOTH_COMPANY_ID_DASHLOGIC_INC: u32 = 2475;
pub const BLUETOOTH_COMPANY_ID_AMBIQ: u32 = 2476;
pub const BLUETOOTH_COMPANY_ID_NARHWALL_INC: u32 = 2477;
pub const BLUETOOTH_COMPANY_ID_POZYX_NV: u32 = 2478;
pub const BLUETOOTH_COMPANY_ID_IFLINK_OPEN_COMMUNITY: u32 = 2479;
pub const BLUETOOTH_COMPANY_ID_DEUBLIN_COMPANY_LLC: u32 = 2480;
pub const BLUETOOTH_COMPANY_ID_BLINQY: u32 = 2481;
pub const BLUETOOTH_COMPANY_ID_DYPHI: u32 = 2482;
pub const BLUETOOTH_COMPANY_ID_BLUEX_MICROELECTRONICS_CORP_LTD: u32 = 2483;
pub const BLUETOOTH_COMPANY_ID_PENTALOCK_APS: u32 = 2484;
pub const BLUETOOTH_COMPANY_ID_AUTEC_GESELLSCHAFT_FUER_AUTOMATIONSTECHNIK_MBH: u32 = 2485;
pub const BLUETOOTH_COMPANY_ID_PEGASUS_TECHNOLOGIES_INC: u32 = 2486;
pub const BLUETOOTH_COMPANY_ID_BOUT_LABS_LLC: u32 = 2487;
pub const BLUETOOTH_COMPANY_ID_PLAYERDATA_LIMITED: u32 = 2488;
pub const BLUETOOTH_COMPANY_ID_SAVOY_ELECTRONIC_LIGHTING: u32 = 2489;
pub const BLUETOOTH_COMPANY_ID_ELIMO_ENGINEERING_LTD: u32 = 2490;
pub const BLUETOOTH_COMPANY_ID_SKYSTREAM_CORPORATION: u32 = 2491;
pub const BLUETOOTH_COMPANY_ID_AEROSENS_LLC: u32 = 2492;
pub const BLUETOOTH_COMPANY_ID_CENTRE_SUISSE_D_ELECTRONIQUE_ET_DE_MICROTECHNIQUE_SA: u32 = 2493;
pub const BLUETOOTH_COMPANY_ID_VESSEL_LTD: u32 = 2494;
pub const BLUETOOTH_COMPANY_ID_SPANIO_INC: u32 = 2495;
pub const BLUETOOTH_COMPANY_ID_ANOTHERBRAIN_INC: u32 = 2496;
pub const BLUETOOTH_COMPANY_ID_ROSEWILL: u32 = 2497;
pub const BLUETOOTH_COMPANY_ID_UNIVERSAL_AUDIO_INC: u32 = 2498;
pub const BLUETOOTH_COMPANY_ID_JAPAN_TOBACCO_INC: u32 = 2499;
pub const BLUETOOTH_COMPANY_ID_UVISIO: u32 = 2500;
pub const BLUETOOTH_COMPANY_ID_HUNGYI_MICROELECTRONICS_COLTD: u32 = 2501;
pub const BLUETOOTH_COMPANY_ID_HONOR_DEVICE_CO_LTD: u32 = 2502;
pub const BLUETOOTH_COMPANY_ID_COMBUSTION_LLC: u32 = 2503;
pub const BLUETOOTH_COMPANY_ID_XUNTONG: u32 = 2504;
pub const BLUETOOTH_COMPANY_ID_CROWDGLOW_LTD: u32 = 2505;
pub const BLUETOOTH_COMPANY_ID_MOBITRACE: u32 = 2506;
pub const BLUETOOTH_COMPANY_ID_HX_ENGINEERING_LLC: u32 = 2507;
pub const BLUETOOTH_COMPANY_ID_SENSO4S_DOO: u32 = 2508;
pub const BLUETOOTH_COMPANY_ID_BLYOTT: u32 = 2509;
pub const BLUETOOTH_COMPANY_ID_JULIUS_BLUM_GMBH: u32 = 2510;
pub const BLUETOOTH_COMPANY_ID_BLUESTREAK_IOT_LLC: u32 = 2511;
pub const BLUETOOTH_COMPANY_ID_CHESS_WISE_BV: u32 = 2512;
pub const BLUETOOTH_COMPANY_ID_ABLEPAY_TECHNOLOGIES_AS: u32 = 2513;
pub const BLUETOOTH_COMPANY_ID_TEMPERATURE_SENSITIVE_SOLUTIONS_SYSTEMS_SWEDEN_AB: u32 = 2514;
pub const BLUETOOTH_COMPANY_ID_HEARTHERO_INC: u32 = 2515;
pub const BLUETOOTH_COMPANY_ID_ORBIS_INC: u32 = 2516;
pub const BLUETOOTH_COMPANY_ID_GEAR_RADIO_ELECTRONICS_CORP: u32 = 2517;
pub const BLUETOOTH_COMPANY_ID_EAR_TEKNIK_ISITME_VE_ODIOMETRI_CIHAZLARI_SANAYI_VE_TICARET_ANONIM_SIRKETI : u32 = 2518 ;
pub const BLUETOOTH_COMPANY_ID_COYOTTA: u32 = 2519;
pub const BLUETOOTH_COMPANY_ID_SYNERGY_TECNOLOGIA_EM_SISTEMAS_LTDA: u32 = 2520;
pub const BLUETOOTH_COMPANY_ID_VIVOSENSMEDICAL_GMBH: u32 = 2521;
pub const BLUETOOTH_COMPANY_ID_NAGRAVISION_SA: u32 = 2522;
pub const BLUETOOTH_COMPANY_ID_BIONIC_AVIONICS_INC: u32 = 2523;
pub const BLUETOOTH_COMPANY_ID_AON2_LTD: u32 = 2524;
pub const BLUETOOTH_COMPANY_ID_INNOWARE_DEVELOPMENT_AB: u32 = 2525;
pub const BLUETOOTH_COMPANY_ID_JLD_TECHNOLOGY_SOLUTIONS_LLC: u32 = 2526;
pub const BLUETOOTH_COMPANY_ID_MAGNUS_TECHNOLOGY_SDN_BHD: u32 = 2527;
pub const BLUETOOTH_COMPANY_ID_PREDDIO_TECHNOLOGIES_INC: u32 = 2528;
pub const BLUETOOTH_COMPANY_ID_TAG_N_TRAC_INC: u32 = 2529;
pub const BLUETOOTH_COMPANY_ID_WUHAN_LINPTECH_COLTD: u32 = 2530;
pub const BLUETOOTH_COMPANY_ID_FRIDAY_HOME_APS: u32 = 2531;
pub const BLUETOOTH_COMPANY_ID_CPS_AS: u32 = 2532;
pub const BLUETOOTH_COMPANY_ID_MOBILOGIX: u32 = 2533;
pub const BLUETOOTH_COMPANY_ID_MASONITE_CORPORATION: u32 = 2534;
pub const BLUETOOTH_COMPANY_ID_KABUSHIKIGAISHA_HANERON: u32 = 2535;
pub const BLUETOOTH_COMPANY_ID_MELANGE_SYSTEMS_PVT_LTD: u32 = 2536;
pub const BLUETOOTH_COMPANY_ID_LUMENRADIO_AB: u32 = 2537;
pub const BLUETOOTH_COMPANY_ID_ATHLOS_OY: u32 = 2538;
pub const BLUETOOTH_COMPANY_ID_KEAN_ELECTRONICS_PTY_LTD: u32 = 2539;
pub const BLUETOOTH_COMPANY_ID_YUKON_ADVANCED_OPTICS_WORLDWIDE_UAB: u32 = 2540;
pub const BLUETOOTH_COMPANY_ID_SIBEL_INC: u32 = 2541;
pub const BLUETOOTH_COMPANY_ID_OJMAR_SA: u32 = 2542;
pub const BLUETOOTH_COMPANY_ID_STEINEL_SOLUTIONS_AG: u32 = 2543;
pub const BLUETOOTH_COMPANY_ID_WATCHGAS_BV: u32 = 2544;
pub const BLUETOOTH_COMPANY_ID_OM_DIGITAL_SOLUTIONS_CORPORATION: u32 = 2545;
pub const BLUETOOTH_COMPANY_ID_AUDEARA_PTY_LTD: u32 = 2546;
pub const BLUETOOTH_COMPANY_ID_BEIJING_ZERO_ZERO_INFINITY_TECHNOLOGY_COLTD: u32 = 2547;
pub const BLUETOOTH_COMPANY_ID_SPECTRUM_TECHNOLOGIES_INC: u32 = 2548;
pub const BLUETOOTH_COMPANY_ID_OKI_ELECTRIC_INDUSTRY_CO_LTD: u32 = 2549;
pub const BLUETOOTH_COMPANY_ID_MOBILE_ACTION_TECHNOLOGY_INC: u32 = 2550;
pub const BLUETOOTH_COMPANY_ID_SENSATEC_CO_LTD: u32 = 2551;
pub const BLUETOOTH_COMPANY_ID_RO_SRL: u32 = 2552;
pub const BLUETOOTH_COMPANY_ID_HANGZHOU_YAGUAN_TECHNOLOGY_CO_LTD: u32 = 2553;
pub const BLUETOOTH_COMPANY_ID_LISTEN_TECHNOLOGIES_CORPORATION: u32 = 2554;
pub const BLUETOOTH_COMPANY_ID_TOITU_CO_LTD: u32 = 2555;
pub const BLUETOOTH_COMPANY_ID_CONFIDEX: u32 = 2556;
pub const BLUETOOTH_COMPANY_ID_KEEP_TECHNOLOGIES_INC: u32 = 2557;
pub const BLUETOOTH_COMPANY_ID_LICHTVISION_ENGINEERING_GMBH: u32 = 2558;
pub const BLUETOOTH_COMPANY_ID_AIRSTAR: u32 = 2559;
pub const BLUETOOTH_COMPANY_ID_AMPLER_BIKES_OU: u32 = 2560;
pub const BLUETOOTH_COMPANY_ID_CLEVERON_AS: u32 = 2561;
pub const BLUETOOTH_COMPANY_ID_AYXON_DYNAMICS_GMBH: u32 = 2562;
pub const BLUETOOTH_COMPANY_ID_DONUTROBOTICS_CO_LTD: u32 = 2563;
pub const BLUETOOTH_COMPANY_ID_FLOSONICS_MEDICAL: u32 = 2564;
pub const BLUETOOTH_COMPANY_ID_SOUTHWIRE_COMPANY_LLC: u32 = 2565;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_WUQI_MICROELECTRONICS_COLTD: u32 = 2566;
pub const BLUETOOTH_COMPANY_ID_REFLOW_PTY_LTD: u32 = 2567;
pub const BLUETOOTH_COMPANY_ID_ORAS_OY: u32 = 2568;
pub const BLUETOOTH_COMPANY_ID_ECCT: u32 = 2569;
pub const BLUETOOTH_COMPANY_ID_VOLAN_TECHNOLOGY_INC: u32 = 2570;
pub const BLUETOOTH_COMPANY_ID_SIANA_SYSTEMS: u32 = 2571;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_YIDIAN_INTELLIGENT_TECHNOLOGY_CO_LTD: u32 = 2572;
pub const BLUETOOTH_COMPANY_ID_BLUE_PEACOCK_GMBH: u32 = 2573;
pub const BLUETOOTH_COMPANY_ID_ROLAND_CORPORATION: u32 = 2574;
pub const BLUETOOTH_COMPANY_ID_LIXIL_CORPORATION: u32 = 2575;
pub const BLUETOOTH_COMPANY_ID_SUBARU_CORPORATION: u32 = 2576;
pub const BLUETOOTH_COMPANY_ID_SENSOLUS: u32 = 2577;
pub const BLUETOOTH_COMPANY_ID_DYSON_TECHNOLOGY_LIMITED: u32 = 2578;
pub const BLUETOOTH_COMPANY_ID_TEC4MED_LIFESCIENCE_GMBH: u32 = 2579;
pub const BLUETOOTH_COMPANY_ID_CROXEL_INC: u32 = 2580;
pub const BLUETOOTH_COMPANY_ID_SYNG_INC: u32 = 2581;
pub const BLUETOOTH_COMPANY_ID_RIDE_VISION_LTD: u32 = 2582;
pub const BLUETOOTH_COMPANY_ID_PLUME_DESIGN_INC: u32 = 2583;
pub const BLUETOOTH_COMPANY_ID_CAMBRIDGE_ANIMAL_TECHNOLOGIES_LTD: u32 = 2584;
pub const BLUETOOTH_COMPANY_ID_MAXELL_LTD: u32 = 2585;
pub const BLUETOOTH_COMPANY_ID_LINK_LABS_INC: u32 = 2586;
pub const BLUETOOTH_COMPANY_ID_EMBRAVA_PTY_LTD: u32 = 2587;
pub const BLUETOOTH_COMPANY_ID_INPEAK_SC: u32 = 2588;
pub const BLUETOOTH_COMPANY_ID_API_K: u32 = 2589;
pub const BLUETOOTH_COMPANY_ID_COMBIQ_AB: u32 = 2590;
pub const BLUETOOTH_COMPANY_ID_DEVILBISS_HEALTHCARE_LLC: u32 = 2591;
pub const BLUETOOTH_COMPANY_ID_JIANGXI_INNOTECH_TECHNOLOGY_CO_LTD: u32 = 2592;
pub const BLUETOOTH_COMPANY_ID_APOLLOGIC_SP_Z_OO: u32 = 2593;
pub const BLUETOOTH_COMPANY_ID_DAIICHIKOSHO_CO_LTD: u32 = 2594;
pub const BLUETOOTH_COMPANY_ID_BIXOLON_COLTD: u32 = 2595;
pub const BLUETOOTH_COMPANY_ID_ATMOSIC_TECHNOLOGIES_INC: u32 = 2596;
pub const BLUETOOTH_COMPANY_ID_ERAN_FINANCIAL_SERVICES_LLC: u32 = 2597;
pub const BLUETOOTH_COMPANY_ID_LOUIS_VUITTON: u32 = 2598;
pub const BLUETOOTH_COMPANY_ID_AYU_DEVICES_PRIVATE_LIMITED: u32 = 2599;
pub const BLUETOOTH_COMPANY_ID_NANOFLEX: u32 = 2600;
pub const BLUETOOTH_COMPANY_ID_WORTHCLOUD_TECHNOLOGY_COLTD: u32 = 2601;
pub const BLUETOOTH_COMPANY_ID_YAMAHA_CORPORATION: u32 = 2602;
pub const BLUETOOTH_COMPANY_ID_PACEBAIT_IVS: u32 = 2603;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_HANDT_INTELLIGENT_CONTROL_CO_LTD: u32 = 2604;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_FEASYCOM_TECHNOLOGY_CO_LTD: u32 = 2605;
pub const BLUETOOTH_COMPANY_ID_ZUMA_ARRAY_LIMITED: u32 = 2606;
pub const BLUETOOTH_COMPANY_ID_INSTAMIC_INC: u32 = 2607;
pub const BLUETOOTH_COMPANY_ID_AIR_WEIGH: u32 = 2608;
pub const BLUETOOTH_COMPANY_ID_NEVRO_CORP: u32 = 2609;
pub const BLUETOOTH_COMPANY_ID_PINNACLE_TECHNOLOGY_INC: u32 = 2610;
pub const BLUETOOTH_COMPANY_ID_WMF_AG: u32 = 2611;
pub const BLUETOOTH_COMPANY_ID_LUXER_CORPORATION: u32 = 2612;
pub const BLUETOOTH_COMPANY_ID_SAFECTORY_GMBH: u32 = 2613;
pub const BLUETOOTH_COMPANY_ID_NGK_SPARK_PLUG_CO_LTD: u32 = 2614;
pub const BLUETOOTH_COMPANY_ID_2587702_ONTARIO_INC: u32 = 2615;
pub const BLUETOOTH_COMPANY_ID_BOUFFALO_LAB_LTD: u32 = 2616;
pub const BLUETOOTH_COMPANY_ID_BLUETICKETING_SRL: u32 = 2617;
pub const BLUETOOTH_COMPANY_ID_INCOTEX_CO_LTD: u32 = 2618;
pub const BLUETOOTH_COMPANY_ID_GALILEO_TECHNOLOGY_LIMITED: u32 = 2619;
pub const BLUETOOTH_COMPANY_ID_SITECO_GMBH: u32 = 2620;
pub const BLUETOOTH_COMPANY_ID_DELABIE: u32 = 2621;
pub const BLUETOOTH_COMPANY_ID_HEFEI_YUNLIAN_SEMICONDUCTOR_CO_LTD: u32 = 2622;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_YOPEAK_OPTOELECTRONICS_TECHNOLOGY_CO_LTD: u32 = 2623;
pub const BLUETOOTH_COMPANY_ID_GEWISS_SPA: u32 = 2624;
pub const BLUETOOTH_COMPANY_ID_OPEX_CORPORATION: u32 = 2625;
pub const BLUETOOTH_COMPANY_ID_MOTIONALYSIS_INC: u32 = 2626;
pub const BLUETOOTH_COMPANY_ID_BUSCH_SYSTEMS_INTERNATIONAL_INC: u32 = 2627;
pub const BLUETOOTH_COMPANY_ID_NOVIDAN_INC: u32 = 2628;
pub const BLUETOOTH_COMPANY_ID_3SI_SECURITY_SYSTEMS_INC: u32 = 2629;
pub const BLUETOOTH_COMPANY_ID_BEIJING_HC_INFINITE_TECHNOLOGY_LIMITED: u32 = 2630;
pub const BLUETOOTH_COMPANY_ID_THE_WAND_COMPANY_LTD: u32 = 2631;
pub const BLUETOOTH_COMPANY_ID_JRC_MOBILITY_INC: u32 = 2632;
pub const BLUETOOTH_COMPANY_ID_VENTURE_RESEARCH_INC: u32 = 2633;
pub const BLUETOOTH_COMPANY_ID_MAP_LARGE_INC: u32 = 2634;
pub const BLUETOOTH_COMPANY_ID_MISTYWEST_ENERGY_AND_TRANSPORT_LTD: u32 = 2635;
pub const BLUETOOTH_COMPANY_ID_SIFLI_TECHNOLOGIES_INC: u32 = 2636;
pub const BLUETOOTH_COMPANY_ID_LOCKN_TECHNOLOGIES_PRIVATE_LIMITED: u32 = 2637;
pub const BLUETOOTH_COMPANY_ID_TOYTEC_CORPORATION: u32 = 2638;
pub const BLUETOOTH_COMPANY_ID_VANMOOF_GLOBAL_HOLDING_BV: u32 = 2639;
pub const BLUETOOTH_COMPANY_ID_NEXTSCAPE_INC: u32 = 2640;
pub const BLUETOOTH_COMPANY_ID_CSIRO: u32 = 2641;
pub const BLUETOOTH_COMPANY_ID_FOLLOW_SENSE_EUROPE_BV: u32 = 2642;
pub const BLUETOOTH_COMPANY_ID_KKM_COMPANY_LIMITED: u32 = 2643;
pub const BLUETOOTH_COMPANY_ID_SQL_TECHNOLOGIES_CORP: u32 = 2644;
pub const BLUETOOTH_COMPANY_ID_INUGO_SYSTEMS_LIMITED: u32 = 2645;
pub const BLUETOOTH_COMPANY_ID_AMBIE: u32 = 2646;
pub const BLUETOOTH_COMPANY_ID_MEIZHOU_GUO_WEI_ELECTRONICS_CO_LTD: u32 = 2647;
pub const BLUETOOTH_COMPANY_ID_INDIGO_DIABETES: u32 = 2648;
pub const BLUETOOTH_COMPANY_ID_TOURBUILT_LLC: u32 = 2649;
pub const BLUETOOTH_COMPANY_ID_SONTHEIM_INDUSTRIE_ELEKTRONIK_GMBH: u32 = 2650;
pub const BLUETOOTH_COMPANY_ID_LEGIC_IDENTSYSTEMS_AG: u32 = 2651;
pub const BLUETOOTH_COMPANY_ID_INNOVATIVE_DESIGN_LABS_INC: u32 = 2652;
pub const BLUETOOTH_COMPANY_ID_MG_ENERGY_SYSTEMS_BV: u32 = 2653;
pub const BLUETOOTH_COMPANY_ID_LACECLIPS_LLC: u32 = 2654;
pub const BLUETOOTH_COMPANY_ID_STRYKER: u32 = 2655;
pub const BLUETOOTH_COMPANY_ID_DATANG_SEMICONDUCTOR_TECHNOLOGY_COLTD: u32 = 2656;
pub const BLUETOOTH_COMPANY_ID_SMART_PARKS_BV: u32 = 2657;
pub const BLUETOOTH_COMPANY_ID_MOKO_TECHNOLOGY_LTD: u32 = 2658;
pub const BLUETOOTH_COMPANY_ID_GREMSY_JSC: u32 = 2659;
pub const BLUETOOTH_COMPANY_ID_GEOPAL_SYSTEM_A_S: u32 = 2660;
pub const BLUETOOTH_COMPANY_ID_LYTX_INC: u32 = 2661;
pub const BLUETOOTH_COMPANY_ID_JUSTMORPH_PTE_LTD: u32 = 2662;
pub const BLUETOOTH_COMPANY_ID_BEIJING_SUPERHEXA_CENTURY_TECHNOLOGY_CO_LTD: u32 = 2663;
pub const BLUETOOTH_COMPANY_ID_FOCUS_INGENIERIA_SRL: u32 = 2664;
pub const BLUETOOTH_COMPANY_ID_HAPPIEST_BABY_INC: u32 = 2665;
pub const BLUETOOTH_COMPANY_ID_SCRIBBLE_DESIGN_INC: u32 = 2666;
pub const BLUETOOTH_COMPANY_ID_OLYMPIC_OPHTHALMICS_INC: u32 = 2667;
pub const BLUETOOTH_COMPANY_ID_POKKELS: u32 = 2668;
pub const BLUETOOTH_COMPANY_ID_KUUKANJYOKIN_COLTD: u32 = 2669;
pub const BLUETOOTH_COMPANY_ID_PAC_SANE_LIMITED: u32 = 2670;
pub const BLUETOOTH_COMPANY_ID_WARNER_BROS: u32 = 2671;
pub const BLUETOOTH_COMPANY_ID_OOMA: u32 = 2672;
pub const BLUETOOTH_COMPANY_ID_SENQUIP_PTY_LTD: u32 = 2673;
pub const BLUETOOTH_COMPANY_ID_JUMO_GMBH_AND_CO_KG: u32 = 2674;
pub const BLUETOOTH_COMPANY_ID_INNOHOME_OY: u32 = 2675;
pub const BLUETOOTH_COMPANY_ID_MICROSON_SA: u32 = 2676;
pub const BLUETOOTH_COMPANY_ID_DELTA_CYCLE_CORPORATION: u32 = 2677;
pub const BLUETOOTH_COMPANY_ID_SYNAPTICS_INCORPORATED: u32 = 2678;
pub const BLUETOOTH_COMPANY_ID_JMD_PACIFIC_PTE_LTD: u32 = 2679;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_SUNRICHER_TECHNOLOGY_LIMITED: u32 = 2680;
pub const BLUETOOTH_COMPANY_ID_WEBASTO_SE: u32 = 2681;
pub const BLUETOOTH_COMPANY_ID_EMLID_LIMITED: u32 = 2682;
pub const BLUETOOTH_COMPANY_ID_UNIQAIR_OY: u32 = 2683;
pub const BLUETOOTH_COMPANY_ID_WAFERLOCK: u32 = 2684;
pub const BLUETOOTH_COMPANY_ID_FREEDMAN_ELECTRONICS_PTY_LTD: u32 = 2685;
pub const BLUETOOTH_COMPANY_ID_KEBA_AG: u32 = 2686;
pub const BLUETOOTH_COMPANY_ID_INTUITY_MEDICAL: u32 = 2687;
pub const BLUETOOTH_COMPANY_ID_CLEER_LIMITED: u32 = 2688;
pub const BLUETOOTH_COMPANY_ID_UNIVERSAL_BIOSENSORS_PTY_LTD: u32 = 2689;
pub const BLUETOOTH_COMPANY_ID_CORSAIR: u32 = 2690;
pub const BLUETOOTH_COMPANY_ID_RIVATA_INC: u32 = 2691;
pub const BLUETOOTH_COMPANY_ID_GREENNOTE_INC: u32 = 2692;
pub const BLUETOOTH_COMPANY_ID_SNOWBALL_TECHNOLOGY_CO_LTD: u32 = 2693;
pub const BLUETOOTH_COMPANY_ID_ALIZENT_INTERNATIONAL: u32 = 2694;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_SMART_SYSTEM_TECHNOLOGY_CO_LTD: u32 = 2695;
pub const BLUETOOTH_COMPANY_ID_PSA_PEUGEOT_CITROEN: u32 = 2696;
pub const BLUETOOTH_COMPANY_ID_SES_IMAGOTAG: u32 = 2697;
pub const BLUETOOTH_COMPANY_ID_HAINBUCH_SPANNENDE_TECHNIK: u32 = 2698;
pub const BLUETOOTH_COMPANY_ID_SANLIGHT_GMBH: u32 = 2699;
pub const BLUETOOTH_COMPANY_ID_DELPSYS_SRO: u32 = 2700;
pub const BLUETOOTH_COMPANY_ID_JCM_TECHNOLOGIES_SA: u32 = 2701;
pub const BLUETOOTH_COMPANY_ID_PERFECT_COMPANY: u32 = 2702;
pub const BLUETOOTH_COMPANY_ID_TOTO_LTD: u32 = 2703;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_GRANDSUN_ELECTRONIC_COLTD: u32 = 2704;
pub const BLUETOOTH_COMPANY_ID_MONARCH_INTERNATIONAL_INC: u32 = 2705;
pub const BLUETOOTH_COMPANY_ID_CARESTREAM_DENTAL_LLC: u32 = 2706;
pub const BLUETOOTH_COMPANY_ID_GIPSTECH_SRL: u32 = 2707;
pub const BLUETOOTH_COMPANY_ID_OOBIK_INC: u32 = 2708;
pub const BLUETOOTH_COMPANY_ID_PAMEX_INC: u32 = 2709;
pub const BLUETOOTH_COMPANY_ID_LIGHTRICITY_LTD: u32 = 2710;
pub const BLUETOOTH_COMPANY_ID_SENSTEK: u32 = 2711;
pub const BLUETOOTH_COMPANY_ID_FOIL_INC: u32 = 2712;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_HIGH_FLYING_ELECTRONICS_TECHNOLOGY_COLTD: u32 = 2713;
pub const BLUETOOTH_COMPANY_ID_TEMKIN_ASSOCIATES_LLC: u32 = 2714;
pub const BLUETOOTH_COMPANY_ID_EELLO_LLC: u32 = 2715;
pub const BLUETOOTH_COMPANY_ID_XI_AN_FENGYU_INFORMATION_TECHNOLOGY_CO_LTD: u32 = 2716;
pub const BLUETOOTH_COMPANY_ID_CANON_FINETECH_NISCA_INC: u32 = 2717;
pub const BLUETOOTH_COMPANY_ID_LIFEPLUS_INC: u32 = 2718;
pub const BLUETOOTH_COMPANY_ID_ISTA_INTERNATIONAL_GMBH: u32 = 2719;
pub const BLUETOOTH_COMPANY_ID_LOY_TEC_ELECTRONICS_GMBH: u32 = 2720;
pub const BLUETOOTH_COMPANY_ID_LINCOGN_TECHNOLOGY_CO_LIMITED: u32 = 2721;
pub const BLUETOOTH_COMPANY_ID_CARE_BLOOM_LLC: u32 = 2722;
pub const BLUETOOTH_COMPANY_ID_DIC_CORPORATION: u32 = 2723;
pub const BLUETOOTH_COMPANY_ID_FAZEPRO_LLC: u32 = 2724;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_UASCENT_TECHNOLOGY_CO_LTD: u32 = 2725;
pub const BLUETOOTH_COMPANY_ID_REALITYWORKS_INC: u32 = 2726;
pub const BLUETOOTH_COMPANY_ID_URBANISTA_AB: u32 = 2727;
pub const BLUETOOTH_COMPANY_ID_ZENCONTROL_PTY_LTD: u32 = 2728;
pub const BLUETOOTH_COMPANY_ID_MRINQ_TECHNOLOGIES_LLC: u32 = 2729;
pub const BLUETOOTH_COMPANY_ID_COMPUTIME_INTERNATIONAL_LTD: u32 = 2730;
pub const BLUETOOTH_COMPANY_ID_ANHUI_LISTENAI_CO: u32 = 2731;
pub const BLUETOOTH_COMPANY_ID_OSM_HK_LIMITED: u32 = 2732;
pub const BLUETOOTH_COMPANY_ID_ADEVO_CONSULTING_AB: u32 = 2733;
pub const BLUETOOTH_COMPANY_ID_PS_ENGINEERING_INC: u32 = 2734;
pub const BLUETOOTH_COMPANY_ID_AIAIAI_APS: u32 = 2735;
pub const BLUETOOTH_COMPANY_ID_VISIONTRONIC_SRO: u32 = 2736;
pub const BLUETOOTH_COMPANY_ID_INVUE_SECURITY_PRODUCTS_INC: u32 = 2737;
pub const BLUETOOTH_COMPANY_ID_TOUCHTRONICS_INC: u32 = 2738;
pub const BLUETOOTH_COMPANY_ID_INNER_RANGE_PTY_LTD: u32 = 2739;
pub const BLUETOOTH_COMPANY_ID_ELLENBY_TECHNOLOGIES_INC: u32 = 2740;
pub const BLUETOOTH_COMPANY_ID_ELSTAT_LTD__FORMERLY_ELSTAT_ELECTRONICS_LTD: u32 = 2741;
pub const BLUETOOTH_COMPANY_ID_XENTER_INC: u32 = 2742;
pub const BLUETOOTH_COMPANY_ID_LOGTAG_NORTH_AMERICA_INC: u32 = 2743;
pub const BLUETOOTH_COMPANY_ID_SENSAI_INCORPORATED: u32 = 2744;
pub const BLUETOOTH_COMPANY_ID_STL: u32 = 2745;
pub const BLUETOOTH_COMPANY_ID_OPEN_BIONICS_LTD: u32 = 2746;
pub const BLUETOOTH_COMPANY_ID_R_DAS_SRO: u32 = 2747;
pub const BLUETOOTH_COMPANY_ID_KCCS_MOBILE_ENGINEERING_CO_LTD: u32 = 2748;
pub const BLUETOOTH_COMPANY_ID_INVENTAS_AS: u32 = 2749;
pub const BLUETOOTH_COMPANY_ID_ROBKOO_INFORMATION_AND_TECHNOLOGIES_CO_LTD: u32 = 2750;
pub const BLUETOOTH_COMPANY_ID_PAUL_HARTMANN_AG: u32 = 2751;
pub const BLUETOOTH_COMPANY_ID_OMNI_ID_USA_INC: u32 = 2752;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_JINGXUN_TECHNOLOGY_CO_LTD: u32 = 2753;
pub const BLUETOOTH_COMPANY_ID_REALMEGA_MICROELECTRONICS_TECHNOLOGY_CO_LTD: u32 = 2754;
pub const BLUETOOTH_COMPANY_ID_KENZEN_INC: u32 = 2755;
pub const BLUETOOTH_COMPANY_ID_CODIUM: u32 = 2756;
pub const BLUETOOTH_COMPANY_ID_FLEXOPTIX_GMBH: u32 = 2757;
pub const BLUETOOTH_COMPANY_ID_BARNES_GROUP_INC: u32 = 2758;
pub const BLUETOOTH_COMPANY_ID_CHENGDU_AICH_TECHNOLOGY_COLTD: u32 = 2759;
pub const BLUETOOTH_COMPANY_ID_KEEPIN_CO_LTD: u32 = 2760;
pub const BLUETOOTH_COMPANY_ID_SWEDLOCK_AB: u32 = 2761;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_COOLKIT_TECHNOLOGY_CO_LTD: u32 = 2762;
pub const BLUETOOTH_COMPANY_ID_ISE_INDIVIDUELLE_SOFTWARE_UND_ELEKTRONIK_GMBH: u32 = 2763;
pub const BLUETOOTH_COMPANY_ID_NUVOTON: u32 = 2764;
pub const BLUETOOTH_COMPANY_ID_VISUALLEX_SPORT_INTERNATIONAL_LIMITED: u32 = 2765;
pub const BLUETOOTH_COMPANY_ID_KOBATA_GAUGE_MFG_CO_LTD: u32 = 2766;
pub const BLUETOOTH_COMPANY_ID_CACI_TECHNOLOGIES: u32 = 2767;
pub const BLUETOOTH_COMPANY_ID_NORDIC_STRONG_APS: u32 = 2768;
pub const BLUETOOTH_COMPANY_ID_EAGLE_KINGDOM_TECHNOLOGIES_LIMITED: u32 = 2769;
pub const BLUETOOTH_COMPANY_ID_LAUTSPRECHER_TEUFEL_GMBH: u32 = 2770;
pub const BLUETOOTH_COMPANY_ID_SSV_SOFTWARE_SYSTEMS_GMBH: u32 = 2771;
pub const BLUETOOTH_COMPANY_ID_ZHUHAI_PANTUM_ELECTRONISC_CO_LTD: u32 = 2772;
pub const BLUETOOTH_COMPANY_ID_STREAMIT_BV: u32 = 2773;
pub const BLUETOOTH_COMPANY_ID_NYMEA_GMBH: u32 = 2774;
pub const BLUETOOTH_COMPANY_ID_AL_KO_GERAETE_GMBH: u32 = 2775;
pub const BLUETOOTH_COMPANY_ID_FRANZ_KALDEWEI_GMBHANDCO_KG: u32 = 2776;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_AIMORE_COLTD: u32 = 2777;
pub const BLUETOOTH_COMPANY_ID_CODEFABRIK_GMBH: u32 = 2778;
pub const BLUETOOTH_COMPANY_ID_REELABLES_INC: u32 = 2779;
pub const BLUETOOTH_COMPANY_ID_DURAVIT_AG: u32 = 2780;
pub const BLUETOOTH_COMPANY_ID_BOSS_AUDIO: u32 = 2781;
pub const BLUETOOTH_COMPANY_ID_VOCERA_COMMUNICATIONS_INC: u32 = 2782;
pub const BLUETOOTH_COMPANY_ID_DOUGLAS_DYNAMICS_LLC: u32 = 2783;
pub const BLUETOOTH_COMPANY_ID_VICEROY_DEVICES_CORPORATION: u32 = 2784;
pub const BLUETOOTH_COMPANY_ID_CHENGDU_FORTHINK_TECHNOLOGY_CO_LTD: u32 = 2785;
pub const BLUETOOTH_COMPANY_ID_IMATRIX_SYSTEMS_INC: u32 = 2786;
pub const BLUETOOTH_COMPANY_ID_GLOBALMED: u32 = 2787;
pub const BLUETOOTH_COMPANY_ID_DALI_ALLIANCE: u32 = 2788;
pub const BLUETOOTH_COMPANY_ID_UNU_GMBH: u32 = 2789;
pub const BLUETOOTH_COMPANY_ID_HEXOLOGY: u32 = 2790;
pub const BLUETOOTH_COMPANY_ID_SUNPLUS_TECHNOLOGY_CO_LTD: u32 = 2791;
pub const BLUETOOTH_COMPANY_ID_LEVEL_SRO: u32 = 2792;
pub const BLUETOOTH_COMPANY_ID_FLIR_SYSTEMS_AB: u32 = 2793;
pub const BLUETOOTH_COMPANY_ID_BORDA_TECHNOLOGY: u32 = 2794;
pub const BLUETOOTH_COMPANY_ID_SQUARE_INC: u32 = 2795;
pub const BLUETOOTH_COMPANY_ID_FUTEK_ADVANCED_SENSOR_TECHNOLOGY_INC: u32 = 2796;
pub const BLUETOOTH_COMPANY_ID_SAXONAR_GMBH: u32 = 2797;
pub const BLUETOOTH_COMPANY_ID_VELENTIUM_LLC: u32 = 2798;
pub const BLUETOOTH_COMPANY_ID_GLP_GERMAN_LIGHT_PRODUCTS_GMBH: u32 = 2799;
pub const BLUETOOTH_COMPANY_ID_LEUPOLD_AND_STEVENS_INC: u32 = 2800;
pub const BLUETOOTH_COMPANY_ID_CRADERSCOLTD: u32 = 2801;
pub const BLUETOOTH_COMPANY_ID_SHANGHAI_ALL_LINK_MICROELECTRONICS_COLTD: u32 = 2802;
pub const BLUETOOTH_COMPANY_ID_701X_INC: u32 = 2803;
pub const BLUETOOTH_COMPANY_ID_RADIOWORKS_MICROELECTRONICS_PTY_LTD: u32 = 2804;
pub const BLUETOOTH_COMPANY_ID_UNITECH_ELECTRONIC_INC: u32 = 2805;
pub const BLUETOOTH_COMPANY_ID_AMETEK_INC: u32 = 2806;
pub const BLUETOOTH_COMPANY_ID_IRDETO: u32 = 2807;
pub const BLUETOOTH_COMPANY_ID_FIRST_DESIGN_SYSTEM_INC: u32 = 2808;
pub const BLUETOOTH_COMPANY_ID_UNISTO_AG: u32 = 2809;
pub const BLUETOOTH_COMPANY_ID_CHENGDU_AMBIT_TECHNOLOGY_CO_LTD: u32 = 2810;
pub const BLUETOOTH_COMPANY_ID_SMT_ELEKTRONIK_GMBH: u32 = 2811;
pub const BLUETOOTH_COMPANY_ID_CEREBRUM_SENSOR_TECHNOLOGIES_INC: u32 = 2812;
pub const BLUETOOTH_COMPANY_ID_WEBER_SENSORS_LLC: u32 = 2813;
pub const BLUETOOTH_COMPANY_ID_EARDA_TECHNOLOGIES_COLTD: u32 = 2814;
pub const BLUETOOTH_COMPANY_ID_FUSEAWARE_LIMITED: u32 = 2815;
pub const BLUETOOTH_COMPANY_ID_FLAIRCOMM_MICROELECTRONICS_INC: u32 = 2816;
pub const BLUETOOTH_COMPANY_ID_RESIDEO_TECHNOLOGIES_INC: u32 = 2817;
pub const BLUETOOTH_COMPANY_ID_IORA_TECHNOLOGY_DEVELOPMENT_LTD_STI: u32 = 2818;
pub const BLUETOOTH_COMPANY_ID_PRECISION_TRIATHLON_SYSTEMS_LIMITED: u32 = 2819;
pub const BLUETOOTH_COMPANY_ID_I_PERCUT: u32 = 2820;
pub const BLUETOOTH_COMPANY_ID_MARQUARDT_GMBH: u32 = 2821;
pub const BLUETOOTH_COMPANY_ID_FAZUA_GMBH: u32 = 2822;
pub const BLUETOOTH_COMPANY_ID_WORKAROUND_GMBH: u32 = 2823;
pub const BLUETOOTH_COMPANY_ID_SHENZHEN_QIANFENYI_INTELLIGENT_TECHNOLOGY_CO_LTD: u32 = 2824;
pub const BLUETOOTH_COMPANY_ID_SOONISYS: u32 = 2825;
pub const BLUETOOTH_COMPANY_ID_BELUN_TECHNOLOGY_COMPANY_LIMITED: u32 = 2826;
pub const BLUETOOTH_COMPANY_ID_SANISTAAL_A_S: u32 = 2827;
pub const BLUETOOTH_COMPANY_ID_BLUPEAK: u32 = 2828;
pub const BLUETOOTH_COMPANY_ID_SANYO_DENKO_COLTD: u32 = 2829;
pub const BLUETOOTH_COMPANY_ID_HONDA_LOCK_MFG_COLTD: u32 = 2830;
pub const BLUETOOTH_COMPANY_ID_BEA_SA: u32 = 2831;
pub const BLUETOOTH_COMPANY_ID_ALFA_LAVAL_CORPORATE_AB: u32 = 2832;
pub const BLUETOOTH_COMPANY_ID_THERMOWORKS_INC: u32 = 2833;
pub const BLUETOOTH_COMPANY_ID_TOUGHBUILT_INDUSTRIES_LLC: u32 = 2834;
pub const BLUETOOTH_COMPANY_ID_IOTOOLS: u32 = 2835;
pub const BLUETOOTH_COMPANY_ID_OLUMEE: u32 = 2836;
pub const BLUETOOTH_COMPANY_ID_NAOS_JAPAN_KK: u32 = 2837;
pub const BLUETOOTH_COMPANY_ID_GUARD_RFID_SOLUTIONS_INC: u32 = 2838;
pub const BLUETOOTH_COMPANY_ID_SIG_SAUER_INC: u32 = 2839;
pub const BLUETOOTH_COMPANY_ID_DECATHLON_SE: u32 = 2840;
pub const BLUETOOTH_COMPANY_ID_WBS_PROJECT_H_PTY_LTD: u32 = 2841;
pub const BLUETOOTH_COMPANY_ID_ROCA_SANITARIO_SA: u32 = 2842;
pub const BLUETOOTH_COMPANY_ID_ENERPAC_TOOL_GROUP_CORP: u32 = 2843;
pub const BLUETOOTH_COMPANY_ID_NANOLEQ_AG: u32 = 2844;
pub const BLUETOOTH_COMPANY_ID_ACCELERATED_SYSTEMS: u32 = 2845;
pub const BLUETOOTH_COMPANY_ID_PB_INC: u32 = 2846;
pub const BLUETOOTH_COMPANY_ID_BEIJING_ESWIN_COMPUTING_TECHNOLOGY_CO_LTD: u32 = 2847;
pub const BLUETOOTH_COMPANY_ID_TKH_SECURITY_BV: u32 = 2848;
pub const BLUETOOTH_COMPANY_ID_AMS_AG: u32 = 2849;
pub const BLUETOOTH_COMPANY_ID_HYGIENE_IQ_LLC: u32 = 2850;
pub const BLUETOOTH_COMPANY_ID_IRHYTHM_TECHNOLOGIES_INC: u32 = 2851;
pub const BLUETOOTH_COMPANY_ID_CAMBRIDGE_SILICON_RADIO: u32 = 10;
pub const BLUETOOTH_DATA_TYPE_FLAGS: u32 = 1;
pub const BLUETOOTH_DATA_TYPE_INCOMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS: u32 = 2;
pub const BLUETOOTH_DATA_TYPE_COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS: u32 = 3;
pub const BLUETOOTH_DATA_TYPE_INCOMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS: u32 = 4;
pub const BLUETOOTH_DATA_TYPE_COMPLETE_LIST_OF_32_BIT_SERVICE_CLASS_UUIDS: u32 = 5;
pub const BLUETOOTH_DATA_TYPE_INCOMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS: u32 = 6;
pub const BLUETOOTH_DATA_TYPE_COMPLETE_LIST_OF_128_BIT_SERVICE_CLASS_UUIDS: u32 = 7;
pub const BLUETOOTH_DATA_TYPE_SHORTENED_LOCAL_NAME: u32 = 8;
pub const BLUETOOTH_DATA_TYPE_COMPLETE_LOCAL_NAME: u32 = 9;
pub const BLUETOOTH_DATA_TYPE_TX_POWER_LEVEL: u32 = 10;
pub const BLUETOOTH_DATA_TYPE_CLASS_OF_DEVICE: u32 = 13;
pub const BLUETOOTH_DATA_TYPE_SIMPLE_PAIRING_HASH_C: u32 = 14;
pub const BLUETOOTH_DATA_TYPE_SIMPLE_PAIRING_HASH_C_192: u32 = 14;
pub const BLUETOOTH_DATA_TYPE_SIMPLE_PAIRING_RANDOMIZER_R: u32 = 15;
pub const BLUETOOTH_DATA_TYPE_SIMPLE_PAIRING_RANDOMIZER_R_192: u32 = 15;
pub const BLUETOOTH_DATA_TYPE_DEVICE_ID: u32 = 16;
pub const BLUETOOTH_DATA_TYPE_SECURITY_MANAGER_TK_VALUE: u32 = 16;
pub const BLUETOOTH_DATA_TYPE_SECURITY_MANAGER_OUT_OF_BAND_FLAGS: u32 = 17;
pub const BLUETOOTH_DATA_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE: u32 = 18;
pub const BLUETOOTH_DATA_TYPE_LIST_OF_16_BIT_SERVICE_SOLICITATION_UUIDS: u32 = 20;
pub const BLUETOOTH_DATA_TYPE_LIST_OF_128_BIT_SERVICE_SOLICITATION_UUIDS: u32 = 21;
pub const BLUETOOTH_DATA_TYPE_SERVICE_DATA: u32 = 22;
pub const BLUETOOTH_DATA_TYPE_SERVICE_DATA_16_BIT_UUID: u32 = 22;
pub const BLUETOOTH_DATA_TYPE_PUBLIC_TARGET_ADDRESS: u32 = 23;
pub const BLUETOOTH_DATA_TYPE_RANDOM_TARGET_ADDRESS: u32 = 24;
pub const BLUETOOTH_DATA_TYPE_APPEARANCE: u32 = 25;
pub const BLUETOOTH_DATA_TYPE_ADVERTISING_INTERVAL: u32 = 26;
pub const BLUETOOTH_DATA_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS: u32 = 27;
pub const BLUETOOTH_DATA_TYPE_LE_ROLE: u32 = 28;
pub const BLUETOOTH_DATA_TYPE_SIMPLE_PAIRING_HASH_C_256: u32 = 29;
pub const BLUETOOTH_DATA_TYPE_SIMPLE_PAIRING_RANDOMIZER_R_256: u32 = 30;
pub const BLUETOOTH_DATA_TYPE_LIST_OF_32_BIT_SERVICE_SOLICITATION_UUIDS: u32 = 31;
pub const BLUETOOTH_DATA_TYPE_SERVICE_DATA_32_BIT_UUID: u32 = 32;
pub const BLUETOOTH_DATA_TYPE_SERVICE_DATA_128_BIT_UUID: u32 = 33;
pub const BLUETOOTH_DATA_TYPE_LE_SECURE_CONNECTIONS_CONFIRMATION_VALUE: u32 = 34;
pub const BLUETOOTH_DATA_TYPE_LE_SECURE_CONNECTIONS_RANDOM_VALUE: u32 = 35;
pub const BLUETOOTH_DATA_TYPE_URI: u32 = 36;
pub const BLUETOOTH_DATA_TYPE_INDOOR_POSITIONING: u32 = 37;
pub const BLUETOOTH_DATA_TYPE_TRANSPORT_DISCOVERY_DATA: u32 = 38;
pub const BLUETOOTH_DATA_TYPE_LE_SUPPORTED_FEATURES: u32 = 39;
pub const BLUETOOTH_DATA_TYPE_CHANNEL_MAP_UPDATE_INDICATION: u32 = 40;
pub const BLUETOOTH_DATA_TYPE_PB_ADV: u32 = 41;
pub const BLUETOOTH_DATA_TYPE_MESH_MESSAGE: u32 = 42;
pub const BLUETOOTH_DATA_TYPE_MESH_BEACON: u32 = 43;
pub const BLUETOOTH_DATA_TYPE_3D_INFORMATION_DATA: u32 = 61;
pub const BLUETOOTH_DATA_TYPE_MANUFACTURER_SPECIFIC_DATA: u32 = 255;
pub const ORG_BLUETOOTH_ATTRIBUTE_GATT_CHARACTERISTIC_DECLARATION: u32 = 10243;
pub const ORG_BLUETOOTH_ATTRIBUTE_GATT_INCLUDE_DECLARATION: u32 = 10242;
pub const ORG_BLUETOOTH_ATTRIBUTE_GATT_PRIMARY_SERVICE_DECLARATION: u32 = 10240;
pub const ORG_BLUETOOTH_ATTRIBUTE_GATT_SECONDARY_SERVICE_DECLARATION: u32 = 10241;
pub const ORG_BLUETOOTH_SERVICE_ALERT_NOTIFICATION: u32 = 6161;
pub const ORG_BLUETOOTH_SERVICE_AUTOMATION_IO: u32 = 6165;
pub const ORG_BLUETOOTH_SERVICE_BATTERY_SERVICE: u32 = 6159;
pub const ORG_BLUETOOTH_SERVICE_BLOOD_PRESSURE: u32 = 6160;
pub const ORG_BLUETOOTH_SERVICE_BODY_COMPOSITION: u32 = 6171;
pub const ORG_BLUETOOTH_SERVICE_BOND_MANAGEMENT: u32 = 6174;
pub const ORG_BLUETOOTH_SERVICE_CONTINUOUS_GLUCOSE_MONITORING: u32 = 6175;
pub const ORG_BLUETOOTH_SERVICE_CURRENT_TIME: u32 = 6149;
pub const ORG_BLUETOOTH_SERVICE_CYCLING_POWER: u32 = 6168;
pub const ORG_BLUETOOTH_SERVICE_CYCLING_SPEED_AND_CADENCE: u32 = 6166;
pub const ORG_BLUETOOTH_SERVICE_DEVICE_INFORMATION: u32 = 6154;
pub const ORG_BLUETOOTH_SERVICE_ENVIRONMENTAL_SENSING: u32 = 6170;
pub const ORG_BLUETOOTH_SERVICE_FITNESS_MACHINE: u32 = 6182;
pub const ORG_BLUETOOTH_SERVICE_GENERIC_ACCESS: u32 = 6144;
pub const ORG_BLUETOOTH_SERVICE_GENERIC_ATTRIBUTE: u32 = 6145;
pub const ORG_BLUETOOTH_SERVICE_GLUCOSE: u32 = 6152;
pub const ORG_BLUETOOTH_SERVICE_HEALTH_THERMOMETER: u32 = 6153;
pub const ORG_BLUETOOTH_SERVICE_HEART_RATE: u32 = 6157;
pub const ORG_BLUETOOTH_SERVICE_HTTP_PROXY: u32 = 6179;
pub const ORG_BLUETOOTH_SERVICE_HUMAN_INTERFACE_DEVICE: u32 = 6162;
pub const ORG_BLUETOOTH_SERVICE_IMMEDIATE_ALERT: u32 = 6146;
pub const ORG_BLUETOOTH_SERVICE_INDOOR_POSITIONING: u32 = 6177;
pub const ORG_BLUETOOTH_SERVICE_INSULIN_DELIVERY: u32 = 6202;
pub const ORG_BLUETOOTH_SERVICE_INTERNET_PROTOCOL_SUPPORT: u32 = 6176;
pub const ORG_BLUETOOTH_SERVICE_LINK_LOSS: u32 = 6147;
pub const ORG_BLUETOOTH_SERVICE_LOCATION_AND_NAVIGATION: u32 = 6169;
pub const ORG_BLUETOOTH_SERVICE_MESH_PROVISIONING: u32 = 6183;
pub const ORG_BLUETOOTH_SERVICE_MESH_PROXY: u32 = 6184;
pub const ORG_BLUETOOTH_SERVICE_NEXT_DST_CHANGE: u32 = 6151;
pub const ORG_BLUETOOTH_SERVICE_OBJECT_TRANSFER: u32 = 6181;
pub const ORG_BLUETOOTH_SERVICE_PHONE_ALERT_STATUS: u32 = 6158;
pub const ORG_BLUETOOTH_SERVICE_PULSE_OXIMETER: u32 = 6178;
pub const ORG_BLUETOOTH_SERVICE_RECONNECTION_CONFIGURATION: u32 = 6185;
pub const ORG_BLUETOOTH_SERVICE_REFERENCE_TIME_UPDATE: u32 = 6150;
pub const ORG_BLUETOOTH_SERVICE_RUNNING_SPEED_AND_CADENCE: u32 = 6164;
pub const ORG_BLUETOOTH_SERVICE_SCAN_PARAMETERS: u32 = 6163;
pub const ORG_BLUETOOTH_SERVICE_TRANSPORT_DISCOVERY: u32 = 6180;
pub const ORG_BLUETOOTH_SERVICE_TX_POWER: u32 = 6148;
pub const ORG_BLUETOOTH_SERVICE_USER_DATA: u32 = 6172;
pub const ORG_BLUETOOTH_SERVICE_WEIGHT_SCALE: u32 = 6173;
pub const ORG_BLUETOOTH_SERVICE_AUDIO_INPUT_CONTROL: u32 = 6211;
pub const ORG_BLUETOOTH_SERVICE_AUDIO_STREAM_CONTROL_SERVICE: u32 = 6222;
pub const ORG_BLUETOOTH_SERVICE_BASIC_AUDIO_ANNOUNCEMENT_SERVICE: u32 = 6225;
pub const ORG_BLUETOOTH_SERVICE_BINARY_SENSOR: u32 = 6203;
pub const ORG_BLUETOOTH_SERVICE_BROADCAST_AUDIO_ANNOUNCEMENT_SERVICE: u32 = 6226;
pub const ORG_BLUETOOTH_SERVICE_BROADCAST_AUDIO_SCAN_SERVICE: u32 = 6223;
pub const ORG_BLUETOOTH_SERVICE_CONSTANT_TONE_EXTENSION: u32 = 6218;
pub const ORG_BLUETOOTH_SERVICE_COORDINATED_SET_IDENTIFICATION_SERVICE: u32 = 6214;
pub const ORG_BLUETOOTH_SERVICE_DEVICE_TIME: u32 = 6215;
pub const ORG_BLUETOOTH_SERVICE_EMERGENCY_CONFIGURATION: u32 = 6204;
pub const ORG_BLUETOOTH_SERVICE_GENERIC_MEDIA_CONTROL_SERVICE: u32 = 6217;
pub const ORG_BLUETOOTH_SERVICE_GENERIC_TELEPHONE_BEARER_SERVICE: u32 = 6220;
pub const ORG_BLUETOOTH_SERVICE_MEDIA_CONTROL_SERVICE: u32 = 6216;
pub const ORG_BLUETOOTH_SERVICE_MICROPHONE_CONTROL: u32 = 6221;
pub const ORG_BLUETOOTH_SERVICE_PHYSICAL_ACTIVITY_MONITOR: u32 = 6206;
pub const ORG_BLUETOOTH_SERVICE_PUBLISHED_AUDIO_CAPABILITIES_SERVICE: u32 = 6224;
pub const ORG_BLUETOOTH_SERVICE_TELEPHONE_BEARER_SERVICE: u32 = 6219;
pub const ORG_BLUETOOTH_SERVICE_VOLUME_CONTROL: u32 = 6212;
pub const ORG_BLUETOOTH_SERVICE_VOLUME_OFFSET_CONTROL: u32 = 6213;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AEROBIC_HEART_RATE_LOWER_LIMIT: u32 = 10878;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AEROBIC_HEART_RATE_UPPER_LIMIT: u32 = 10884;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AEROBIC_THRESHOLD: u32 = 10879;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AGE: u32 = 10880;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AGGREGATE: u32 = 10842;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ALERT_CATEGORY_ID: u32 = 10819;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ALERT_CATEGORY_ID_BIT_MASK: u32 = 10818;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ALERT_LEVEL: u32 = 10758;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ALERT_NOTIFICATION_CONTROL_POINT: u32 = 10820;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ALERT_STATUS: u32 = 10815;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ALTITUDE: u32 = 10931;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ANAEROBIC_HEART_RATE_LOWER_LIMIT: u32 = 10881;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ANAEROBIC_HEART_RATE_UPPER_LIMIT: u32 = 10882;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ANAEROBIC_THRESHOLD: u32 = 10883;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ANALOG: u32 = 10840;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ANALOG_OUTPUT: u32 = 10841;
pub const ORG_BLUETOOTH_CHARACTERISTIC_APPARENT_WIND_DIRECTION: u32 = 10867;
pub const ORG_BLUETOOTH_CHARACTERISTIC_APPARENT_WIND_SPEED: u32 = 10866;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BAROMETRIC_PRESSURE_TREND: u32 = 10915;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BATTERY_LEVEL: u32 = 10777;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BATTERY_LEVEL_STATE: u32 = 10779;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BATTERY_POWER_STATE: u32 = 10778;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BLOOD_PRESSURE_FEATURE: u32 = 10825;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BLOOD_PRESSURE_MEASUREMENT: u32 = 10805;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BODY_COMPOSITION_FEATURE: u32 = 10907;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BODY_COMPOSITION_MEASUREMENT: u32 = 10908;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BODY_SENSOR_LOCATION: u32 = 10808;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BOND_MANAGEMENT_CONTROL_POINT: u32 = 10916;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BOND_MANAGEMENT_FEATURE: u32 = 10917;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BOOT_KEYBOARD_INPUT_REPORT: u32 = 10786;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BOOT_KEYBOARD_OUTPUT_REPORT: u32 = 10802;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BOOT_MOUSE_INPUT_REPORT: u32 = 10803;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CGM_FEATURE: u32 = 10920;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CGM_MEASUREMENT: u32 = 10919;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CGM_SESSION_RUN_TIME: u32 = 10923;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CGM_SESSION_START_TIME: u32 = 10922;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CGM_SPECIFIC_OPS_CONTROL_POINT: u32 = 10924;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CGM_STATUS: u32 = 10921;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CROSS_TRAINER_DATA: u32 = 10958;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CSC_FEATURE: u32 = 10844;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CSC_MEASUREMENT: u32 = 10843;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CURRENT_TIME: u32 = 10795;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CYCLING_POWER_CONTROL_POINT: u32 = 10854;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CYCLING_POWER_FEATURE: u32 = 10853;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CYCLING_POWER_MEASUREMENT: u32 = 10851;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CYCLING_POWER_VECTOR: u32 = 10852;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DATABASE_CHANGE_INCREMENT: u32 = 10905;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DATE_OF_BIRTH: u32 = 10885;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DATE_OF_THRESHOLD_ASSESSMENT: u32 = 10886;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DATE_TIME: u32 = 10760;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DATE_UTC: u32 = 10989;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DAY_DATE_TIME: u32 = 10762;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DAY_OF_WEEK: u32 = 10761;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DESCRIPTOR_VALUE_CHANGED: u32 = 10877;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DEW_POINT: u32 = 10875;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DIGITAL: u32 = 10838;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DIGITAL_OUTPUT: u32 = 10839;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DST_OFFSET: u32 = 10765;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ELEVATION: u32 = 10860;
pub const ORG_BLUETOOTH_CHARACTERISTIC_EMAIL_ADDRESS: u32 = 10887;
pub const ORG_BLUETOOTH_CHARACTERISTIC_EXACT_TIME_100: u32 = 10763;
pub const ORG_BLUETOOTH_CHARACTERISTIC_EXACT_TIME_256: u32 = 10764;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FAT_BURN_HEART_RATE_LOWER_LIMIT: u32 = 10888;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FAT_BURN_HEART_RATE_UPPER_LIMIT: u32 = 10889;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FIRMWARE_REVISION_STRING: u32 = 10790;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FIRST_NAME: u32 = 10890;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FITNESS_MACHINE_CONTROL_POINT: u32 = 10969;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FITNESS_MACHINE_FEATURE: u32 = 10956;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FITNESS_MACHINE_STATUS: u32 = 10970;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FIVE_ZONE_HEART_RATE_LIMITS: u32 = 10891;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FLOOR_NUMBER: u32 = 10930;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAP_APPEARANCE: u32 = 10753;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAP_CENTRAL_ADDRESS_RESOLUTION: u32 = 10918;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAP_DEVICE_NAME: u32 = 10752;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAP_PERIPHERAL_PREFERRED_CONNECTION_PARAMETERS: u32 = 10756;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAP_PERIPHERAL_PRIVACY_FLAG: u32 = 10754;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAP_RECONNECTION_ADDRESS: u32 = 10755;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GATT_SERVICE_CHANGED: u32 = 10757;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GENDER: u32 = 10892;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GLUCOSE_FEATURE: u32 = 10833;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GLUCOSE_MEASUREMENT: u32 = 10776;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GLUCOSE_MEASUREMENT_CONTEXT: u32 = 10804;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GUST_FACTOR: u32 = 10868;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HARDWARE_REVISION_STRING: u32 = 10791;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HEART_RATE_CONTROL_POINT: u32 = 10809;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HEART_RATE_MAX: u32 = 10893;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HEART_RATE_MEASUREMENT: u32 = 10807;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HEAT_INDEX: u32 = 10874;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HEIGHT: u32 = 10894;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HID_CONTROL_POINT: u32 = 10828;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HID_INFORMATION: u32 = 10826;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HIP_CIRCUMFERENCE: u32 = 10895;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HTTP_CONTROL_POINT: u32 = 10938;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HTTP_ENTITY_BODY: u32 = 10937;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HTTP_HEADERS: u32 = 10935;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HTTP_STATUS_CODE: u32 = 10936;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HTTPS_SECURITY: u32 = 10939;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HUMIDITY: u32 = 10863;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_ANNUNCIATION_STATUS: u32 = 11042;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_COMMAND_CONTROL_POINT: u32 = 11045;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_COMMAND_DATA: u32 = 11046;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_FEATURES: u32 = 11043;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_HISTORY_DATA: u32 = 11048;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_RECORD_ACCESS_CONTROL_POINT: u32 = 11047;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_STATUS: u32 = 11041;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_STATUS_CHANGED: u32 = 11040;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IDD_STATUS_READER_CONTROL_POINT: u32 = 11044;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST: u32 =
    10794;
pub const ORG_BLUETOOTH_CHARACTERISTIC_INDOOR_BIKE_DATA: u32 = 10962;
pub const ORG_BLUETOOTH_CHARACTERISTIC_INDOOR_POSITIONING_CONFIGURATION: u32 = 10925;
pub const ORG_BLUETOOTH_CHARACTERISTIC_INTERMEDIATE_CUFF_PRESSURE: u32 = 10806;
pub const ORG_BLUETOOTH_CHARACTERISTIC_INTERMEDIATE_TEMPERATURE: u32 = 10782;
pub const ORG_BLUETOOTH_CHARACTERISTIC_IRRADIANCE: u32 = 10871;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LANGUAGE: u32 = 10914;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LAST_NAME: u32 = 10896;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LATITUDE: u32 = 10926;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LN_CONTROL_POINT: u32 = 10859;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LN_FEATURE: u32 = 10858;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LOCAL_EAST_COORDINATE: u32 = 10929;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LOCAL_NORTH_COORDINATE: u32 = 10928;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LOCAL_TIME_INFORMATION: u32 = 10767;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LOCATION_AND_SPEED: u32 = 10855;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LOCATION_NAME: u32 = 10933;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LONGITUDE: u32 = 10927;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MAGNETIC_DECLINATION: u32 = 10796;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MAGNETIC_FLUX_DENSITY_2D: u32 = 10912;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MAGNETIC_FLUX_DENSITY_3D: u32 = 10913;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MANUFACTURER_NAME_STRING: u32 = 10793;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MAXIMUM_RECOMMENDED_HEART_RATE: u32 = 10897;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEASUREMENT_INTERVAL: u32 = 10785;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MODEL_NUMBER_STRING: u32 = 10788;
pub const ORG_BLUETOOTH_CHARACTERISTIC_NAVIGATION: u32 = 10856;
pub const ORG_BLUETOOTH_CHARACTERISTIC_NETWORK_AVAILABILITY: u32 = 10814;
pub const ORG_BLUETOOTH_CHARACTERISTIC_NEW_ALERT: u32 = 10822;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_ACTION_CONTROL_POINT: u32 = 10949;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_CHANGED: u32 = 10952;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_FIRST_CREATED: u32 = 10945;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_ID: u32 = 10947;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_LAST_MODIFIED: u32 = 10946;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_LIST_CONTROL_POINT: u32 = 10950;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_LIST_FILTER: u32 = 10951;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_NAME: u32 = 10942;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_PROPERTIES: u32 = 10948;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_SIZE: u32 = 10944;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OBJECT_TYPE: u32 = 10943;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OTS_FEATURE: u32 = 10941;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PLX_CONTINUOUS_MEASUREMENT: u32 = 10847;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PLX_FEATURES: u32 = 10848;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PLX_SPOT_CHECK_MEASUREMENT: u32 = 10846;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PNP_ID: u32 = 10832;
pub const ORG_BLUETOOTH_CHARACTERISTIC_POLLEN_CONCENTRATION: u32 = 10869;
pub const ORG_BLUETOOTH_CHARACTERISTIC_POSITION_2D: u32 = 10799;
pub const ORG_BLUETOOTH_CHARACTERISTIC_POSITION_3D: u32 = 10800;
pub const ORG_BLUETOOTH_CHARACTERISTIC_POSITION_QUALITY: u32 = 10857;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PRESSURE: u32 = 10861;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PROTOCOL_MODE: u32 = 10830;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PULSE_OXIMETRY_CONTROL_POINT: u32 = 10850;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RAINFALL: u32 = 10872;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RC_FEATURE: u32 = 11037;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RC_SETTINGS: u32 = 11038;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RECONNECTION_CONFIGURATION_CONTROL_POINT: u32 = 11039;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RECORD_ACCESS_CONTROL_POINT: u32 = 10834;
pub const ORG_BLUETOOTH_CHARACTERISTIC_REFERENCE_TIME_INFORMATION: u32 = 10772;
pub const ORG_BLUETOOTH_CHARACTERISTIC_REMOVABLE: u32 = 10810;
pub const ORG_BLUETOOTH_CHARACTERISTIC_REPORT: u32 = 10829;
pub const ORG_BLUETOOTH_CHARACTERISTIC_REPORT_MAP: u32 = 10827;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RESOLVABLE_PRIVATE_ADDRESS_ONLY: u32 = 10953;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RESTING_HEART_RATE: u32 = 10898;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RINGER_CONTROL_POINT: u32 = 10816;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RINGER_SETTING: u32 = 10817;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ROWER_DATA: u32 = 10961;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RSC_FEATURE: u32 = 10836;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RSC_MEASUREMENT: u32 = 10835;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SC_CONTROL_POINT: u32 = 10837;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SCAN_INTERVAL_WINDOW: u32 = 10831;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SCAN_REFRESH: u32 = 10801;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SCIENTIFIC_TEMPERATURE_CELSIUS: u32 = 10812;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SECONDARY_TIME_ZONE: u32 = 10768;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SENSOR_LOCATION: u32 = 10845;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SERIAL_NUMBER_STRING: u32 = 10789;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SERVICE_REQUIRED: u32 = 10811;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SOFTWARE_REVISION_STRING: u32 = 10792;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SPORT_TYPE_FOR_AEROBIC_AND_ANAEROBIC_THRESHOLDS: u32 = 10899;
pub const ORG_BLUETOOTH_CHARACTERISTIC_STAIR_CLIMBER_DATA: u32 = 10960;
pub const ORG_BLUETOOTH_CHARACTERISTIC_STEP_CLIMBER_DATA: u32 = 10959;
pub const ORG_BLUETOOTH_CHARACTERISTIC_STRING: u32 = 10813;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_HEART_RATE_RANGE: u32 = 10967;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_INCLINATION_RANGE: u32 = 10965;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_NEW_ALERT_CATEGORY: u32 = 10823;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_POWER_RANGE: u32 = 10968;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_RESISTANCE_LEVEL_RANGE: u32 = 10966;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_SPEED_RANGE: u32 = 10964;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_UNREAD_ALERT_CATEGORY: u32 = 10824;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SYSTEM_ID: u32 = 10787;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TDS_CONTROL_POINT: u32 = 10940;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TEMPERATURE: u32 = 10862;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TEMPERATURE_CELSIUS: u32 = 10783;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TEMPERATURE_FAHRENHEIT: u32 = 10784;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TEMPERATURE_MEASUREMENT: u32 = 10780;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TEMPERATURE_TYPE: u32 = 10781;
pub const ORG_BLUETOOTH_CHARACTERISTIC_THREE_ZONE_HEART_RATE_LIMITS: u32 = 10900;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_ACCURACY: u32 = 10770;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_BROADCAST: u32 = 10773;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_SOURCE: u32 = 10771;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_UPDATE_CONTROL_POINT: u32 = 10774;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_UPDATE_STATE: u32 = 10775;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_WITH_DST: u32 = 10769;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_ZONE: u32 = 10766;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRAINING_STATUS: u32 = 10963;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TREADMILL_DATA: u32 = 10957;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRUE_WIND_DIRECTION: u32 = 10865;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRUE_WIND_SPEED: u32 = 10864;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TWO_ZONE_HEART_RATE_LIMIT: u32 = 10901;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TX_POWER_LEVEL: u32 = 10759;
pub const ORG_BLUETOOTH_CHARACTERISTIC_UNCERTAINTY: u32 = 10932;
pub const ORG_BLUETOOTH_CHARACTERISTIC_UNREAD_ALERT_STATUS: u32 = 10821;
pub const ORG_BLUETOOTH_CHARACTERISTIC_URI: u32 = 10934;
pub const ORG_BLUETOOTH_CHARACTERISTIC_USER_CONTROL_POINT: u32 = 10911;
pub const ORG_BLUETOOTH_CHARACTERISTIC_USER_INDEX: u32 = 10906;
pub const ORG_BLUETOOTH_CHARACTERISTIC_UV_INDEX: u32 = 10870;
pub const ORG_BLUETOOTH_CHARACTERISTIC_VO2_MAX: u32 = 10902;
pub const ORG_BLUETOOTH_CHARACTERISTIC_WAIST_CIRCUMFERENCE: u32 = 10903;
pub const ORG_BLUETOOTH_CHARACTERISTIC_WEIGHT: u32 = 10904;
pub const ORG_BLUETOOTH_CHARACTERISTIC_WEIGHT_MEASUREMENT: u32 = 10909;
pub const ORG_BLUETOOTH_CHARACTERISTIC_WEIGHT_SCALE_FEATURE: u32 = 10910;
pub const ORG_BLUETOOTH_CHARACTERISTIC_WIND_CHILL: u32 = 10873;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CLIENT_SUPPORTED_FEATURES: u32 = 11049;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DATABASE_HASH: u32 = 11050;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BSS_CONTROL_POINT: u32 = 11051;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BSS_RESPONSE: u32 = 11052;
pub const ORG_BLUETOOTH_CHARACTERISTIC_EMERGENCY_ID: u32 = 11053;
pub const ORG_BLUETOOTH_CHARACTERISTIC_EMERGENCY_TEXT: u32 = 11054;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ENHANCED_BLOOD_PRESSURE_MEASUREMENT: u32 = 11060;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ENHANCED_INTERMEDIATE_CUFF_PRESSURE: u32 = 11061;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BLOOD_PRESSURE_RECORD: u32 = 11062;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BR_EDR_HANDOVER_DATA: u32 = 11064;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BLUETOOTH_SIG_DATA: u32 = 11065;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SERVER_SUPPORTED_FEATURES: u32 = 11066;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PHYSICAL_ACTIVITY_MONITOR_FEATURES: u32 = 11067;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GENERAL_ACTIVITY_INSTANTANEOUS_DATA: u32 = 11068;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GENERAL_ACTIVITY_SUMMARY_DATA: u32 = 11069;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CARDIORESPIRATORY_ACTIVITY_INSTANTANEOUS_DATA: u32 = 11070;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CARDIORESPIRATORY_ACTIVITY_SUMMARY_DATA: u32 = 11071;
pub const ORG_BLUETOOTH_CHARACTERISTIC_STEP_COUNTER_ACTIVITY_SUMMARY_DATA: u32 = 11072;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SLEEP_ACTIVITY_INSTANTANEOUS_DATA: u32 = 11073;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SLEEP_ACTIVITY_SUMMARY_DATA: u32 = 11074;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PHYSICAL_ACTIVITY_MONITOR_CONTROL_POINT: u32 = 11075;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CURRENT_SESSION: u32 = 11076;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SESSION: u32 = 11077;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PREFERRED_UNITS: u32 = 11078;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HIGH_RESOLUTION_HEIGHT: u32 = 11079;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MIDDLE_NAME: u32 = 11080;
pub const ORG_BLUETOOTH_CHARACTERISTIC_STRIDE_LENGTH: u32 = 11081;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HANDEDNESS: u32 = 11082;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DEVICE_WEARING_POSITION: u32 = 11083;
pub const ORG_BLUETOOTH_CHARACTERISTIC_FOUR_ZONE_HEART_RATE_LIMITS: u32 = 11084;
pub const ORG_BLUETOOTH_CHARACTERISTIC_HIGH_INTENSITY_EXERCISE_THRESHOLD: u32 = 11085;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ACTIVITY_GOAL: u32 = 11086;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SEDENTARY_INTERVAL_NOTIFICATION: u32 = 11087;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CALORIC_INTAKE: u32 = 11088;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_INPUT_STATE: u32 = 11127;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GAIN_SETTINGS_ATTRIBUTE: u32 = 11128;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_INPUT_TYPE: u32 = 11129;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_INPUT_STATUS: u32 = 11130;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_INPUT_CONTROL_POINT: u32 = 11131;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_INPUT_DESCRIPTION: u32 = 11132;
pub const ORG_BLUETOOTH_CHARACTERISTIC_VOLUME_STATE: u32 = 11133;
pub const ORG_BLUETOOTH_CHARACTERISTIC_VOLUME_CONTROL_POINT: u32 = 11134;
pub const ORG_BLUETOOTH_CHARACTERISTIC_VOLUME_FLAGS: u32 = 11135;
pub const ORG_BLUETOOTH_CHARACTERISTIC_OFFSET_STATE: u32 = 11136;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_LOCATION: u32 = 11137;
pub const ORG_BLUETOOTH_CHARACTERISTIC_VOLUME_OFFSET_CONTROL_POINT: u32 = 11138;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AUDIO_OUTPUT_DESCRIPTION: u32 = 11139;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SET_IDENTITY_RESOLVING_KEY_CHARACTERISTIC: u32 = 11140;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SIZE_CHARACTERISTIC: u32 = 11141;
pub const ORG_BLUETOOTH_CHARACTERISTIC_LOCK_CHARACTERISTIC: u32 = 11142;
pub const ORG_BLUETOOTH_CHARACTERISTIC_RANK_CHARACTERISTIC: u32 = 11143;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DEVICE_TIME_FEATURE_: u32 = 11150;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DEVICE_TIME_PARAMETERS: u32 = 11151;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DEVICE_TIME: u32 = 11152;
pub const ORG_BLUETOOTH_CHARACTERISTIC_DEVICE_TIME_CONTROL_POINT: u32 = 11153;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TIME_CHANGE_LOG_DATA: u32 = 11154;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_PLAYER_NAME: u32 = 11155;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_PLAYER_ICON_OBJECT_ID: u32 = 11156;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_PLAYER_ICON_URL: u32 = 11157;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRACK_CHANGED: u32 = 11158;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRACK_TITLE: u32 = 11159;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRACK_DURATION: u32 = 11160;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRACK_POSITION: u32 = 11161;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PLAYBACK_SPEED: u32 = 11162;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SEEKING_SPEED: u32 = 11163;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CURRENT_TRACK_SEGMENTS_OBJECT_ID: u32 = 11164;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CURRENT_TRACK_OBJECT_ID: u32 = 11165;
pub const ORG_BLUETOOTH_CHARACTERISTIC_NEXT_TRACK_OBJECT_ID: u32 = 11166;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PARENT_GROUP_OBJECT_ID: u32 = 11167;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CURRENT_GROUP_OBJECT_ID: u32 = 11168;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PLAYING_ORDER: u32 = 11169;
pub const ORG_BLUETOOTH_CHARACTERISTIC_PLAYING_ORDERS_SUPPORTED: u32 = 11170;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_STATE: u32 = 11171;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_CONTROL_POINT: u32 = 11172;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_CONTROL_POINT_OPCODES_SUPPORTED: u32 = 11173;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SEARCH_RESULTS_OBJECT_ID: u32 = 11174;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SEARCH_CONTROL_POINT: u32 = 11175;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MEDIA_PLAYER_ICON_OBJECT_TYPE: u32 = 11177;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRACK_SEGMENTS_OBJECT_TYPE: u32 = 11178;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TRACK_OBJECT_TYPE: u32 = 11179;
pub const ORG_BLUETOOTH_CHARACTERISTIC_GROUP_OBJECT_TYPE: u32 = 11180;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CONSTANT_TONE_EXTENSION_ENABLE: u32 = 11181;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ADVERTISING_CONSTANT_TONE_EXTENSION_MINIMUM_LENGTH: u32 =
    11182;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ADVERTISING_CONSTANT_TONE_EXTENSION_MINIMUM_TRANSMIT_COUNT : u32 = 11183 ;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ADVERTISING_CONSTANT_TONE_EXTENSION_TRANSMIT_DURATION: u32 =
    11184;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ADVERTISING_CONSTANT_TONE_EXTENSION_INTERVAL: u32 = 11185;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ADVERTISING_CONSTANT_TONE_EXTENSION_PHY: u32 = 11186;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_PROVIDER_NAME: u32 = 11187;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_UCI: u32 = 11188;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_TECHNOLOGY: u32 = 11189;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_URI_SCHEMES_SUPPORTED_LIST: u32 = 11190;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_SIGNAL_STRENGTH: u32 = 11191;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_SIGNAL_STRENGTH_REPORTING_INTERVAL: u32 = 11192;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BEARER_LIST_CURRENT_CALLS: u32 = 11193;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CONTENT_CONTROL_ID: u32 = 11194;
pub const ORG_BLUETOOTH_CHARACTERISTIC_STATUS_FLAGS: u32 = 11195;
pub const ORG_BLUETOOTH_CHARACTERISTIC_INCOMING_CALL_TARGET_BEARER_URI: u32 = 11196;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CALL_STATE: u32 = 11197;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CALL_CONTROL_POINT: u32 = 11198;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CALL_CONTROL_POINT_OPTIONAL_OPCODES: u32 = 11199;
pub const ORG_BLUETOOTH_CHARACTERISTIC_TERMINATION_REASON: u32 = 11200;
pub const ORG_BLUETOOTH_CHARACTERISTIC_INCOMING_CALL: u32 = 11201;
pub const ORG_BLUETOOTH_CHARACTERISTIC_CALL_FRIENDLY_NAME: u32 = 11202;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MUTE: u32 = 11203;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SINK_ASE: u32 = 11204;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SOURCE_ASE: u32 = 11205;
pub const ORG_BLUETOOTH_CHARACTERISTIC_ASE_CONTROL_POINT: u32 = 11206;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BROADCAST_AUDIO_SCAN_CONTROL_POINT: u32 = 11207;
pub const ORG_BLUETOOTH_CHARACTERISTIC_BROADCAST_RECEIVE_STATE: u32 = 11208;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SINK_PAC: u32 = 11209;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SINK_AUDIO_LOCATIONS: u32 = 11210;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SOURCE_PAC: u32 = 11211;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SOURCE_AUDIO_LOCATIONS: u32 = 11212;
pub const ORG_BLUETOOTH_CHARACTERISTIC_AVAILABLE_AUDIO_CONTEXTS: u32 = 11213;
pub const ORG_BLUETOOTH_CHARACTERISTIC_SUPPORTED_AUDIO_CONTEXTS: u32 = 11214;
pub const ORG_BLUETOOTH_DESCRIPTOR_ES_CONFIGURATION: u32 = 10507;
pub const ORG_BLUETOOTH_DESCRIPTOR_ES_MEASUREMENT: u32 = 10508;
pub const ORG_BLUETOOTH_DESCRIPTOR_ES_TRIGGER_SETTING: u32 = 10509;
pub const ORG_BLUETOOTH_DESCRIPTOR_EXTERNAL_REPORT_REFERENCE: u32 = 10503;
pub const ORG_BLUETOOTH_DESCRIPTOR_GATT_CHARACTERISTIC_AGGREGATE_FORMAT: u32 = 10501;
pub const ORG_BLUETOOTH_DESCRIPTOR_GATT_CHARACTERISTIC_EXTENDED_PROPERTIES: u32 = 10496;
pub const ORG_BLUETOOTH_DESCRIPTOR_GATT_CHARACTERISTIC_PRESENTATION_FORMAT: u32 = 10500;
pub const ORG_BLUETOOTH_DESCRIPTOR_GATT_CHARACTERISTIC_USER_DESCRIPTION: u32 = 10497;
pub const ORG_BLUETOOTH_DESCRIPTOR_GATT_CLIENT_CHARACTERISTIC_CONFIGURATION: u32 = 10498;
pub const ORG_BLUETOOTH_DESCRIPTOR_GATT_SERVER_CHARACTERISTIC_CONFIGURATION: u32 = 10499;
pub const ORG_BLUETOOTH_DESCRIPTOR_NUMBER_OF_DIGITALS: u32 = 10505;
pub const ORG_BLUETOOTH_DESCRIPTOR_REPORT_REFERENCE: u32 = 10504;
pub const ORG_BLUETOOTH_DESCRIPTOR_TIME_TRIGGER_SETTING: u32 = 10510;
pub const ORG_BLUETOOTH_DESCRIPTOR_VALID_RANGE: u32 = 10502;
pub const ORG_BLUETOOTH_DESCRIPTOR_VALUE_TRIGGER_SETTING: u32 = 10506;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MESH_PROVISIONING_DATA_IN: u32 = 10971;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MESH_PROVISIONING_DATA_OUT: u32 = 10972;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MESH_PROXY_DATA_IN: u32 = 10973;
pub const ORG_BLUETOOTH_CHARACTERISTIC_MESH_PROXY_DATA_OUT: u32 = 10974;
pub const BLUETOOTH_PROTOCOL_SDP: u32 = 1;
pub const BLUETOOTH_PROTOCOL_UDP: u32 = 2;
pub const BLUETOOTH_PROTOCOL_RFCOMM: u32 = 3;
pub const BLUETOOTH_PROTOCOL_TCP: u32 = 4;
pub const BLUETOOTH_PROTOCOL_TCS_BIN: u32 = 5;
pub const BLUETOOTH_PROTOCOL_TCS_AT: u32 = 6;
pub const BLUETOOTH_PROTOCOL_ATT: u32 = 7;
pub const BLUETOOTH_PROTOCOL_OBEX: u32 = 8;
pub const BLUETOOTH_PROTOCOL_IP: u32 = 9;
pub const BLUETOOTH_PROTOCOL_FTP: u32 = 10;
pub const BLUETOOTH_PROTOCOL_HTTP: u32 = 12;
pub const BLUETOOTH_PROTOCOL_WSP: u32 = 14;
pub const BLUETOOTH_PROTOCOL_BNEP: u32 = 15;
pub const BLUETOOTH_PROTOCOL_UPNP: u32 = 16;
pub const BLUETOOTH_PROTOCOL_HIDP: u32 = 17;
pub const BLUETOOTH_PROTOCOL_HARDCOPY_CONTROL_CHANNEL: u32 = 18;
pub const BLUETOOTH_PROTOCOL_HARDCOPY_DATA_CHANNEL: u32 = 20;
pub const BLUETOOTH_PROTOCOL_HARDCOPY_NOTIFICATION: u32 = 22;
pub const BLUETOOTH_PROTOCOL_AVCTP: u32 = 23;
pub const BLUETOOTH_PROTOCOL_AVDTP: u32 = 25;
pub const BLUETOOTH_PROTOCOL_CMTP: u32 = 27;
pub const BLUETOOTH_PROTOCOL_MCAP_CONTROL_CHANNEL: u32 = 30;
pub const BLUETOOTH_PROTOCOL_MCAP_DATA_CHANNEL: u32 = 31;
pub const BLUETOOTH_PROTOCOL_L2CAP: u32 = 256;
pub const BLUETOOTH_SERVICE_CLASS_SERVICE_DISCOVERY_SERVER: u32 = 4096;
pub const BLUETOOTH_SERVICE_CLASS_BROWSE_GROUP_DESCRIPTOR: u32 = 4097;
pub const BLUETOOTH_SERVICE_CLASS_SERIAL_PORT: u32 = 4353;
pub const BLUETOOTH_SERVICE_CLASS_LAN_ACCESS_USING_PPP: u32 = 4354;
pub const BLUETOOTH_SERVICE_CLASS_DIALUP_NETWORKING: u32 = 4355;
pub const BLUETOOTH_SERVICE_CLASS_IR_MC_SYNC: u32 = 4356;
pub const BLUETOOTH_SERVICE_CLASS_OBEX_OBJECT_PUSH: u32 = 4357;
pub const BLUETOOTH_SERVICE_CLASS_OBEX_FILE_TRANSFER: u32 = 4358;
pub const BLUETOOTH_SERVICE_CLASS_IR_MC_SYNC_COMMAND: u32 = 4359;
pub const BLUETOOTH_SERVICE_CLASS_HEADSET: u32 = 4360;
pub const BLUETOOTH_SERVICE_CLASS_CORDLESS_TELEPHONY: u32 = 4361;
pub const BLUETOOTH_SERVICE_CLASS_AUDIO_SOURCE: u32 = 4362;
pub const BLUETOOTH_SERVICE_CLASS_AUDIO_SINK: u32 = 4363;
pub const BLUETOOTH_SERVICE_CLASS_AV_REMOTE_CONTROL_TARGET: u32 = 4364;
pub const BLUETOOTH_SERVICE_CLASS_ADVANCED_AUDIO_DISTRIBUTION: u32 = 4365;
pub const BLUETOOTH_SERVICE_CLASS_AV_REMOTE_CONTROL: u32 = 4366;
pub const BLUETOOTH_SERVICE_CLASS_AV_REMOTE_CONTROL_CONTROLLER: u32 = 4367;
pub const BLUETOOTH_SERVICE_CLASS_INTERCOM: u32 = 4368;
pub const BLUETOOTH_SERVICE_CLASS_FAX: u32 = 4369;
pub const BLUETOOTH_SERVICE_CLASS_HEADSET_AUDIO_GATEWAY_AG: u32 = 4370;
pub const BLUETOOTH_SERVICE_CLASS_WAP: u32 = 4371;
pub const BLUETOOTH_SERVICE_CLASS_WAP_CLIENT: u32 = 4372;
pub const BLUETOOTH_SERVICE_CLASS_PANU: u32 = 4373;
pub const BLUETOOTH_SERVICE_CLASS_NAP: u32 = 4374;
pub const BLUETOOTH_SERVICE_CLASS_GN: u32 = 4375;
pub const BLUETOOTH_SERVICE_CLASS_DIRECT_PRINTING: u32 = 4376;
pub const BLUETOOTH_SERVICE_CLASS_REFERENCE_PRINTING: u32 = 4377;
pub const BLUETOOTH_SERVICE_CLASS_BASIC_IMAGING_PROFILE: u32 = 4378;
pub const BLUETOOTH_SERVICE_CLASS_IMAGING_RESPONDER: u32 = 4379;
pub const BLUETOOTH_SERVICE_CLASS_IMAGING_AUTOMATIC_ARCHIVE: u32 = 4380;
pub const BLUETOOTH_SERVICE_CLASS_IMAGING_REFERENCED_OBJECTS: u32 = 4381;
pub const BLUETOOTH_SERVICE_CLASS_HANDSFREE: u32 = 4382;
pub const BLUETOOTH_SERVICE_CLASS_HANDSFREE_AUDIO_GATEWAY: u32 = 4383;
pub const BLUETOOTH_SERVICE_CLASS_DIRECT_PRINTING_REFERENCE_OBJECTS_SERVICE: u32 = 4384;
pub const BLUETOOTH_SERVICE_CLASS_REFLECTED_UI: u32 = 4385;
pub const BLUETOOTH_SERVICE_CLASS_BASIC_PRINTING: u32 = 4386;
pub const BLUETOOTH_SERVICE_CLASS_PRINTING_STATUS: u32 = 4387;
pub const BLUETOOTH_SERVICE_CLASS_HUMAN_INTERFACE_DEVICE_SERVICE: u32 = 4388;
pub const BLUETOOTH_SERVICE_CLASS_HARDCOPY_CABLE_REPLACEMENT: u32 = 4389;
pub const BLUETOOTH_SERVICE_CLASS_HCR_PRINT: u32 = 4390;
pub const BLUETOOTH_SERVICE_CLASS_HCR_SCAN: u32 = 4391;
pub const BLUETOOTH_SERVICE_CLASS_COMMON_ISDN_ACCESS: u32 = 4392;
pub const BLUETOOTH_SERVICE_CLASS_SIM_ACCESS: u32 = 4397;
pub const BLUETOOTH_SERVICE_CLASS_PHONEBOOK_ACCESS_PCE: u32 = 4398;
pub const BLUETOOTH_SERVICE_CLASS_PHONEBOOK_ACCESS_PSE: u32 = 4399;
pub const BLUETOOTH_SERVICE_CLASS_PHONEBOOK_ACCESS: u32 = 4400;
pub const BLUETOOTH_SERVICE_CLASS_HEADSET_HS: u32 = 4401;
pub const BLUETOOTH_SERVICE_CLASS_MESSAGE_ACCESS_SERVER: u32 = 4402;
pub const BLUETOOTH_SERVICE_CLASS_MESSAGE_NOTIFICATION_SERVER: u32 = 4403;
pub const BLUETOOTH_SERVICE_CLASS_MESSAGE_ACCESS_PROFILE: u32 = 4404;
pub const BLUETOOTH_SERVICE_CLASS_GNSS: u32 = 4405;
pub const BLUETOOTH_SERVICE_CLASS_GNSS_SERVER: u32 = 4406;
pub const BLUETOOTH_SERVICE_CLASS_3D_DISPLAY: u32 = 4407;
pub const BLUETOOTH_SERVICE_CLASS_3D_GLASSES: u32 = 4408;
pub const BLUETOOTH_SERVICE_CLASS_3D_SYNCHRONIZATION: u32 = 4409;
pub const BLUETOOTH_SERVICE_CLASS_MPS_PROFILE_UUID: u32 = 4410;
pub const BLUETOOTH_SERVICE_CLASS_MPS_SC_UUID: u32 = 4411;
pub const BLUETOOTH_SERVICE_CLASS_CTN_ACCESS_SERVICE: u32 = 4412;
pub const BLUETOOTH_SERVICE_CLASS_CTN_NOTIFICATION_SERVICE: u32 = 4413;
pub const BLUETOOTH_SERVICE_CLASS_CTN_PROFILE: u32 = 4414;
pub const BLUETOOTH_SERVICE_CLASS_PNP_INFORMATION: u32 = 4608;
pub const BLUETOOTH_SERVICE_CLASS_GENERIC_NETWORKING: u32 = 4609;
pub const BLUETOOTH_SERVICE_CLASS_GENERIC_FILE_TRANSFER: u32 = 4610;
pub const BLUETOOTH_SERVICE_CLASS_GENERIC_AUDIO: u32 = 4611;
pub const BLUETOOTH_SERVICE_CLASS_GENERIC_TELEPHONY: u32 = 4612;
pub const BLUETOOTH_SERVICE_CLASS_UPNP_SERVICE: u32 = 4613;
pub const BLUETOOTH_SERVICE_CLASS_UPNP_IP_SERVICE: u32 = 4614;
pub const BLUETOOTH_SERVICE_CLASS_ESDP_UPNP_IP_PAN: u32 = 4864;
pub const BLUETOOTH_SERVICE_CLASS_ESDP_UPNP_IP_LAP: u32 = 4865;
pub const BLUETOOTH_SERVICE_CLASS_ESDP_UPNP_L2CAP: u32 = 4866;
pub const BLUETOOTH_SERVICE_CLASS_VIDEO_SOURCE: u32 = 4867;
pub const BLUETOOTH_SERVICE_CLASS_VIDEO_SINK: u32 = 4868;
pub const BLUETOOTH_SERVICE_CLASS_VIDEO_DISTRIBUTION: u32 = 4869;
pub const BLUETOOTH_SERVICE_CLASS_HDP: u32 = 5120;
pub const BLUETOOTH_SERVICE_CLASS_HDP_SOURCE: u32 = 5121;
pub const BLUETOOTH_SERVICE_CLASS_HDP_SINK: u32 = 5122;
pub const BLUETOOTH_ATTRIBUTE_PUBLIC_BROWSE_ROOT: u32 = 4098;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_FEATURES: u32 = 785;
pub const BLUETOOTH_ATTRIBUTE_GOEP_L2CAP_PSM: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_CAPABILITIES: u32 = 784;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_FUNCTIONS: u32 = 786;
pub const BLUETOOTH_ATTRIBUTE_TOTAL_IMAGING_DATA_CAPACITY: u32 = 787;
pub const BLUETOOTH_ATTRIBUTE_DOCUMENT_FORMATS_SUPPORTED: u32 = 848;
pub const BLUETOOTH_ATTRIBUTE_CHARACTER_REPERTOIRES_SUPPORTED: u32 = 850;
pub const BLUETOOTH_ATTRIBUTE_XHTML_PRINT_IMAGE_FORMATS_SUPPORTED: u32 = 852;
pub const BLUETOOTH_ATTRIBUTE_COLOR_SUPPORTED: u32 = 854;
pub const BLUETOOTH_ATTRIBUTE_1284_ID: u32 = 856;
pub const BLUETOOTH_ATTRIBUTE_PRINTER_NAME: u32 = 858;
pub const BLUETOOTH_ATTRIBUTE_PRINTER_LOCATION: u32 = 860;
pub const BLUETOOTH_ATTRIBUTE_DUPLEX_SUPPORTED: u32 = 862;
pub const BLUETOOTH_ATTRIBUTE_MEDIA_TYPES_SUPPORTED: u32 = 864;
pub const BLUETOOTH_ATTRIBUTE_MAX_MEDIA_WIDTH: u32 = 866;
pub const BLUETOOTH_ATTRIBUTE_MAX_MEDIA_LENGTH: u32 = 868;
pub const BLUETOOTH_ATTRIBUTE_ENHANCED_LAYOUT_SUPPORTED: u32 = 870;
pub const BLUETOOTH_ATTRIBUTE_RUI_FORMATS_SUPPORTED: u32 = 872;
pub const BLUETOOTH_ATTRIBUTE_REFERENCE_PRINTING_RUI_SUPPORTED: u32 = 880;
pub const BLUETOOTH_ATTRIBUTE_DIRECT_PRINTING_RUI_SUPPORTED: u32 = 882;
pub const BLUETOOTH_ATTRIBUTE_REFERENCE_PRINTING_TOP_URL: u32 = 884;
pub const BLUETOOTH_ATTRIBUTE_DIRECT_PRINTING_TOP_URL: u32 = 886;
pub const BLUETOOTH_ATTRIBUTE_PRINTER_ADMIN_RUI_TOP_URL: u32 = 888;
pub const BLUETOOTH_ATTRIBUTE_DEVICE_NAME: u32 = 890;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_RECORD_HANDLE: u32 = 0;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_CLASS_ID_LIST: u32 = 1;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_RECORD_STATE: u32 = 2;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_ID: u32 = 3;
pub const BLUETOOTH_ATTRIBUTE_PROTOCOL_DESCRIPTOR_LIST: u32 = 4;
pub const BLUETOOTH_ATTRIBUTE_BROWSE_GROUP_LIST: u32 = 5;
pub const BLUETOOTH_ATTRIBUTE_LANGUAGE_BASE_ATTRIBUTE_ID_LIST: u32 = 6;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_INFO_TIME_TO_LIVE: u32 = 7;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_AVAILABILITY: u32 = 8;
pub const BLUETOOTH_ATTRIBUTE_BLUETOOTH_PROFILE_DESCRIPTOR_LIST: u32 = 9;
pub const BLUETOOTH_ATTRIBUTE_DOCUMENTATION_URL: u32 = 10;
pub const BLUETOOTH_ATTRIBUTE_CLIENT_EXECUTABLE_URL: u32 = 11;
pub const BLUETOOTH_ATTRIBUTE_ICON_URL: u32 = 12;
pub const BLUETOOTH_ATTRIBUTE_ADDITIONAL_PROTOCOL_DESCRIPTOR_LISTS: u32 = 13;
pub const BLUETOOTH_ATTRIBUTE_VERSION_NUMBER_LIST: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_DATABASE_STATE: u32 = 513;
pub const BLUETOOTH_ATTRIBUTE_SPECIFICATION_ID: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_VENDOR_ID: u32 = 513;
pub const BLUETOOTH_ATTRIBUTE_PRODUCT_ID: u32 = 514;
pub const BLUETOOTH_ATTRIBUTE_VERSION: u32 = 515;
pub const BLUETOOTH_ATTRIBUTE_PRIMARY_RECORD: u32 = 516;
pub const BLUETOOTH_ATTRIBUTE_VENDOR_ID_SOURCE: u32 = 517;
pub const BLUETOOTH_ATTRIBUTE_NETWORK: u32 = 769;
pub const BLUETOOTH_ATTRIBUTE_FRIENDLY_NAME: u32 = 772;
pub const BLUETOOTH_ATTRIBUTE_DEVICE_LOCATION: u32 = 774;
pub const BLUETOOTH_ATTRIBUTE_REMOTE_AUDIO_VOLUME_CONTROL: u32 = 770;
pub const BLUETOOTH_ATTRIBUTE_SUPPORT_FEATURES_LIST: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_DATA_EXCHANGE_SPECIFICATION: u32 = 769;
pub const BLUETOOTH_ATTRIBUTE_MCAP_SUPPORTED_PROCEDURES: u32 = 770;
pub const BLUETOOTH_ATTRIBUTE_HID_DEVICE_RELEASE_NUMBER: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_HID_PARSER_VERSION: u32 = 513;
pub const BLUETOOTH_ATTRIBUTE_HID_DEVICE_SUBCLASS: u32 = 514;
pub const BLUETOOTH_ATTRIBUTE_HID_COUNTRY_CODE: u32 = 515;
pub const BLUETOOTH_ATTRIBUTE_HID_VIRTUAL_CABLE: u32 = 516;
pub const BLUETOOTH_ATTRIBUTE_HID_RECONNECT_INITIATE: u32 = 517;
pub const BLUETOOTH_ATTRIBUTE_HID_DESCRIPTOR_LIST: u32 = 518;
pub const BLUETOOTH_ATTRIBUTE_HIDLANGID_BASE_LIST: u32 = 519;
pub const BLUETOOTH_ATTRIBUTE_HIDSDP_DISABLE: u32 = 520;
pub const BLUETOOTH_ATTRIBUTE_HID_BATTERY_POWER: u32 = 521;
pub const BLUETOOTH_ATTRIBUTE_HID_REMOTE_WAKE: u32 = 522;
pub const BLUETOOTH_ATTRIBUTE_HID_PROFILE_VERSION: u32 = 523;
pub const BLUETOOTH_ATTRIBUTE_HID_SUPERVISION_TIMEOUT: u32 = 524;
pub const BLUETOOTH_ATTRIBUTE_HID_NORMALLY_CONNECTABLE: u32 = 525;
pub const BLUETOOTH_ATTRIBUTE_HID_BOOT_DEVICE: u32 = 526;
pub const BLUETOOTH_ATTRIBUTE_HIDSSR_HOST_MAX_LATENCY: u32 = 527;
pub const BLUETOOTH_ATTRIBUTE_HIDSSR_HOST_MIN_TIMEOUT: u32 = 528;
pub const BLUETOOTH_ATTRIBUTE_MAS_INSTANCE_ID: u32 = 789;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_MESSAGE_TYPES: u32 = 790;
pub const BLUETOOTH_ATTRIBUTE_MAP_SUPPORTED_FEATURES: u32 = 791;
pub const BLUETOOTH_ATTRIBUTE_SERVICE_VERSION: u32 = 768;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_FORMATS_LIST: u32 = 771;
pub const BLUETOOTH_ATTRIBUTE_IP_SUBNET: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_SECURITY_DESCRIPTION: u32 = 778;
pub const BLUETOOTH_ATTRIBUTE_NET_ACCESS_TYPE: u32 = 779;
pub const BLUETOOTH_ATTRIBUTE_MAX_NET_ACCESSRATE: u32 = 780;
pub const BLUETOOTH_ATTRIBUTE_IPV4_SUBNET: u32 = 781;
pub const BLUETOOTH_ATTRIBUTE_IPV6_SUBNET: u32 = 782;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_REPOSITORIES: u32 = 788;
pub const BLUETOOTH_ATTRIBUTE_PBAP_SUPPORTED_FEATURES: u32 = 791;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_DATA_STORES_LIST: u32 = 769;
pub const BLUETOOTH_ATTRIBUTE_MPSD_SCENARIOS: u32 = 512;
pub const BLUETOOTH_ATTRIBUTE_MPMD_SCENARIOS: u32 = 513;
pub const BLUETOOTH_ATTRIBUTE_SUPPORTED_PROFILES_AND_PROTOCOLS: u32 = 514;
pub const BLUETOOTH_ATTRIBUTE_CAS_INSTANCE_ID: u32 = 789;
pub const BLUETOOTH_ATTRIBUTE_CTN_SUPPORTED_FEATURES: u32 = 791;
pub const BLUETOOTH_ATTRIBUTE_GNSS_SUPPORTED_FEATURES: u32 = 512;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const HCI_CON_HANDLE_INVALID: u32 = 65535;
pub const DAEMON_EVENT_PACKET: u32 = 5;
pub const L2CAP_DATA_PACKET: u32 = 6;
pub const RFCOMM_DATA_PACKET: u32 = 7;
pub const ATT_DATA_PACKET: u32 = 8;
pub const SM_DATA_PACKET: u32 = 9;
pub const SDP_CLIENT_PACKET: u32 = 10;
pub const BNEP_DATA_PACKET: u32 = 11;
pub const UCD_DATA_PACKET: u32 = 12;
pub const GOEP_DATA_PACKET: u32 = 13;
pub const PBAP_DATA_PACKET: u32 = 14;
pub const AVRCP_BROWSING_DATA_PACKET: u32 = 15;
pub const MAP_DATA_PACKET: u32 = 16;
pub const PROVISIONING_DATA_PACKET: u32 = 17;
pub const MESH_PROXY_DATA_PACKET: u32 = 17;
pub const MESH_NETWORK_PACKET: u32 = 18;
pub const MESH_BEACON_PACKET: u32 = 19;
pub const LOG_MESSAGE_PACKET: u32 = 252;
pub const OGF_BTSTACK: u32 = 61;
pub const BTSTACK_GET_STATE: u32 = 1;
pub const BTSTACK_SET_POWER_MODE: u32 = 2;
pub const BTSTACK_SET_ACL_CAPTURE_MODE: u32 = 3;
pub const BTSTACK_GET_VERSION: u32 = 4;
pub const BTSTACK_GET_SYSTEM_BLUETOOTH_ENABLED: u32 = 5;
pub const BTSTACK_SET_SYSTEM_BLUETOOTH_ENABLED: u32 = 6;
pub const BTSTACK_SET_DISCOVERABLE: u32 = 7;
pub const BTSTACK_SET_BLUETOOTH_ENABLED: u32 = 8;
pub const L2CAP_CREATE_CHANNEL: u32 = 32;
pub const L2CAP_DISCONNECT: u32 = 33;
pub const L2CAP_REGISTER_SERVICE: u32 = 34;
pub const L2CAP_UNREGISTER_SERVICE: u32 = 35;
pub const L2CAP_ACCEPT_CONNECTION: u32 = 36;
pub const L2CAP_DECLINE_CONNECTION: u32 = 37;
pub const L2CAP_CREATE_CHANNEL_MTU: u32 = 38;
pub const L2CAP_REQUEST_CAN_SEND_NOW: u32 = 39;
pub const SDP_REGISTER_SERVICE_RECORD: u32 = 48;
pub const SDP_UNREGISTER_SERVICE_RECORD: u32 = 49;
pub const SDP_CLIENT_QUERY_RFCOMM_SERVICES: u32 = 50;
pub const SDP_CLIENT_QUERY_SERVICES: u32 = 51;
pub const RFCOMM_CREATE_CHANNEL: u32 = 64;
pub const RFCOMM_DISCONNECT: u32 = 65;
pub const RFCOMM_REGISTER_SERVICE: u32 = 66;
pub const RFCOMM_UNREGISTER_SERVICE: u32 = 67;
pub const RFCOMM_ACCEPT_CONNECTION: u32 = 68;
pub const RFCOMM_DECLINE_CONNECTION: u32 = 69;
pub const RFCOMM_CREATE_CHANNEL_WITH_CREDITS: u32 = 71;
pub const RFCOMM_PERSISTENT_CHANNEL: u32 = 70;
pub const RFCOMM_REGISTER_SERVICE_WITH_CREDITS: u32 = 72;
pub const RFCOMM_GRANT_CREDITS: u32 = 73;
pub const RFCOMM_REQUEST_CAN_SEND_NOW: u32 = 74;
pub const GAP_DISCONNECT: u32 = 80;
pub const GAP_INQUIRY_START: u32 = 81;
pub const GAP_INQUIRY_STOP: u32 = 82;
pub const GAP_REMOTE_NAME_REQUEST: u32 = 83;
pub const GAP_DROP_LINK_KEY_FOR_BD_ADDR: u32 = 84;
pub const GAP_DELETE_ALL_LINK_KEYS: u32 = 85;
pub const GAP_PIN_CODE_RESPONSE: u32 = 86;
pub const GAP_PIN_CODE_NEGATIVE: u32 = 87;
pub const GAP_LE_SCAN_START: u32 = 96;
pub const GAP_LE_SCAN_STOP: u32 = 97;
pub const GAP_LE_CONNECT: u32 = 98;
pub const GAP_LE_CONNECT_CANCEL: u32 = 99;
pub const GAP_LE_SET_SCAN_PARAMETERS: u32 = 100;
pub const GATT_DISCOVER_ALL_PRIMARY_SERVICES: u32 = 112;
pub const GATT_DISCOVER_PRIMARY_SERVICES_BY_UUID16: u32 = 113;
pub const GATT_DISCOVER_PRIMARY_SERVICES_BY_UUID128: u32 = 114;
pub const GATT_FIND_INCLUDED_SERVICES_FOR_SERVICE: u32 = 115;
pub const GATT_DISCOVER_CHARACTERISTICS_FOR_SERVICE: u32 = 116;
pub const GATT_DISCOVER_CHARACTERISTICS_FOR_SERVICE_BY_UUID128: u32 = 117;
pub const GATT_DISCOVER_CHARACTERISTIC_DESCRIPTORS: u32 = 118;
pub const GATT_READ_VALUE_OF_CHARACTERISTIC: u32 = 119;
pub const GATT_READ_LONG_VALUE_OF_CHARACTERISTIC: u32 = 120;
pub const GATT_WRITE_VALUE_OF_CHARACTERISTIC_WITHOUT_RESPONSE: u32 = 121;
pub const GATT_WRITE_VALUE_OF_CHARACTERISTIC: u32 = 122;
pub const GATT_WRITE_LONG_VALUE_OF_CHARACTERISTIC: u32 = 123;
pub const GATT_RELIABLE_WRITE_LONG_VALUE_OF_CHARACTERISTIC: u32 = 124;
pub const GATT_READ_CHARACTERISTIC_DESCRIPTOR: u32 = 125;
pub const GATT_READ_LONG_CHARACTERISTIC_DESCRIPTOR: u32 = 126;
pub const GATT_WRITE_CHARACTERISTIC_DESCRIPTOR: u32 = 127;
pub const GATT_WRITE_LONG_CHARACTERISTIC_DESCRIPTOR: u32 = 128;
pub const GATT_WRITE_CLIENT_CHARACTERISTIC_CONFIGURATION: u32 = 129;
pub const GATT_GET_MTU: u32 = 130;
pub const SM_SET_AUTHENTICATION_REQUIREMENTS: u32 = 144;
pub const SM_SET_IO_CAPABILITIES: u32 = 146;
pub const SM_BONDING_DECLINE: u32 = 147;
pub const SM_JUST_WORKS_CONFIRM: u32 = 148;
pub const SM_NUMERIC_COMPARISON_CONFIRM: u32 = 149;
pub const SM_PASSKEY_INPUT: u32 = 150;
pub const ATT_DB_VERSION: u32 = 1;
pub const HCI_EVENT_NOP: u32 = 0;
pub const HCI_EVENT_INQUIRY_COMPLETE: u32 = 1;
pub const HCI_EVENT_INQUIRY_RESULT: u32 = 2;
pub const HCI_EVENT_CONNECTION_COMPLETE: u32 = 3;
pub const HCI_EVENT_CONNECTION_REQUEST: u32 = 4;
pub const HCI_EVENT_DISCONNECTION_COMPLETE: u32 = 5;
pub const HCI_EVENT_AUTHENTICATION_COMPLETE: u32 = 6;
pub const HCI_EVENT_AUTHENTICATION_COMPLETE_EVENT: u32 = 6;
pub const HCI_EVENT_REMOTE_NAME_REQUEST_COMPLETE: u32 = 7;
pub const HCI_EVENT_ENCRYPTION_CHANGE: u32 = 8;
pub const HCI_EVENT_CHANGE_CONNECTION_LINK_KEY_COMPLETE: u32 = 9;
pub const HCI_EVENT_MASTER_LINK_KEY_COMPLETE: u32 = 10;
pub const HCI_EVENT_READ_REMOTE_SUPPORTED_FEATURES_COMPLETE: u32 = 11;
pub const HCI_EVENT_READ_REMOTE_VERSION_INFORMATION_COMPLETE: u32 = 12;
pub const HCI_EVENT_QOS_SETUP_COMPLETE: u32 = 13;
pub const HCI_EVENT_COMMAND_COMPLETE: u32 = 14;
pub const HCI_EVENT_COMMAND_STATUS: u32 = 15;
pub const HCI_EVENT_HARDWARE_ERROR: u32 = 16;
pub const HCI_EVENT_FLUSH_OCCURRED: u32 = 17;
pub const HCI_EVENT_ROLE_CHANGE: u32 = 18;
pub const HCI_EVENT_NUMBER_OF_COMPLETED_PACKETS: u32 = 19;
pub const HCI_EVENT_MODE_CHANGE: u32 = 20;
pub const HCI_EVENT_RETURN_LINK_KEYS: u32 = 21;
pub const HCI_EVENT_PIN_CODE_REQUEST: u32 = 22;
pub const HCI_EVENT_LINK_KEY_REQUEST: u32 = 23;
pub const HCI_EVENT_LINK_KEY_NOTIFICATION: u32 = 24;
pub const HCI_EVENT_LOOPBACK_COMMAND: u32 = 25;
pub const HCI_EVENT_DATA_BUFFER_OVERFLOW: u32 = 26;
pub const HCI_EVENT_MAX_SLOTS_CHANGED: u32 = 27;
pub const HCI_EVENT_READ_CLOCK_OFFSET_COMPLETE: u32 = 28;
pub const HCI_EVENT_CONNECTION_PACKET_TYPE_CHANGED: u32 = 29;
pub const HCI_EVENT_QOS_VIOLATION: u32 = 30;
pub const HCI_EVENT_PAGE_SCAN_REPETITION_MODE_CHANGE: u32 = 32;
pub const HCI_EVENT_FLOW_SPECIFICATION_COMPLETE: u32 = 33;
pub const HCI_EVENT_INQUIRY_RESULT_WITH_RSSI: u32 = 34;
pub const HCI_EVENT_READ_REMOTE_EXTENDED_FEATURES_COMPLETE: u32 = 35;
pub const HCI_EVENT_SYNCHRONOUS_CONNECTION_COMPLETE: u32 = 44;
pub const HCI_EVENT_SYNCHRONOUS_CONNECTION_CHANGED: u32 = 45;
pub const HCI_EVENT_SNIFF_SUBRATING: u32 = 46;
pub const HCI_EVENT_EXTENDED_INQUIRY_RESPONSE: u32 = 47;
pub const HCI_EVENT_ENCRYPTION_KEY_REFRESH_COMPLETE: u32 = 48;
pub const HCI_EVENT_IO_CAPABILITY_REQUEST: u32 = 49;
pub const HCI_EVENT_IO_CAPABILITY_RESPONSE: u32 = 50;
pub const HCI_EVENT_USER_CONFIRMATION_REQUEST: u32 = 51;
pub const HCI_EVENT_USER_PASSKEY_REQUEST: u32 = 52;
pub const HCI_EVENT_REMOTE_OOB_DATA_REQUEST: u32 = 53;
pub const HCI_EVENT_SIMPLE_PAIRING_COMPLETE: u32 = 54;
pub const HCI_EVENT_LINK_SUPERVISION_TIMEOUT_CHANGED: u32 = 56;
pub const HCI_EVENT_ENHANCED_FLUSH_COMPLETE: u32 = 57;
pub const HCI_EVENT_USER_PASSKEY_NOTIFICATION: u32 = 59;
pub const HCI_EVENT_KEYPRESS_NOTIFICATION: u32 = 60;
pub const HCI_EVENT_REMOTE_HOST_SUPPORTED_FEATURES: u32 = 61;
pub const HCI_EVENT_LE_META: u32 = 62;
pub const HCI_EVENT_NUMBER_OF_COMPLETED_DATA_BLOCKS: u32 = 72;
pub const HCI_EVENT_ENCRYPTION_CHANGE_V2: u32 = 89;
pub const HCI_EVENT_VENDOR_SPECIFIC: u32 = 255;
pub const HCI_SUBEVENT_LE_CONNECTION_COMPLETE: u32 = 1;
pub const HCI_SUBEVENT_LE_ADVERTISING_REPORT: u32 = 2;
pub const HCI_SUBEVENT_LE_CONNECTION_UPDATE_COMPLETE: u32 = 3;
pub const HCI_SUBEVENT_LE_READ_REMOTE_FEATURES_COMPLETE: u32 = 4;
pub const HCI_SUBEVENT_LE_LONG_TERM_KEY_REQUEST: u32 = 5;
pub const HCI_SUBEVENT_LE_REMOTE_CONNECTION_PARAMETER_REQUEST: u32 = 6;
pub const HCI_SUBEVENT_LE_DATA_LENGTH_CHANGE: u32 = 7;
pub const HCI_SUBEVENT_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE: u32 = 8;
pub const HCI_SUBEVENT_LE_GENERATE_DHKEY_COMPLETE: u32 = 9;
pub const HCI_SUBEVENT_LE_ENHANCED_CONNECTION_COMPLETE: u32 = 10;
pub const HCI_SUBEVENT_LE_DIRECT_ADVERTISING_REPORT: u32 = 11;
pub const HCI_SUBEVENT_LE_PHY_UPDATE_COMPLETE: u32 = 12;
pub const HCI_SUBEVENT_LE_EXTENDED_ADVERTISING_REPORT: u32 = 13;
pub const HCI_SUBEVENT_LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHMENT: u32 = 14;
pub const HCI_SUBEVENT_LE_PERIODIC_ADVERTISING_REPORT: u32 = 15;
pub const HCI_SUBEVENT_LE_PERIODIC_ADVERTISING_SYNC_LOST: u32 = 16;
pub const HCI_SUBEVENT_LE_SCAN_TIMEOUT: u32 = 17;
pub const HCI_SUBEVENT_LE_ADVERTISING_SET_TERMINATED: u32 = 18;
pub const HCI_SUBEVENT_LE_SCAN_REQUEST_RECEIVED: u32 = 19;
pub const HCI_SUBEVENT_LE_CHANNEL_SELECTION_ALGORITHM: u32 = 20;
pub const HCI_SUBEVENT_LE_CONNECTIONLESS_IQ_REPORT: u32 = 21;
pub const HCI_SUBEVENT_LE_CONNECTION_IQ_REPORT: u32 = 22;
pub const HCI_SUBEVENT_LE_LE_CTE_REQUEST_FAILED: u32 = 23;
pub const HCI_SUBEVENT_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED: u32 = 24;
pub const HCI_SUBEVENT_LE_CIS_ESTABLISHED: u32 = 25;
pub const HCI_SUBEVENT_LE_CIS_REQUEST: u32 = 26;
pub const HCI_SUBEVENT_LE_CREATE_BIG_COMPLETE: u32 = 27;
pub const HCI_SUBEVENT_LE_TERMINATE_BIG_COMPLETE: u32 = 28;
pub const HCI_SUBEVENT_LE_BIG_SYNC_ESTABLISHED: u32 = 29;
pub const HCI_SUBEVENT_LE_BIG_SYNC_LOST: u32 = 30;
pub const HCI_SUBEVENT_LE_REQUEST_PEER_SCA_COMPLETE: u32 = 31;
pub const HCI_SUBEVENT_LE_TRANSMIT_POWER_REPORTING: u32 = 33;
pub const HCI_SUBEVENT_LE_BIGINFO_ADVERTISING_REPORT: u32 = 34;
pub const HCI_SUBEVENT_LE_SUBRATE_CHANGE: u32 = 35;
pub const BTSTACK_EVENT_STATE: u32 = 96;
pub const BTSTACK_EVENT_NR_CONNECTIONS_CHANGED: u32 = 97;
pub const BTSTACK_EVENT_POWERON_FAILED: u32 = 98;
pub const BTSTACK_EVENT_SCAN_MODE_CHANGED: u32 = 102;
pub const DAEMON_EVENT_VERSION: u32 = 99;
pub const DAEMON_EVENT_SYSTEM_BLUETOOTH_ENABLED: u32 = 100;
pub const DAEMON_EVENT_REMOTE_NAME_CACHED: u32 = 101;
pub const DAEMON_EVENT_CONNECTION_OPENED: u32 = 103;
pub const DAEMON_EVENT_CONNECTION_CLOSED: u32 = 104;
pub const DAEMON_EVENT_L2CAP_CREDITS: u32 = 116;
pub const DAEMON_EVENT_L2CAP_SERVICE_REGISTERED: u32 = 117;
pub const DAEMON_EVENT_RFCOMM_SERVICE_REGISTERED: u32 = 133;
pub const DAEMON_EVENT_RFCOMM_PERSISTENT_CHANNEL: u32 = 134;
pub const DAEMON_EVENT_SDP_SERVICE_REGISTERED: u32 = 144;
pub const HCI_EVENT_TRANSPORT_SLEEP_MODE: u32 = 105;
pub const HCI_EVENT_TRANSPORT_USB_INFO: u32 = 106;
pub const HCI_EVENT_TRANSPORT_READY: u32 = 109;
pub const HCI_EVENT_TRANSPORT_PACKET_SENT: u32 = 110;
pub const HCI_EVENT_BIS_CAN_SEND_NOW: u32 = 107;
pub const HCI_EVENT_CIS_CAN_SEND_NOW: u32 = 108;
pub const HCI_EVENT_SCO_CAN_SEND_NOW: u32 = 111;
pub const L2CAP_EVENT_CHANNEL_OPENED: u32 = 112;
pub const L2CAP_EVENT_CHANNEL_CLOSED: u32 = 113;
pub const L2CAP_EVENT_INCOMING_CONNECTION: u32 = 114;
pub const L2CAP_EVENT_TIMEOUT_CHECK: u32 = 115;
pub const L2CAP_EVENT_CONNECTION_PARAMETER_UPDATE_REQUEST: u32 = 118;
pub const L2CAP_EVENT_CONNECTION_PARAMETER_UPDATE_RESPONSE: u32 = 119;
pub const L2CAP_EVENT_INFORMATION_RESPONSE: u32 = 120;
pub const L2CAP_EVENT_CAN_SEND_NOW: u32 = 121;
pub const L2CAP_EVENT_PACKET_SENT: u32 = 122;
pub const L2CAP_EVENT_ERTM_BUFFER_RELEASED: u32 = 123;
pub const L2CAP_EVENT_CBM_INCOMING_CONNECTION: u32 = 124;
pub const L2CAP_EVENT_CBM_CHANNEL_OPENED: u32 = 125;
pub const L2CAP_EVENT_TRIGGER_RUN: u32 = 126;
pub const L2CAP_EVENT_ECBM_INCOMING_CONNECTION: u32 = 127;
pub const L2CAP_EVENT_ECBM_CHANNEL_OPENED: u32 = 138;
pub const L2CAP_EVENT_ECBM_RECONFIGURED: u32 = 139;
pub const L2CAP_EVENT_ECBM_RECONFIGURATION_COMPLETE: u32 = 140;
pub const RFCOMM_EVENT_CHANNEL_OPENED: u32 = 128;
pub const RFCOMM_EVENT_CHANNEL_CLOSED: u32 = 129;
pub const RFCOMM_EVENT_INCOMING_CONNECTION: u32 = 130;
pub const RFCOMM_EVENT_REMOTE_LINE_STATUS: u32 = 131;
pub const RFCOMM_EVENT_REMOTE_MODEM_STATUS: u32 = 135;
pub const RFCOMM_EVENT_PORT_CONFIGURATION: u32 = 136;
pub const RFCOMM_EVENT_CAN_SEND_NOW: u32 = 137;
pub const SDP_EVENT_QUERY_COMPLETE: u32 = 145;
pub const SDP_EVENT_QUERY_RFCOMM_SERVICE: u32 = 146;
pub const SDP_EVENT_QUERY_ATTRIBUTE_BYTE: u32 = 147;
pub const SDP_EVENT_QUERY_ATTRIBUTE_VALUE: u32 = 148;
pub const SDP_EVENT_QUERY_SERVICE_RECORD_HANDLE: u32 = 149;
pub const GATT_EVENT_QUERY_COMPLETE: u32 = 160;
pub const GATT_EVENT_SERVICE_QUERY_RESULT: u32 = 161;
pub const GATT_EVENT_CHARACTERISTIC_QUERY_RESULT: u32 = 162;
pub const GATT_EVENT_INCLUDED_SERVICE_QUERY_RESULT: u32 = 163;
pub const GATT_EVENT_ALL_CHARACTERISTIC_DESCRIPTORS_QUERY_RESULT: u32 = 164;
pub const GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT: u32 = 165;
pub const GATT_EVENT_LONG_CHARACTERISTIC_VALUE_QUERY_RESULT: u32 = 166;
pub const GATT_EVENT_NOTIFICATION: u32 = 167;
pub const GATT_EVENT_INDICATION: u32 = 168;
pub const GATT_EVENT_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT: u32 = 169;
pub const GATT_EVENT_LONG_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT: u32 = 170;
pub const GATT_EVENT_MTU: u32 = 171;
pub const GATT_EVENT_CAN_WRITE_WITHOUT_RESPONSE: u32 = 172;
pub const ATT_EVENT_CONNECTED: u32 = 179;
pub const ATT_EVENT_DISCONNECTED: u32 = 180;
pub const ATT_EVENT_MTU_EXCHANGE_COMPLETE: u32 = 181;
pub const ATT_EVENT_HANDLE_VALUE_INDICATION_COMPLETE: u32 = 182;
pub const ATT_EVENT_CAN_SEND_NOW: u32 = 183;
pub const BNEP_EVENT_SERVICE_REGISTERED: u32 = 192;
pub const BNEP_EVENT_CHANNEL_OPENED: u32 = 193;
pub const BNEP_EVENT_CHANNEL_CLOSED: u32 = 194;
pub const BNEP_EVENT_CHANNEL_TIMEOUT: u32 = 195;
pub const BNEP_EVENT_CAN_SEND_NOW: u32 = 196;
pub const SM_EVENT_JUST_WORKS_REQUEST: u32 = 200;
pub const SM_EVENT_PASSKEY_DISPLAY_NUMBER: u32 = 201;
pub const SM_EVENT_PASSKEY_DISPLAY_CANCEL: u32 = 202;
pub const SM_EVENT_PASSKEY_INPUT_NUMBER: u32 = 203;
pub const SM_EVENT_NUMERIC_COMPARISON_REQUEST: u32 = 204;
pub const SM_EVENT_IDENTITY_RESOLVING_STARTED: u32 = 205;
pub const SM_EVENT_IDENTITY_RESOLVING_FAILED: u32 = 206;
pub const SM_EVENT_IDENTITY_RESOLVING_SUCCEEDED: u32 = 207;
pub const SM_EVENT_AUTHORIZATION_REQUEST: u32 = 208;
pub const SM_EVENT_AUTHORIZATION_RESULT: u32 = 209;
pub const SM_EVENT_KEYPRESS_NOTIFICATION: u32 = 210;
pub const SM_EVENT_IDENTITY_CREATED: u32 = 211;
pub const SM_EVENT_PAIRING_STARTED: u32 = 212;
pub const SM_EVENT_PAIRING_COMPLETE: u32 = 213;
pub const SM_EVENT_REENCRYPTION_STARTED: u32 = 214;
pub const SM_EVENT_REENCRYPTION_COMPLETE: u32 = 215;
pub const GAP_EVENT_SECURITY_LEVEL: u32 = 216;
pub const GAP_EVENT_DEDICATED_BONDING_COMPLETED: u32 = 217;
pub const GAP_EVENT_ADVERTISING_REPORT: u32 = 218;
pub const GAP_EVENT_EXTENDED_ADVERTISING_REPORT: u32 = 219;
pub const GAP_EVENT_INQUIRY_RESULT: u32 = 220;
pub const GAP_EVENT_INQUIRY_COMPLETE: u32 = 221;
pub const GAP_EVENT_RSSI_MEASUREMENT: u32 = 222;
pub const GAP_EVENT_LOCAL_OOB_DATA: u32 = 223;
pub const GAP_EVENT_PAIRING_STARTED: u32 = 224;
pub const GAP_EVENT_PAIRING_COMPLETE: u32 = 225;
pub const HCI_EVENT_META_GAP: u32 = 231;
pub const HCI_EVENT_HSP_META: u32 = 232;
pub const HCI_EVENT_HFP_META: u32 = 233;
pub const HCI_EVENT_ANCS_META: u32 = 234;
pub const HCI_EVENT_AVDTP_META: u32 = 235;
pub const HCI_EVENT_AVRCP_META: u32 = 236;
pub const HCI_EVENT_GOEP_META: u32 = 237;
pub const HCI_EVENT_PBAP_META: u32 = 238;
pub const HCI_EVENT_HID_META: u32 = 239;
pub const HCI_EVENT_A2DP_META: u32 = 240;
pub const HCI_EVENT_HIDS_META: u32 = 241;
pub const HCI_EVENT_GATTSERVICE_META: u32 = 242;
pub const HCI_EVENT_BIP_META: u32 = 243;
pub const HCI_EVENT_MAP_META: u32 = 244;
pub const HCI_EVENT_MESH_META: u32 = 245;
pub const GAP_SUBEVENT_ADVERTISING_SET_INSTALLED: u32 = 0;
pub const GAP_SUBEVENT_ADVERTISING_SET_REMOVED: u32 = 1;
pub const GAP_SUBEVENT_BIG_CREATED: u32 = 2;
pub const GAP_SUBEVENT_BIG_TERMINATED: u32 = 3;
pub const GAP_SUBEVENT_BIG_SYNC_CREATED: u32 = 4;
pub const GAP_SUBEVENT_BIG_SYNC_STOPPED: u32 = 5;
pub const GAP_SUBEVENT_CIG_CREATED: u32 = 6;
pub const GAP_SUBEVENT_CIS_CREATED: u32 = 7;
pub const HSP_SUBEVENT_RFCOMM_CONNECTION_COMPLETE: u32 = 1;
pub const HSP_SUBEVENT_RFCOMM_DISCONNECTION_COMPLETE: u32 = 2;
pub const HSP_SUBEVENT_AUDIO_CONNECTION_COMPLETE: u32 = 3;
pub const HSP_SUBEVENT_AUDIO_DISCONNECTION_COMPLETE: u32 = 4;
pub const HSP_SUBEVENT_RING: u32 = 5;
pub const HSP_SUBEVENT_MICROPHONE_GAIN_CHANGED: u32 = 6;
pub const HSP_SUBEVENT_SPEAKER_GAIN_CHANGED: u32 = 7;
pub const HSP_SUBEVENT_HS_COMMAND: u32 = 8;
pub const HSP_SUBEVENT_AG_INDICATION: u32 = 9;
pub const HSP_SUBEVENT_BUTTON_PRESSED: u32 = 10;
pub const HFP_SUBEVENT_SERVICE_LEVEL_CONNECTION_ESTABLISHED: u32 = 1;
pub const HFP_SUBEVENT_SERVICE_LEVEL_CONNECTION_RELEASED: u32 = 2;
pub const HFP_SUBEVENT_AUDIO_CONNECTION_ESTABLISHED: u32 = 3;
pub const HFP_SUBEVENT_AUDIO_CONNECTION_RELEASED: u32 = 4;
pub const HFP_SUBEVENT_COMPLETE: u32 = 5;
pub const HFP_SUBEVENT_AG_INDICATOR_MAPPING: u32 = 6;
pub const HFP_SUBEVENT_AG_INDICATOR_STATUS_CHANGED: u32 = 7;
pub const HFP_SUBEVENT_NETWORK_OPERATOR_CHANGED: u32 = 8;
pub const HFP_SUBEVENT_EXTENDED_AUDIO_GATEWAY_ERROR: u32 = 9;
pub const HFP_SUBEVENT_START_RINGING: u32 = 10;
pub const HFP_SUBEVENT_RING: u32 = 11;
pub const HFP_SUBEVENT_STOP_RINGING: u32 = 12;
pub const HFP_SUBEVENT_PLACE_CALL_WITH_NUMBER: u32 = 13;
pub const HFP_SUBEVENT_ATTACH_NUMBER_TO_VOICE_TAG: u32 = 14;
pub const HFP_SUBEVENT_NUMBER_FOR_VOICE_TAG: u32 = 15;
pub const HFP_SUBEVENT_TRANSMIT_DTMF_CODES: u32 = 16;
pub const HFP_SUBEVENT_CALL_ANSWERED: u32 = 17;
pub const HFP_SUBEVENT_CALL_TERMINATED: u32 = 18;
pub const HFP_SUBEVENT_CONFERENCE_CALL: u32 = 19;
pub const HFP_SUBEVENT_SPEAKER_VOLUME: u32 = 20;
pub const HFP_SUBEVENT_MICROPHONE_VOLUME: u32 = 21;
pub const HFP_SUBEVENT_CALL_WAITING_NOTIFICATION: u32 = 22;
pub const HFP_SUBEVENT_CALLING_LINE_IDENTIFICATION_NOTIFICATION: u32 = 23;
pub const HFP_SUBEVENT_ENHANCED_CALL_STATUS: u32 = 24;
pub const HFP_SUBEVENT_SUBSCRIBER_NUMBER_INFORMATION: u32 = 25;
pub const HFP_SUBEVENT_RESPONSE_AND_HOLD_STATUS: u32 = 26;
pub const HFP_SUBEVENT_AT_MESSAGE_SENT: u32 = 27;
pub const HFP_SUBEVENT_AT_MESSAGE_RECEIVED: u32 = 28;
pub const HFP_SUBEVENT_IN_BAND_RING_TONE: u32 = 29;
pub const HFP_SUBEVENT_VOICE_RECOGNITION_ACTIVATED: u32 = 30;
pub const HFP_SUBEVENT_VOICE_RECOGNITION_DEACTIVATED: u32 = 31;
pub const HFP_SUBEVENT_ENHANCED_VOICE_RECOGNITION_HF_READY_FOR_AUDIO: u32 = 32;
pub const HFP_SUBEVENT_ENHANCED_VOICE_RECOGNITION_AG_READY_TO_ACCEPT_AUDIO_INPUT: u32 = 33;
pub const HFP_SUBEVENT_ENHANCED_VOICE_RECOGNITION_AG_IS_STARTING_SOUND: u32 = 34;
pub const HFP_SUBEVENT_ENHANCED_VOICE_RECOGNITION_AG_IS_PROCESSING_AUDIO_INPUT: u32 = 35;
pub const HFP_SUBEVENT_ENHANCED_VOICE_RECOGNITION_AG_MESSAGE_SENT: u32 = 36;
pub const HFP_SUBEVENT_ENHANCED_VOICE_RECOGNITION_AG_MESSAGE: u32 = 37;
pub const HFP_SUBEVENT_ECHO_CANCELING_AND_NOISE_REDUCTION_DEACTIVATE: u32 = 38;
pub const HFP_SUBEVENT_HF_INDICATOR: u32 = 39;
pub const HFP_SUBEVENT_CUSTOM_AT_COMMAND: u32 = 40;
pub const ANCS_SUBEVENT_CLIENT_CONNECTED: u32 = 240;
pub const ANCS_SUBEVENT_CLIENT_NOTIFICATION: u32 = 241;
pub const ANCS_SUBEVENT_CLIENT_DISCONNECTED: u32 = 242;
pub const AVDTP_SUBEVENT_SIGNALING_ACCEPT: u32 = 1;
pub const AVDTP_SUBEVENT_SIGNALING_REJECT: u32 = 2;
pub const AVDTP_SUBEVENT_SIGNALING_GENERAL_REJECT: u32 = 3;
pub const AVDTP_SUBEVENT_SIGNALING_CONNECTION_ESTABLISHED: u32 = 4;
pub const AVDTP_SUBEVENT_SIGNALING_CONNECTION_RELEASED: u32 = 5;
pub const AVDTP_SUBEVENT_SIGNALING_SEP_FOUND: u32 = 6;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_SBC_CAPABILITY: u32 = 7;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AUDIO_CAPABILITY: u32 = 8;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AAC_CAPABILITY: u32 = 9;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_ATRAC_CAPABILITY: u32 = 10;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_OTHER_CAPABILITY: u32 = 11;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_TRANSPORT_CAPABILITY: u32 = 12;
pub const AVDTP_SUBEVENT_SIGNALING_REPORTING_CAPABILITY: u32 = 13;
pub const AVDTP_SUBEVENT_SIGNALING_RECOVERY_CAPABILITY: u32 = 14;
pub const AVDTP_SUBEVENT_SIGNALING_CONTENT_PROTECTION_CAPABILITY: u32 = 15;
pub const AVDTP_SUBEVENT_SIGNALING_MULTIPLEXING_CAPABILITY: u32 = 16;
pub const AVDTP_SUBEVENT_SIGNALING_DELAY_REPORTING_CAPABILITY: u32 = 17;
pub const AVDTP_SUBEVENT_SIGNALING_HEADER_COMPRESSION_CAPABILITY: u32 = 18;
pub const AVDTP_SUBEVENT_SIGNALING_CAPABILITIES_DONE: u32 = 19;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_SBC_CONFIGURATION: u32 = 20;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AUDIO_CONFIGURATION: u32 = 21;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AAC_CONFIGURATION: u32 = 22;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_ATRAC_CONFIGURATION: u32 = 23;
pub const AVDTP_SUBEVENT_SIGNALING_MEDIA_CODEC_OTHER_CONFIGURATION: u32 = 24;
pub const AVDTP_SUBEVENT_STREAMING_CONNECTION_ESTABLISHED: u32 = 25;
pub const AVDTP_SUBEVENT_STREAMING_CONNECTION_RELEASED: u32 = 26;
pub const AVDTP_SUBEVENT_STREAMING_CAN_SEND_MEDIA_PACKET_NOW: u32 = 27;
pub const AVDTP_SUBEVENT_SIGNALING_SEP_DICOVERY_DONE: u32 = 28;
pub const AVDTP_SUBEVENT_SIGNALING_DELAY_REPORT: u32 = 29;
pub const A2DP_SUBEVENT_STREAMING_CAN_SEND_MEDIA_PACKET_NOW: u32 = 1;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_SBC_CONFIGURATION: u32 = 2;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AUDIO_CONFIGURATION: u32 = 3;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AAC_CONFIGURATION: u32 = 4;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_ATRAC_CONFIGURATION: u32 = 5;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_OTHER_CONFIGURATION: u32 = 6;
pub const A2DP_SUBEVENT_STREAM_ESTABLISHED: u32 = 7;
pub const A2DP_SUBEVENT_START_STREAM_REQUESTED: u32 = 8;
pub const A2DP_SUBEVENT_STREAM_STARTED: u32 = 9;
pub const A2DP_SUBEVENT_STREAM_SUSPENDED: u32 = 10;
pub const A2DP_SUBEVENT_STREAM_STOPPED: u32 = 11;
pub const A2DP_SUBEVENT_STREAM_RELEASED: u32 = 12;
pub const A2DP_SUBEVENT_COMMAND_ACCEPTED: u32 = 13;
pub const A2DP_SUBEVENT_COMMAND_REJECTED: u32 = 14;
pub const A2DP_SUBEVENT_SIGNALING_CONNECTION_ESTABLISHED: u32 = 15;
pub const A2DP_SUBEVENT_SIGNALING_CONNECTION_RELEASED: u32 = 16;
pub const A2DP_SUBEVENT_STREAM_RECONFIGURED: u32 = 18;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_SBC_CAPABILITY: u32 = 19;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AUDIO_CAPABILITY: u32 = 20;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_MPEG_AAC_CAPABILITY: u32 = 21;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_ATRAC_CAPABILITY: u32 = 22;
pub const A2DP_SUBEVENT_SIGNALING_MEDIA_CODEC_OTHER_CAPABILITY: u32 = 23;
pub const A2DP_SUBEVENT_SIGNALING_DELAY_REPORTING_CAPABILITY: u32 = 24;
pub const A2DP_SUBEVENT_SIGNALING_DELAY_REPORT: u32 = 25;
pub const A2DP_SUBEVENT_SIGNALING_CAPABILITIES_DONE: u32 = 26;
pub const A2DP_SUBEVENT_SIGNALING_CAPABILITIES_COMPLETE: u32 = 27;
pub const AVRCP_SUBEVENT_NOTIFICATION_PLAYBACK_STATUS_CHANGED: u32 = 1;
pub const AVRCP_SUBEVENT_NOTIFICATION_TRACK_CHANGED: u32 = 2;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_TRACK_REACHED_END: u32 = 3;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_TRACK_REACHED_START: u32 = 4;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_PLAYBACK_POS_CHANGED: u32 = 5;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_BATT_STATUS_CHANGED: u32 = 6;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_SYSTEM_STATUS_CHANGED: u32 = 7;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_PLAYER_APPLICATION_SETTING_CHANGED: u32 = 8;
pub const AVRCP_SUBEVENT_NOTIFICATION_NOW_PLAYING_CONTENT_CHANGED: u32 = 9;
pub const AVRCP_SUBEVENT_NOTIFICATION_AVAILABLE_PLAYERS_CHANGED: u32 = 10;
pub const AVRCP_SUBEVENT_NOTIFICATION_EVENT_UIDS_CHANGED: u32 = 12;
pub const AVRCP_SUBEVENT_NOTIFICATION_VOLUME_CHANGED: u32 = 13;
pub const AVRCP_SUBEVENT_SET_ABSOLUTE_VOLUME_RESPONSE: u32 = 16;
pub const AVRCP_SUBEVENT_NOTIFICATION_STATE: u32 = 17;
pub const AVRCP_SUBEVENT_CONNECTION_ESTABLISHED: u32 = 18;
pub const AVRCP_SUBEVENT_CONNECTION_RELEASED: u32 = 19;
pub const AVRCP_SUBEVENT_SHUFFLE_AND_REPEAT_MODE: u32 = 20;
pub const AVRCP_SUBEVENT_PLAY_STATUS: u32 = 21;
pub const AVRCP_SUBEVENT_OPERATION_START: u32 = 22;
pub const AVRCP_SUBEVENT_OPERATION_COMPLETE: u32 = 23;
pub const AVRCP_SUBEVENT_PLAYER_APPLICATION_VALUE_RESPONSE: u32 = 24;
pub const AVRCP_SUBEVENT_PLAY_STATUS_QUERY: u32 = 25;
pub const AVRCP_SUBEVENT_OPERATION: u32 = 26;
pub const AVRCP_SUBEVENT_NOW_PLAYING_TRACK_INFO: u32 = 27;
pub const AVRCP_SUBEVENT_NOW_PLAYING_TOTAL_TRACKS_INFO: u32 = 28;
pub const AVRCP_SUBEVENT_NOW_PLAYING_SONG_LENGTH_MS_INFO: u32 = 29;
pub const AVRCP_SUBEVENT_NOW_PLAYING_TITLE_INFO: u32 = 30;
pub const AVRCP_SUBEVENT_NOW_PLAYING_ARTIST_INFO: u32 = 31;
pub const AVRCP_SUBEVENT_NOW_PLAYING_ALBUM_INFO: u32 = 32;
pub const AVRCP_SUBEVENT_NOW_PLAYING_GENRE_INFO: u32 = 33;
pub const AVRCP_SUBEVENT_NOW_PLAYING_INFO_DONE: u32 = 34;
pub const AVRCP_SUBEVENT_NOTIFICATION_PLAYBACK_POS_CHANGED: u32 = 35;
pub const AVRCP_SUBEVENT_GET_CAPABILITY_EVENT_ID: u32 = 36;
pub const AVRCP_SUBEVENT_GET_CAPABILITY_EVENT_ID_DONE: u32 = 37;
pub const AVRCP_SUBEVENT_GET_CAPABILITY_COMPANY_ID: u32 = 38;
pub const AVRCP_SUBEVENT_GET_CAPABILITY_COMPANY_ID_DONE: u32 = 39;
pub const AVRCP_SUBEVENT_CUSTOM_COMMAND_RESPONSE: u32 = 40;
pub const AVRCP_SUBEVENT_INCOMING_BROWSING_CONNECTION: u32 = 48;
pub const AVRCP_SUBEVENT_BROWSING_CONNECTION_ESTABLISHED: u32 = 49;
pub const AVRCP_SUBEVENT_BROWSING_CONNECTION_RELEASED: u32 = 50;
pub const AVRCP_SUBEVENT_BROWSING_DONE: u32 = 51;
pub const AVRCP_SUBEVENT_BROWSING_GET_FOLDER_ITEMS: u32 = 52;
pub const AVRCP_SUBEVENT_BROWSING_GET_TOTAL_NUM_ITEMS: u32 = 53;
pub const AVRCP_SUBEVENT_BROWSING_SET_BROWSED_PLAYER: u32 = 54;
pub const GOEP_SUBEVENT_INCOMING_CONNECTION: u32 = 1;
pub const GOEP_SUBEVENT_CONNECTION_OPENED: u32 = 2;
pub const GOEP_SUBEVENT_CONNECTION_CLOSED: u32 = 3;
pub const GOEP_SUBEVENT_CAN_SEND_NOW: u32 = 4;
pub const PBAP_SUBEVENT_CONNECTION_OPENED: u32 = 1;
pub const PBAP_SUBEVENT_CONNECTION_CLOSED: u32 = 2;
pub const PBAP_SUBEVENT_OPERATION_COMPLETED: u32 = 3;
pub const PBAP_SUBEVENT_PHONEBOOK_SIZE: u32 = 4;
pub const PBAP_SUBEVENT_AUTHENTICATION_REQUEST: u32 = 5;
pub const PBAP_SUBEVENT_CARD_RESULT: u32 = 6;
pub const PBAP_SUBEVENT_RESET_MISSED_CALLS: u32 = 10;
pub const PBAP_SUBEVENT_QUERY_PHONEBOOK_SIZE: u32 = 11;
pub const PBAP_SUBEVENT_PULL_PHONEBOOK: u32 = 12;
pub const PBAP_SUBEVENT_PULL_VCARD_LISTING: u32 = 13;
pub const PBAP_SUBEVENT_PULL_VCARD_ENTRY: u32 = 14;
pub const HID_SUBEVENT_INCOMING_CONNECTION: u32 = 1;
pub const HID_SUBEVENT_CONNECTION_OPENED: u32 = 2;
pub const HID_SUBEVENT_CONNECTION_CLOSED: u32 = 3;
pub const HID_SUBEVENT_CAN_SEND_NOW: u32 = 4;
pub const HID_SUBEVENT_SUSPEND: u32 = 5;
pub const HID_SUBEVENT_EXIT_SUSPEND: u32 = 6;
pub const HID_SUBEVENT_VIRTUAL_CABLE_UNPLUG: u32 = 7;
pub const HID_SUBEVENT_GET_REPORT_RESPONSE: u32 = 8;
pub const HID_SUBEVENT_SET_REPORT_RESPONSE: u32 = 9;
pub const HID_SUBEVENT_GET_PROTOCOL_RESPONSE: u32 = 10;
pub const HID_SUBEVENT_SET_PROTOCOL_RESPONSE: u32 = 11;
pub const HID_SUBEVENT_REPORT: u32 = 12;
pub const HID_SUBEVENT_DESCRIPTOR_AVAILABLE: u32 = 13;
pub const HID_SUBEVENT_SNIFF_SUBRATING_PARAMS: u32 = 14;
pub const HIDS_SUBEVENT_CAN_SEND_NOW: u32 = 1;
pub const HIDS_SUBEVENT_PROTOCOL_MODE: u32 = 2;
pub const HIDS_SUBEVENT_BOOT_MOUSE_INPUT_REPORT_ENABLE: u32 = 3;
pub const HIDS_SUBEVENT_BOOT_KEYBOARD_INPUT_REPORT_ENABLE: u32 = 4;
pub const HIDS_SUBEVENT_INPUT_REPORT_ENABLE: u32 = 5;
pub const HIDS_SUBEVENT_OUTPUT_REPORT_ENABLE: u32 = 6;
pub const HIDS_SUBEVENT_FEATURE_REPORT_ENABLE: u32 = 7;
pub const HIDS_SUBEVENT_SUSPEND: u32 = 8;
pub const HIDS_SUBEVENT_EXIT_SUSPEND: u32 = 9;
pub const GATTSERVICE_SUBEVENT_CYCLING_POWER_START_CALIBRATION: u32 = 1;
pub const GATTSERVICE_SUBEVENT_CYCLING_POWER_BROADCAST_START: u32 = 2;
pub const GATTSERVICE_SUBEVENT_CYCLING_POWER_BROADCAST_STOP: u32 = 3;
pub const GATTSERVICE_SUBEVENT_BATTERY_SERVICE_CONNECTED: u32 = 4;
pub const GATTSERVICE_SUBEVENT_BATTERY_SERVICE_LEVEL: u32 = 5;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_DONE: u32 = 6;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_MANUFACTURER_NAME: u32 = 7;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_MODEL_NUMBER: u32 = 8;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_SERIAL_NUMBER: u32 = 9;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_HARDWARE_REVISION: u32 = 10;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_FIRMWARE_REVISION: u32 = 11;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_SOFTWARE_REVISION: u32 = 12;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_SYSTEM_ID: u32 = 13;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_IEEE_REGULATORY_CERTIFICATION: u32 = 14;
pub const GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_PNP_ID: u32 = 15;
pub const GATTSERVICE_SUBEVENT_SCAN_PARAMETERS_SERVICE_CONNECTED: u32 = 16;
pub const GATTSERVICE_SUBEVENT_SPP_SERVICE_CONNECTED: u32 = 17;
pub const GATTSERVICE_SUBEVENT_SPP_SERVICE_DISCONNECTED: u32 = 18;
pub const GATTSERVICE_SUBEVENT_HID_SERVICE_CONNECTED: u32 = 19;
pub const GATTSERVICE_SUBEVENT_HID_REPORT: u32 = 20;
pub const GATTSERVICE_SUBEVENT_HID_INFORMATION: u32 = 21;
pub const GATTSERVICE_SUBEVENT_HID_PROTOCOL_MODE: u32 = 22;
pub const GATTSERVICE_SUBEVENT_HID_SERVICE_REPORTS_NOTIFICATION: u32 = 23;
pub const GATTSERVICE_SUBEVENT_SCAN_PARAMETERS_SERVICE_SCAN_INTERVAL_UPDATE: u32 = 24;
pub const GATTSERVICE_SUBEVENT_MICS_CONNECTED: u32 = 25;
pub const GATTSERVICE_SUBEVENT_REMOTE_MICS_MUTE: u32 = 26;
pub const GATTSERVICE_SUBEVENT_LOCAL_MICS_MUTE: u32 = 27;
pub const GATTSERVICE_SUBEVENT_AICS_MUTE_MODE: u32 = 28;
pub const GATTSERVICE_SUBEVENT_AICS_GAIN_MODE: u32 = 29;
pub const GATTSERVICE_SUBEVENT_AICS_GAIN_CHANGED: u32 = 30;
pub const GATTSERVICE_SUBEVENT_AICS_AUDIO_INPUT_DESC_CHANGED: u32 = 32;
pub const GATTSERVICE_SUBEVENT_VOCS_VOLUME_OFFSET: u32 = 33;
pub const GATTSERVICE_SUBEVENT_VOCS_AUDIO_LOCATION: u32 = 34;
pub const GATTSERVICE_SUBEVENT_VOCS_AUDIO_OUTPUT_DESC_CHANGED: u32 = 35;
pub const GATTSERVICE_SUBEVENT_VCS_VOLUME_STATE: u32 = 36;
pub const GATTSERVICE_SUBEVENT_VCS_VOLUME_FLAGS: u32 = 37;
pub const GATTSERVICE_SUBEVENT_BASS_REMOTE_SCAN_STOPPED: u32 = 38;
pub const GATTSERVICE_SUBEVENT_BASS_REMOTE_SCAN_STARTED: u32 = 39;
pub const GATTSERVICE_SUBEVENT_BASS_BROADCAST_CODE: u32 = 40;
pub const GATTSERVICE_SUBEVENT_BASS_SOURCE_ADDED: u32 = 41;
pub const GATTSERVICE_SUBEVENT_BASS_SOURCE_MODIFIED: u32 = 48;
pub const GATTSERVICE_SUBEVENT_BASS_SOURCE_DELETED: u32 = 49;
pub const GATTSERVICE_SUBEVENT_ASCS_CODEC_CONFIGURATION_REQUEST: u32 = 50;
pub const GATTSERVICE_SUBEVENT_ASCS_QOS_CONFIGURATION: u32 = 51;
pub const GATTSERVICE_SUBEVENT_ASCS_METADATA: u32 = 52;
pub const GATTSERVICE_SUBEVENT_ASCS_CLIENT_START_READY: u32 = 53;
pub const GATTSERVICE_SUBEVENT_ASCS_CLIENT_DISABLING: u32 = 54;
pub const GATTSERVICE_SUBEVENT_ASCS_CLIENT_RELEASING: u32 = 55;
pub const GATTSERVICE_SUBEVENT_ASCS_CLIENT_STOP_READY: u32 = 56;
pub const GATTSERVICE_SUBEVENT_ASCS_CLIENT_RELEASED: u32 = 57;
pub const GATTSERVICE_SUBEVENT_PACS_AUDIO_LOCATION_RECEIVED: u32 = 66;
pub const GATTSERVICE_SUBEVENT_BASS_CONNECTED: u32 = 67;
pub const GATTSERVICE_SUBEVENT_BASS_DISCONNECTED: u32 = 68;
pub const GATTSERVICE_SUBEVENT_BASS_SCAN_OPERATION_COMPLETE: u32 = 69;
pub const GATTSERVICE_SUBEVENT_BASS_NOTIFY_RECEIVE_STATE_BASE: u32 = 70;
pub const GATTSERVICE_SUBEVENT_BASS_NOTIFY_RECEIVE_STATE_SUBGROUP: u32 = 71;
pub const GATTSERVICE_SUBEVENT_BASS_NOTIFICATION_COMPLETE: u32 = 72;
pub const GATTSERVICE_SUBEVENT_BASS_SOURCE_OPERATION_COMPLETE: u32 = 73;
pub const GATTSERVICE_SUBEVENT_PACS_CONNECTED: u32 = 80;
pub const GATTSERVICE_SUBEVENT_PACS_OPERATION_DONE: u32 = 81;
pub const GATTSERVICE_SUBEVENT_PACS_AUDIO_LOCATIONS: u32 = 82;
pub const GATTSERVICE_SUBEVENT_PACS_AVAILABLE_AUDIO_CONTEXTS: u32 = 83;
pub const GATTSERVICE_SUBEVENT_PACS_SUPPORTED_AUDIO_CONTEXTS: u32 = 84;
pub const GATTSERVICE_SUBEVENT_PACS_PACK_RECORD: u32 = 85;
pub const GATTSERVICE_SUBEVENT_PACS_PACK_RECORD_DONE: u32 = 86;
pub const GATTSERVICE_SUBEVENT_ASCS_CONNECTED: u32 = 87;
pub const GATTSERVICE_SUBEVENT_ASCS_DISCONNECTED: u32 = 88;
pub const GATTSERVICE_SUBEVENT_ASCS_CODEC_CONFIGURATION: u32 = 89;
pub const GATTSERVICE_SUBEVENT_PACS_DISCONNECTED: u32 = 90;
pub const MAP_SUBEVENT_CONNECTION_OPENED: u32 = 1;
pub const MAP_SUBEVENT_CONNECTION_CLOSED: u32 = 2;
pub const MAP_SUBEVENT_OPERATION_COMPLETED: u32 = 3;
pub const MAP_SUBEVENT_FOLDER_LISTING_ITEM: u32 = 4;
pub const MAP_SUBEVENT_MESSAGE_LISTING_ITEM: u32 = 5;
pub const MAP_SUBEVENT_PARSING_DONE: u32 = 6;
pub const MESH_SUBEVENT_CAN_SEND_NOW: u32 = 1;
pub const MESH_SUBEVENT_PB_TRANSPORT_PDU_SENT: u32 = 2;
pub const MESH_SUBEVENT_PB_TRANSPORT_LINK_OPEN: u32 = 3;
pub const MESH_SUBEVENT_PB_TRANSPORT_LINK_CLOSED: u32 = 4;
pub const MESH_SUBEVENT_PB_PROV_ATTENTION_TIMER: u32 = 16;
pub const MESH_SUBEVENT_PB_PROV_START_EMIT_PUBLIC_KEY_OOB: u32 = 17;
pub const MESH_SUBEVENT_PB_PROV_STOP_EMIT_PUBLIC_KEY_OOB: u32 = 18;
pub const MESH_SUBEVENT_PB_PROV_INPUT_OOB_REQUEST: u32 = 19;
pub const MESH_SUBEVENT_PB_PROV_START_EMIT_OUTPUT_OOB: u32 = 21;
pub const MESH_SUBEVENT_PB_PROV_STOP_EMIT_OUTPUT_OOB: u32 = 22;
pub const MESH_SUBEVENT_PB_PROV_START_RECEIVE_PUBLIC_KEY_OOB: u32 = 23;
pub const MESH_SUBEVENT_PB_PROV_STOP_RECEIVE_PUBLIC_KEY_OOB: u32 = 24;
pub const MESH_SUBEVENT_PB_PROV_OUTPUT_OOB_REQUEST: u32 = 25;
pub const MESH_SUBEVENT_PB_PROV_START_EMIT_INPUT_OOB: u32 = 26;
pub const MESH_SUBEVENT_PB_PROV_STOP_EMIT_INPUT_OOB: u32 = 27;
pub const MESH_SUBEVENT_PB_PROV_CAPABILITIES: u32 = 28;
pub const MESH_SUBEVENT_PB_PROV_COMPLETE: u32 = 29;
pub const MESH_SUBEVENT_ATTENTION_TIMER: u32 = 30;
pub const MESH_SUBEVENT_PROXY_CONNECTED: u32 = 32;
pub const MESH_SUBEVENT_PROXY_PDU_SENT: u32 = 33;
pub const MESH_SUBEVENT_PROXY_DISCONNECTED: u32 = 34;
pub const MESH_SUBEVENT_MESSAGE_SENT: u32 = 35;
pub const MESH_SUBEVENT_STATE_UPDATE_BOOL: u32 = 36;
pub const MESH_SUBEVENT_STATE_UPDATE_INT16: u32 = 37;
pub const MESH_SUBEVENT_MESSAGE_NOT_ACKNOWLEDGED: u32 = 48;
pub const MESH_SUBEVENT_GENERIC_ON_OFF: u32 = 49;
pub const MESH_SUBEVENT_GENERIC_LEVEL: u32 = 50;
pub const MESH_SUBEVENT_HEALTH_PERFORM_TEST: u32 = 51;
pub const MESH_SUBEVENT_HEALTH_ATTENTION_TIMER_CHANGED: u32 = 52;
pub const MESH_SUBEVENT_GENERIC_DEFAULT_TRANSITION_TIME: u32 = 53;
pub const MESH_SUBEVENT_CONFIGURATION_BEACON: u32 = 54;
pub const MESH_SUBEVENT_CONFIGURATION_COMPOSITION_DATA: u32 = 55;
pub const MESH_SUBEVENT_CONFIGURATION_DEFAULT_TTL: u32 = 56;
pub const MESH_SUBEVENT_CONFIGURATION_GATT_PROXY: u32 = 57;
pub const MESH_SUBEVENT_CONFIGURATION_RELAY: u32 = 64;
pub const MESH_SUBEVENT_CONFIGURATION_MODEL_PUBLICATION: u32 = 65;
pub const MESH_SUBEVENT_CONFIGURATION_MODEL_SUBSCRIPTION: u32 = 66;
pub const MESH_SUBEVENT_CONFIGURATION_MODEL_SUBSCRIPTION_LIST_ITEM: u32 = 67;
pub const MESH_SUBEVENT_CONFIGURATION_NETKEY_INDEX: u32 = 68;
pub const MESH_SUBEVENT_CONFIGURATION_NETKEY_INDEX_LIST_ITEM: u32 = 69;
pub const MESH_SUBEVENT_CONFIGURATION_APPKEY_INDEX: u32 = 70;
pub const MESH_SUBEVENT_CONFIGURATION_APPKEY_INDEX_LIST_ITEM: u32 = 71;
pub const MESH_SUBEVENT_CONFIGURATION_NODE_IDENTITY: u32 = 72;
pub const MESH_SUBEVENT_CONFIGURATION_MODEL_APP: u32 = 73;
pub const MESH_SUBEVENT_CONFIGURATION_MODEL_APP_LIST_ITEM: u32 = 80;
pub const MESH_SUBEVENT_CONFIGURATION_NODE_RESET: u32 = 81;
pub const MESH_SUBEVENT_CONFIGURATION_FRIEND: u32 = 82;
pub const MESH_SUBEVENT_CONFIGURATION_KEY_REFRESH_PHASE: u32 = 83;
pub const MESH_SUBEVENT_CONFIGURATION_HEARTBEAT_PUBLICATION: u32 = 84;
pub const MESH_SUBEVENT_CONFIGURATION_HEARTBEAT_SUBSCRIPTION: u32 = 85;
pub const MESH_SUBEVENT_CONFIGURATION_LOW_POWER_NODE_POLL_TIMEOUT: u32 = 86;
pub const MESH_SUBEVENT_CONFIGURATION_NETWORK_TRANSMIT: u32 = 87;
pub const DEVICE_NAME_LEN: u32 = 248;
pub const __GNUC_VA_LIST: u32 = 1;
pub const HCI_DUMP_LOG_LEVEL_DEBUG: u32 = 0;
pub const HCI_DUMP_LOG_LEVEL_INFO: u32 = 1;
pub const HCI_DUMP_LOG_LEVEL_ERROR: u32 = 2;
pub const HCI_DUMP_HEADER_SIZE_PACKETLOGGER: u32 = 13;
pub const HCI_DUMP_HEADER_SIZE_BLUEZ: u32 = 13;
pub const HCI_DUMP_HEADER_SIZE_BTSNOOP: u32 = 24;
pub const HCI_DUMP_MAX_MESSAGE_LEN: u32 = 256;
pub const MAX_NR_BIS: u32 = 2;
pub const MAX_NR_CIS: u32 = 2;
pub const ATT_ERROR_RESPONSE: u32 = 1;
pub const ATT_EXCHANGE_MTU_REQUEST: u32 = 2;
pub const ATT_EXCHANGE_MTU_RESPONSE: u32 = 3;
pub const ATT_FIND_INFORMATION_REQUEST: u32 = 4;
pub const ATT_FIND_INFORMATION_REPLY: u32 = 5;
pub const ATT_FIND_BY_TYPE_VALUE_REQUEST: u32 = 6;
pub const ATT_FIND_BY_TYPE_VALUE_RESPONSE: u32 = 7;
pub const ATT_READ_BY_TYPE_REQUEST: u32 = 8;
pub const ATT_READ_BY_TYPE_RESPONSE: u32 = 9;
pub const ATT_READ_REQUEST: u32 = 10;
pub const ATT_READ_RESPONSE: u32 = 11;
pub const ATT_READ_BLOB_REQUEST: u32 = 12;
pub const ATT_READ_BLOB_RESPONSE: u32 = 13;
pub const ATT_READ_MULTIPLE_REQUEST: u32 = 14;
pub const ATT_READ_MULTIPLE_RESPONSE: u32 = 15;
pub const ATT_READ_BY_GROUP_TYPE_REQUEST: u32 = 16;
pub const ATT_READ_BY_GROUP_TYPE_RESPONSE: u32 = 17;
pub const ATT_WRITE_REQUEST: u32 = 18;
pub const ATT_WRITE_RESPONSE: u32 = 19;
pub const ATT_PREPARE_WRITE_REQUEST: u32 = 22;
pub const ATT_PREPARE_WRITE_RESPONSE: u32 = 23;
pub const ATT_EXECUTE_WRITE_REQUEST: u32 = 24;
pub const ATT_EXECUTE_WRITE_RESPONSE: u32 = 25;
pub const ATT_HANDLE_VALUE_NOTIFICATION: u32 = 27;
pub const ATT_HANDLE_VALUE_INDICATION: u32 = 29;
pub const ATT_HANDLE_VALUE_CONFIRMATION: u32 = 30;
pub const ATT_READ_MULTIPLE_VARIABLE_REQ: u32 = 32;
pub const ATT_READ_MULTIPLE_VARIABLE_RSP: u32 = 33;
pub const ATT_MULTIPLE_HANDLE_VALUE_NTF: u32 = 35;
pub const ATT_WRITE_COMMAND: u32 = 82;
pub const ATT_SIGNED_WRITE_COMMAND: u32 = 210;
pub const ATT_PROPERTY_UUID128: u32 = 512;
pub const ATT_PROPERTY_READ_PERMISSION_BIT_0: u32 = 1024;
pub const ATT_PROPERTY_READ_PERMISSION_BIT_1: u32 = 2048;
pub const ATT_PROPERTY_WRITE_PERMISSION_BIT_0: u32 = 1;
pub const ATT_PROPERTY_WRITE_PERMISSION_BIT_1: u32 = 16;
pub const ATT_PROPERTY_READ_PERMISSION_SC: u32 = 32;
pub const ATT_PROPERTY_WRITE_PERMISSION_SC: u32 = 128;
pub const ATT_READ_ERROR_CODE_OFFSET: u32 = 65024;
pub const ATT_READ_RESPONSE_PENDING: u32 = 65535;
pub const ATT_INTERNAL_WRITE_RESPONSE_PENDING: u32 = 65534;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const HCI_CMD_HEADER_SIZE: u32 = 3;
pub const HCI_ACL_HEADER_SIZE: u32 = 4;
pub const HCI_SCO_HEADER_SIZE: u32 = 3;
pub const HCI_EVENT_HEADER_SIZE: u32 = 2;
pub const HCI_ISO_HEADER_SIZE: u32 = 4;
pub const HCI_EVENT_PAYLOAD_SIZE: u32 = 255;
pub const HCI_CMD_PAYLOAD_SIZE: u32 = 255;
pub const HCI_ISO_PAYLOAD_SIZE: u32 = 310;
pub const HCI_CMD_PAYLOAD_SIZE_LE: u32 = 32;
pub const HCI_EVENT_BUFFER_SIZE: u32 = 258;
pub const HCI_CMD_BUFFER_SIZE: u32 = 35;
pub const HCI_ACL_BUFFER_SIZE: u32 = 263;
pub const HCI_INCOMING_PACKET_BUFFER_SIZE: u32 = 263;
pub const HCI_OUTGOING_PACKET_BUFFER_SIZE: u32 = 263;
pub const HCI_INCOMING_PRE_BUFFER_SIZE: u32 = 2;
pub const OFFSET_OF_DATA_IN_COMMAND_COMPLETE: u32 = 5;
pub const GAP_CONNECTION_TASK_WRITE_AUTOMATIC_FLUSH_TIMEOUT: u32 = 1;
pub const GAP_CONNECTION_TASK_WRITE_SUPERVISION_TIMEOUT: u32 = 2;
pub const GAP_CONNECTION_TASK_READ_RSSI: u32 = 4;
pub const GAP_CONNECTION_TASK_LE_READ_REMOTE_FEATURES: u32 = 8;
pub const ATT_REQUEST_BUFFER_SIZE: u32 = 259;
pub const GAP_TASK_SET_LOCAL_NAME: u32 = 1;
pub const GAP_TASK_SET_EIR_DATA: u32 = 2;
pub const GAP_TASK_SET_CLASS_OF_DEVICE: u32 = 4;
pub const GAP_TASK_SET_DEFAULT_LINK_POLICY: u32 = 8;
pub const GAP_TASK_WRITE_SCAN_ENABLE: u32 = 16;
pub const GAP_TASK_WRITE_PAGE_SCAN_ACTIVITY: u32 = 32;
pub const GAP_TASK_WRITE_PAGE_SCAN_TYPE: u32 = 64;
pub const GAP_TASK_WRITE_PAGE_TIMEOUT: u32 = 128;
pub const GAP_TASK_WRITE_INQUIRY_SCAN_ACTIVITY: u32 = 256;
pub const MAX_NUM_RESOLVING_LIST_ENTRIES: u32 = 64;
pub const HID_BOOT_MODE_KEYBOARD_ID: u32 = 1;
pub const HID_BOOT_MODE_MOUSE_ID: u32 = 2;
pub const L2CAP_LE_AUTOMATIC_CREDITS: u32 = 65535;
pub const L2CAP_CHANNEL_STATE_VAR_NONE: u32 = 0;
pub const L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_REQ: u32 = 1;
pub const L2CAP_CHANNEL_STATE_VAR_RCVD_CONF_RSP: u32 = 2;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_REQ: u32 = 4;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP: u32 = 8;
pub const L2CAP_CHANNEL_STATE_VAR_SENT_CONF_REQ: u32 = 16;
pub const L2CAP_CHANNEL_STATE_VAR_SENT_CONF_RSP: u32 = 32;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_MTU: u32 = 64;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_ERTM: u32 = 128;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_CONT: u32 = 256;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_INVALID: u32 = 512;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONF_RSP_REJECTED: u32 = 1024;
pub const L2CAP_CHANNEL_STATE_VAR_BASIC_FALLBACK_TRIED: u32 = 2048;
pub const L2CAP_CHANNEL_STATE_VAR_SEND_CONN_RESP_PEND: u32 = 4096;
pub const L2CAP_CHANNEL_STATE_VAR_SENT_CONN_RESP_PEND: u32 = 8192;
pub const L2CAP_CHANNEL_STATE_VAR_INCOMING: u32 = 32768;
pub const PSM_SDP: u32 = 1;
pub const PSM_RFCOMM: u32 = 3;
pub const PSM_BNEP: u32 = 15;
pub const PSM_HID_CONTROL: u32 = 17;
pub const PSM_HID_INTERRUPT: u32 = 19;
pub const PSM_ATT: u32 = 31;
pub const PSM_IPSP: u32 = 35;
pub const MAX_NUM_BATTERY_SERVICES: u32 = 3;
pub const MAX_NUM_HID_SERVICES: u32 = 3;
pub const HIDS_CLIENT_INVALID_REPORT_INDEX: u32 = 255;
pub const HIDS_CLIENT_NUM_REPORTS: u32 = 15;
pub const BOND_MANAGEMENT_CONTROL_POINT_OPCODE_NOT_SUPPORTED: u32 = 128;
pub const BOND_MANAGEMENT_OPERATION_FAILED: u32 = 129;
pub const BMF_DELETE_ACTIVE_BOND_CLASSIC_AND_LE: u32 = 1;
pub const BMF_DELETE_ACTIVE_BOND_CLASSIC_AND_LE_WITH_AUTH: u32 = 2;
pub const BMF_DELETE_ACTIVE_BOND_CLASSIC: u32 = 4;
pub const BMF_DELETE_ACTIVE_BOND_CLASSIC_WITH_AUTH: u32 = 8;
pub const BMF_DELETE_ACTIVE_BOND_LE: u32 = 16;
pub const BMF_DELETE_ACTIVE_BOND_LE_WITH_AUTH: u32 = 32;
pub const BMF_DELETE_ALL_BONDS_CLASSIC_AND_LE: u32 = 64;
pub const BMF_DELETE_ALL_BONDS_CLASSIC_AND_LE_WITH_AUTH: u32 = 128;
pub const BMF_DELETE_ALL_BONDS_CLASSIC: u32 = 256;
pub const BMF_DELETE_ALL_BONDS_CLASSIC_WITH_AUTH: u32 = 512;
pub const BMF_DELETE_ALL_BONDS_LE: u32 = 1024;
pub const BMF_DELETE_ALL_BONDS_LE_WITH_AUTH: u32 = 2048;
pub const BMF_DELETE_ALL_BUT_ACTIVE_BOND_CLASSIC_AND_LE: u32 = 4096;
pub const BMF_DELETE_ALL_BUT_ACTIVE_BOND_CLASSIC_AND_LE_WITH_AUTH: u32 = 8192;
pub const BMF_DELETE_ALL_BUT_ACTIVE_BOND_CLASSIC: u32 = 16384;
pub const BMF_DELETE_ALL_BUT_ACTIVE_BOND_CLASSIC_WITH_AUTH: u32 = 32768;
pub const BMF_DELETE_ALL_BUT_ACTIVE_BOND_LE: u32 = 65536;
pub const BMF_DELETE_ALL_BUT_ACTIVE_BOND_LE_WITH_AUT: u32 = 131072;
pub const CYCLING_POWER_MANUFACTURER_SPECIFIC_DATA_MAX_SIZE: u32 = 16;
pub const LE_AUDIO_MAX_CODEC_CONFIG_SIZE: u32 = 19;
pub const LE_CCIDS_MAX_NUM: u32 = 10;
pub const LE_AUDIO_PROGRAM_INFO_MAX_LENGTH: u32 = 20;
pub const LE_AUDIO_PROGRAM_INFO_URI_MAX_LENGTH: u32 = 20;
pub const LE_AUDIO_EXTENDED_METADATA_MAX_LENGHT: u32 = 20;
pub const LE_AUDIO_VENDOR_SPECIFIC_METADATA_MAX_LENGTH: u32 = 20;
pub const LE_AUDIO_LOCATION_MASK_NOT_ALLOWED: u32 = 0;
pub const LE_AUDIO_LOCATION_MASK_FRONT_LEFT: u32 = 1;
pub const LE_AUDIO_LOCATION_MASK_FRONT_RIGHT: u32 = 2;
pub const LE_AUDIO_LOCATION_MASK_FRONT_CENTER: u32 = 4;
pub const LE_AUDIO_LOCATION_MASK_LOW_FREQUENCY_EFFECTS1: u32 = 8;
pub const LE_AUDIO_LOCATION_MASK_BACK_LEFT: u32 = 16;
pub const LE_AUDIO_LOCATION_MASK_BACK_RIGHT: u32 = 32;
pub const LE_AUDIO_LOCATION_MASK_FRONT_LEFT_OF_CENTER: u32 = 64;
pub const LE_AUDIO_LOCATION_MASK_FRONT_RIGHT_OF_CENTER: u32 = 128;
pub const LE_AUDIO_LOCATION_MASK_BACK_CENTER: u32 = 256;
pub const LE_AUDIO_LOCATION_MASK_LOW_FREQUENCY_EFFECTS2: u32 = 512;
pub const LE_AUDIO_LOCATION_MASK_SIDE_LEFT: u32 = 1024;
pub const LE_AUDIO_LOCATION_MASK_SIDE_RIGHT: u32 = 2048;
pub const LE_AUDIO_LOCATION_MASK_TOP_FRONT_LEFT: u32 = 4096;
pub const LE_AUDIO_LOCATION_MASK_TOP_FRONT_RIGHT: u32 = 8192;
pub const LE_AUDIO_LOCATION_MASK_TOP_FRONT_CENTER: u32 = 16384;
pub const LE_AUDIO_LOCATION_MASK_TOP_CENTER: u32 = 32768;
pub const LE_AUDIO_LOCATION_MASK_TOP_BACK_LEFT: u32 = 65536;
pub const LE_AUDIO_LOCATION_MASK_TOP_BACK_RIGHT: u32 = 131072;
pub const LE_AUDIO_LOCATION_MASK_TOP_SIDE_LEFT: u32 = 262144;
pub const LE_AUDIO_LOCATION_MASK_TOP_SIDE_RIGHT: u32 = 524288;
pub const LE_AUDIO_LOCATION_MASK_TOP_BACK_CENTER: u32 = 1048576;
pub const LE_AUDIO_LOCATION_MASK_BOTTOM_FRONT_CENTER: u32 = 2097152;
pub const LE_AUDIO_LOCATION_MASK_BOTTOM_FRONT_LEFT: u32 = 4194304;
pub const LE_AUDIO_LOCATION_MASK_BOTTOM_FRONT_RIGHT: u32 = 8388608;
pub const LE_AUDIO_LOCATION_MASK_FRONT_LEFT_WIDE: u32 = 16777216;
pub const LE_AUDIO_LOCATION_MASK_FRONT_RIGHT_WIDE: u32 = 33554432;
pub const LE_AUDIO_LOCATION_MASK_LEFT_SURROUND: u32 = 67108864;
pub const LE_AUDIO_LOCATION_MASK_RIGHT_SURROUND: u32 = 134217728;
pub const LE_AUDIO_LOCATION_MASK_RFU: u32 = 4026531840;
pub const LE_AUDIO_CONTEXT_MASK_PROHIBITED: u32 = 0;
pub const LE_AUDIO_CONTEXT_MASK_UNSPECIFIED: u32 = 1;
pub const LE_AUDIO_CONTEXT_MASK_CONVERSATIONAL: u32 = 2;
pub const LE_AUDIO_CONTEXT_MASK_MEDIA: u32 = 4;
pub const LE_AUDIO_CONTEXT_MASK_GAME: u32 = 8;
pub const LE_AUDIO_CONTEXT_MASK_INSTRUCTIONAL: u32 = 16;
pub const LE_AUDIO_CONTEXT_MASK_VOICE_ASSISTANTS: u32 = 32;
pub const LE_AUDIO_CONTEXT_MASK_LIVE: u32 = 64;
pub const LE_AUDIO_CONTEXT_MASK_SOUND_EFFECTS: u32 = 128;
pub const LE_AUDIO_CONTEXT_MASK_NOTIFICATIONS: u32 = 256;
pub const LE_AUDIO_CONTEXT_MASK_RINGTONE: u32 = 512;
pub const LE_AUDIO_CONTEXT_MASK_ALERTS: u32 = 1024;
pub const LE_AUDIO_CONTEXT_MASK_EMERGENCY_ALARM: u32 = 2048;
pub const LE_AUDIO_CONTEXT_MASK_RFU: u32 = 61440;
pub const LE_AUDIO_OTC_MIN_OBJECT_ID_VALUE: u32 = 256;
pub const LE_AUDIO_OTC_MAX_OBJECT_ID_VALUE: u64 = 281474976710655;
pub const LE_AUDIO_UNFRAMED_ISOAL_MASK_PDUS_SUPPORTED: u32 = 0;
pub const LE_AUDIO_UNFRAMED_ISOAL_MASK_PDUS_NOT_SUPPORTED: u32 = 1;
pub const LE_AUDIO_SERVER_PHY_MASK_NO_PREFERENCE: u32 = 0;
pub const LE_AUDIO_SERVER_PHY_MASK_1M: u32 = 1;
pub const LE_AUDIO_SERVER_PHY_MASK_2M: u32 = 2;
pub const LE_AUDIO_SERVER_PHY_MASK_CODED: u32 = 4;
pub const LE_AUDIO_SERVER_LATENCY_MASK_NO_PREFERENCE: u32 = 0;
pub const LE_AUDIO_SERVER_LATENCY_MASK_LOW: u32 = 1;
pub const LE_AUDIO_SERVER_LATENCY_MASK_BALANCED: u32 = 2;
pub const LE_AUDIO_SERVER_LATENCY_MASK_HIGH: u32 = 4;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_8000_HZ: u32 = 1;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_11025_HZ: u32 = 2;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_16000_HZ: u32 = 4;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_22050_HZ: u32 = 8;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_24000_HZ: u32 = 16;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_32000_HZ: u32 = 32;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_44100_HZ: u32 = 64;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_48000_HZ: u32 = 128;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_88200_HZ: u32 = 256;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_96000_HZ: u32 = 512;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_176400_HZ: u32 = 1024;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_192000_HZ: u32 = 2048;
pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_MASK_384000_HZ: u32 = 4096;
pub const LE_AUDIO_CODEC_FRAME_DURATION_MASK_7500US: u32 = 0;
pub const LE_AUDIO_CODEC_FRAME_DURATION_MASK_10000US: u32 = 1;
pub const LE_AUDIO_CODEC_FRAME_DURATION_MASK_7500US_PREFERRED: u32 = 8;
pub const LE_AUDIO_CODEC_FRAME_DURATION_MASK_10000US_PREFERRED: u32 = 16;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_1: u32 = 1;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_2: u32 = 2;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_3: u32 = 4;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_4: u32 = 8;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_5: u32 = 16;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_6: u32 = 32;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_7: u32 = 64;
pub const LE_AUDIO_CODEC_AUDIO_CHANNEL_COUNT_MASK_8: u32 = 128;
pub const AICS_MAX_NUM_SERVICES: u32 = 5;
pub const AICS_MAX_AUDIO_INPUT_DESCRIPTION_LENGTH: u32 = 30;
pub const AICS_ERROR_CODE_INVALID_CHANGE_COUNTER: u32 = 128;
pub const AICS_ERROR_CODE_OPCODE_NOT_SUPPORTED: u32 = 129;
pub const AICS_ERROR_CODE_MUTE_DISABLED: u32 = 130;
pub const AICS_ERROR_CODE_VALUE_OUT_OF_RANGE: u32 = 131;
pub const AICS_ERROR_CODE_GAIN_MODE_CHANGE_NOT_ALLOWED: u32 = 132;
pub const BASS_ERROR_CODE_OPCODE_NOT_SUPPORTED: u32 = 128;
pub const BASS_ERROR_CODE_INVALID_SOURCE_ID: u32 = 129;
pub const BASS_SUBGROUPS_MAX_NUM: u32 = 10;
pub const BASS_MAX_NOTIFY_BUFFER_SIZE: u32 = 200;
pub const BASS_INVALID_SOURCE_INDEX: u32 = 255;
pub const BASS_CLIENT_MAX_ATT_BUFFER_SIZE: u32 = 512;
pub const ATT_ERROR_RESPONSE_MICROPHONE_CONTROL_MUTE_DISABLED: u32 = 128;
pub const VOCS_MAX_NUM_SERVICES: u32 = 5;
pub const VOCS_MAX_AUDIO_OUTPUT_DESCRIPTION_LENGTH: u32 = 30;
pub const VOCS_ERROR_CODE_INVALID_CHANGE_COUNTER: u32 = 128;
pub const VOCS_ERROR_CODE_OPCODE_NOT_SUPPORTED: u32 = 129;
pub const VOCS_ERROR_CODE_VALUE_OUT_OF_RANGE: u32 = 130;
pub const VOLUME_CONTROL_INVALID_CHANGE_COUNTER: u32 = 128;
pub const VOLUME_CONTROL_OPCODE_NOT_SUPPORTED: u32 = 129;
pub const VCS_VOLUME_FLAGS_SETTING_PERSISTED_BIT_POS: u32 = 0;
pub const VCS_VOLUME_FLAGS_SETTING_PERSISTED_MASK: u32 = 1;
pub const VCS_VOLUME_FLAGS_SETTING_PERSISTED_RESET: u32 = 0;
pub const VCS_VOLUME_FLAGS_SETTING_PERSISTED_USER_SET: u32 = 1;
pub const PARAM_ASSERTIONS_ENABLE_ALL: u32 = 0;
pub const PARAM_ASSERTIONS_DISABLE_ALL: u32 = 0;
pub const PICO_SDK_VERSION_MAJOR: u32 = 1;
pub const PICO_SDK_VERSION_MINOR: u32 = 5;
pub const PICO_SDK_VERSION_REVISION: u32 = 0;
pub const PICO_SDK_VERSION_STRING: &[u8; 6usize] = b"1.5.0\0";
pub const PICO_DEFAULT_UART: u32 = 0;
pub const PICO_DEFAULT_UART_TX_PIN: u32 = 0;
pub const PICO_DEFAULT_UART_RX_PIN: u32 = 1;
pub const PICO_DEFAULT_I2C: u32 = 0;
pub const PICO_DEFAULT_I2C_SDA_PIN: u32 = 4;
pub const PICO_DEFAULT_I2C_SCL_PIN: u32 = 5;
pub const PICO_DEFAULT_SPI: u32 = 0;
pub const PICO_DEFAULT_SPI_SCK_PIN: u32 = 18;
pub const PICO_DEFAULT_SPI_TX_PIN: u32 = 19;
pub const PICO_DEFAULT_SPI_RX_PIN: u32 = 16;
pub const PICO_DEFAULT_SPI_CSN_PIN: u32 = 17;
pub const PICO_BOOT_STAGE2_CHOOSE_W25Q080: u32 = 1;
pub const PICO_FLASH_SPI_CLKDIV: u32 = 2;
pub const PICO_FLASH_SIZE_BYTES: u32 = 2097152;
pub const PICO_RP2040_B0_SUPPORTED: u32 = 0;
pub const PICO_RP2040_B1_SUPPORTED: u32 = 0;
pub const CYW43_PIN_WL_HOST_WAKE: u32 = 24;
pub const CYW43_PIN_WL_REG_ON: u32 = 23;
pub const CYW43_WL_GPIO_COUNT: u32 = 3;
pub const CYW43_WL_GPIO_LED_PIN: u32 = 0;
pub const VTABLE_FIRST_IRQ: u32 = 16;
pub const REG_ALIAS_RW_BITS: u32 = 0;
pub const REG_ALIAS_XOR_BITS: u32 = 4096;
pub const REG_ALIAS_SET_BITS: u32 = 8192;
pub const REG_ALIAS_CLR_BITS: u32 = 12288;
pub const SIO_CPUID_RESET: &[u8; 2usize] = b"-\0";
pub const SIO_CPUID_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_GPIO_IN_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_GPIO_HI_IN_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_GPIO_OUT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OUT_SET_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_OUT_CLR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_OUT_XOR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_OE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OE_SET_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_OE_CLR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_OE_XOR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_HI_OUT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OUT_SET_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_HI_OUT_CLR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_HI_OUT_XOR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_HI_OE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OE_SET_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_HI_OE_CLR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_GPIO_HI_OE_XOR_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_FIFO_ST_ROE_ACCESS: &[u8; 3usize] = b"WC\0";
pub const SIO_FIFO_ST_WOF_ACCESS: &[u8; 3usize] = b"WC\0";
pub const SIO_FIFO_ST_RDY_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_FIFO_ST_VLD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_FIFO_WR_ACCESS: &[u8; 3usize] = b"WF\0";
pub const SIO_FIFO_RD_RESET: &[u8; 2usize] = b"-\0";
pub const SIO_FIFO_RD_ACCESS: &[u8; 3usize] = b"RF\0";
pub const SIO_SPINLOCK_ST_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_DIV_UDIVIDEND_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_DIV_UDIVISOR_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_DIV_SDIVIDEND_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_DIV_SDIVISOR_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_DIV_QUOTIENT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_DIV_REMAINDER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_DIV_CSR_DIRTY_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_DIV_CSR_READY_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_ACCUM0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_ACCUM1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_POP_LANE0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_POP_LANE1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_POP_FULL_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_PEEK_LANE0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_PEEK_LANE1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_PEEK_FULL_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_BLEND_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_FORCE_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_ADD_RAW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_SIGNED_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_MASK_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_MASK_LSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_SHIFT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_FORCE_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_ADD_RAW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_SIGNED_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_MASK_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_MASK_LSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_SHIFT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_ACCUM0_ADD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_ACCUM1_ADD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE_1AND0_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_INTERP1_ACCUM0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_ACCUM1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_POP_LANE0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_POP_LANE1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_POP_FULL_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_PEEK_LANE0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_PEEK_LANE1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_PEEK_FULL_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_CLAMP_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_FORCE_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_ADD_RAW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_SIGNED_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_MASK_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_MASK_LSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_SHIFT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_FORCE_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_ADD_RAW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_SIGNED_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_MASK_MSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_MASK_LSB_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_SHIFT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_ACCUM0_ADD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_ACCUM1_ADD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE_1AND0_ACCESS: &[u8; 3usize] = b"WO\0";
pub const SIO_SPINLOCK0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK3_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK4_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK5_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK6_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK7_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK8_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK9_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK10_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK11_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK12_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK13_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK14_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK15_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK16_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK17_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK18_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK19_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK20_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK21_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK22_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK23_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK24_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK25_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK26_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK27_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK28_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK29_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK30_ACCESS: &[u8; 3usize] = b"RW\0";
pub const SIO_SPINLOCK31_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PICO_RP2040: u32 = 1;
pub const PICO_NO_RAM_VECTOR_TABLE: u32 = 0;
pub const PICO_FLOAT_SUPPORT_ROM_V1: u32 = 1;
pub const PICO_DOUBLE_SUPPORT_ROM_V1: u32 = 1;
pub const PICO_RP2040_B2_SUPPORTED: u32 = 1;
pub const PICO_NO_FPGA_CHECK: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_ADDRESS_ALIAS: u32 = 0;
pub const PADS_BANK0_VOLTAGE_SELECT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_OD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_IE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_DRIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_PUE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_PDE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_SCHMITT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_SLEWFAST_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO0_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO0_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO0_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO1_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO1_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO1_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO2_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO2_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO2_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO3_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO3_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO3_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO4_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO4_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO4_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO5_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO5_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO5_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO6_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO6_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO6_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO7_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO7_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO7_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO8_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO8_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO8_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO9_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO9_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO9_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO10_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO10_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO10_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO11_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO11_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO11_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO12_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO12_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO12_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO13_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO13_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO13_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO14_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO14_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO14_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO15_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO15_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO15_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO16_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO16_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO16_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO17_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO17_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO17_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO18_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO18_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO18_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO19_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO19_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO19_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO20_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO20_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO20_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO21_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO21_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO21_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO22_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO22_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO22_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO23_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO23_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO23_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO24_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO24_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO24_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO25_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO25_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO25_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO26_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO26_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO26_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO27_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO27_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO27_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO28_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO28_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO28_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO29_STATUS_IRQTOPROC_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_IRQFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_INTOPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_INFROMPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OETOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OEFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OUTTOPAD_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_STATUS_OUTFROMPERI_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_GPIO29_CTRL_IRQOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_INOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_OEOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_OUTOVER_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_GPIO29_CTRL_FUNCSEL_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_INTR0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"WC\0";
pub const IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_INTR3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RW\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const PICO_MAX_SHARED_IRQ_HANDLERS: u32 = 4;
pub const PICO_DISABLE_SHARED_IRQ_HANDLERS: u32 = 0;
pub const PICO_VTABLE_PER_CORE: u32 = 0;
pub const TIMER_IRQ_0: u32 = 0;
pub const TIMER_IRQ_1: u32 = 1;
pub const TIMER_IRQ_2: u32 = 2;
pub const TIMER_IRQ_3: u32 = 3;
pub const PWM_IRQ_WRAP: u32 = 4;
pub const USBCTRL_IRQ: u32 = 5;
pub const XIP_IRQ: u32 = 6;
pub const PIO0_IRQ_0: u32 = 7;
pub const PIO0_IRQ_1: u32 = 8;
pub const PIO1_IRQ_0: u32 = 9;
pub const PIO1_IRQ_1: u32 = 10;
pub const DMA_IRQ_0: u32 = 11;
pub const DMA_IRQ_1: u32 = 12;
pub const IO_IRQ_BANK0: u32 = 13;
pub const IO_IRQ_QSPI: u32 = 14;
pub const SIO_IRQ_PROC0: u32 = 15;
pub const SIO_IRQ_PROC1: u32 = 16;
pub const CLOCKS_IRQ: u32 = 17;
pub const SPI0_IRQ: u32 = 18;
pub const SPI1_IRQ: u32 = 19;
pub const UART0_IRQ: u32 = 20;
pub const UART1_IRQ: u32 = 21;
pub const ADC_IRQ_FIFO: u32 = 22;
pub const I2C0_IRQ: u32 = 23;
pub const I2C1_IRQ: u32 = 24;
pub const RTC_IRQ: u32 = 25;
pub const M0PLUS_SYST_CSR_COUNTFLAG_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_SYST_CSR_CLKSOURCE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CSR_TICKINT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CSR_ENABLE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_RVR_RELOAD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CVR_CURRENT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CALIB_NOREF_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_SYST_CALIB_SKEW_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_SYST_CALIB_TENMS_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_NVIC_ISER_SETENA_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_ICER_CLRENA_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_ISPR_SETPEND_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_ICPR_CLRPEND_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_3_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_7_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_6_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_5_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_4_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_11_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_10_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_9_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_8_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_15_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_14_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_13_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_12_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_19_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_18_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_17_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_16_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_23_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_22_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_21_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_20_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_27_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_26_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_25_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_24_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_31_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_30_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_29_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_28_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_CPUID_IMPLEMENTER_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_VARIANT_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_ARCHITECTURE_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_PARTNO_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_REVISION_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_NMIPENDSET_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSVSET_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSVCLR_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSTSET_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSTCLR_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_ISRPREEMPT_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_ISRPENDING_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_VECTPENDING_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_VECTACTIVE_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_VTOR_TBLOFF_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_AIRCR_VECTKEY_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_AIRCR_ENDIANESS_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_AIRCR_SYSRESETREQ_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_AIRCR_VECTCLRACTIVE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SCR_SEVONPEND_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SCR_SLEEPDEEP_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SCR_SLEEPONEXIT_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_CCR_STKALIGN_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_CCR_UNALIGN_TRP_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_SHPR2_PRI_11_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SHPR3_PRI_15_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SHPR3_PRI_14_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_SHCSR_SVCALLPENDED_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_TYPE_IREGION_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_MPU_TYPE_DREGION_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_MPU_TYPE_SEPARATE_ACCESS: &[u8; 3usize] = b"RO\0";
pub const M0PLUS_MPU_CTRL_PRIVDEFENA_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_CTRL_HFNMIENA_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_CTRL_ENABLE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RNR_REGION_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RBAR_ADDR_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RBAR_VALID_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RBAR_REGION_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_ATTRS_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_SRD_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_SIZE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_ENABLE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const PICO_DEFAULT_IRQ_PRIORITY: u32 = 128;
pub const PICO_LOWEST_IRQ_PRIORITY: u32 = 255;
pub const PICO_HIGHEST_IRQ_PRIORITY: u32 = 0;
pub const PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY: u32 = 128;
pub const PICO_SHARED_IRQ_HANDLER_HIGHEST_ORDER_PRIORITY: u32 = 255;
pub const PICO_SHARED_IRQ_HANDLER_LOWEST_ORDER_PRIORITY: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_IRQ: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_GPIO: u32 = 0;
pub const GPIO_OUT: u32 = 1;
pub const GPIO_IN: u32 = 0;
pub const GPIO_IRQ_CALLBACK_ORDER_PRIORITY: u32 = 0;
pub const GPIO_RAW_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY: u32 = 128;
pub const PICO_DEBUG_PIN_BASE: u32 = 19;
pub const PICO_DEBUG_PIN_COUNT: u32 = 3;
pub const TIMER_TIMEHW_ACCESS: &[u8; 3usize] = b"WF\0";
pub const TIMER_TIMELW_ACCESS: &[u8; 3usize] = b"WF\0";
pub const TIMER_TIMEHR_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_TIMELR_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_ALARM0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_ALARM1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_ALARM2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_ALARM3_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_ARMED_ACCESS: &[u8; 3usize] = b"WC\0";
pub const TIMER_TIMERAWH_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_TIMERAWL_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_DBGPAUSE_DBG1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_DBGPAUSE_DBG0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_PAUSE_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTR_ALARM_3_ACCESS: &[u8; 3usize] = b"WC\0";
pub const TIMER_INTR_ALARM_2_ACCESS: &[u8; 3usize] = b"WC\0";
pub const TIMER_INTR_ALARM_1_ACCESS: &[u8; 3usize] = b"WC\0";
pub const TIMER_INTR_ALARM_0_ACCESS: &[u8; 3usize] = b"WC\0";
pub const TIMER_INTE_ALARM_3_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTE_ALARM_2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTE_ALARM_1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTE_ALARM_0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_3_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_2_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_1_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_0_ACCESS: &[u8; 3usize] = b"RW\0";
pub const TIMER_INTS_ALARM_3_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_INTS_ALARM_2_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_INTS_ALARM_1_ACCESS: &[u8; 3usize] = b"RO\0";
pub const TIMER_INTS_ALARM_0_ACCESS: &[u8; 3usize] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_TIMER: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_TIME: u32 = 0;
pub const PICO_TIME_SLEEP_OVERHEAD_ADJUST_US: u32 = 6;
pub const PICO_TIME_DEFAULT_ALARM_POOL_DISABLED: u32 = 0;
pub const PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM: u32 = 3;
pub const PICO_TIME_DEFAULT_ALARM_POOL_MAX_TIMERS: u32 = 16;
pub const CYW43_HOST_NAME: &[u8; 6usize] = b"PicoW\0";
pub const CYW43_GPIO: u32 = 1;
pub const CYW43_LOGIC_DEBUG: u32 = 0;
pub const CYW43_USE_OTP_MAC: u32 = 1;
pub const CYW43_NO_NETUTILS: u32 = 1;
pub const CYW43_IOCTL_TIMEOUT_US: u32 = 1000000;
pub const CYW43_USE_STATS: u32 = 0;
pub const CYW43_HAL_MAC_WLAN0: u32 = 0;
pub const CYW43_USE_SPI: u32 = 1;
pub const CYW43_SPI_PIO: u32 = 1;
pub const CYW43_CHIPSET_FIRMWARE_INCLUDE_FILE: &[u8; 32usize] =
    b"wb43439A0_7_95_49_00_combined.h\0";
pub const CYW43_WIFI_NVRAM_INCLUDE_FILE: &[u8; 19usize] = b"wifi_nvram_43439.h\0";
pub const CYW43_NUM_GPIOS: u32 = 3;
pub const CYW43_HAL_PIN_MODE_INPUT: u32 = 0;
pub const CYW43_HAL_PIN_MODE_OUTPUT: u32 = 1;
pub const CYW43_HAL_PIN_PULL_NONE: u32 = 0;
pub const CYW43_HAL_PIN_PULL_UP: u32 = 1;
pub const CYW43_HAL_PIN_PULL_DOWN: u32 = 2;
pub const CYW43_CLEAR_SDIO_INT: u32 = 0;
pub const CYW43_SLEEP_MAX: u32 = 50;
pub const CYW43_NETUTILS: u32 = 0;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const CYW43_VERBOSE_DEBUG: u32 = 0;
pub const CYW43_IOCTL_GET_SSID: u32 = 50;
pub const CYW43_IOCTL_GET_CHANNEL: u32 = 58;
pub const CYW43_IOCTL_SET_DISASSOC: u32 = 105;
pub const CYW43_IOCTL_GET_ANTDIV: u32 = 126;
pub const CYW43_IOCTL_SET_ANTDIV: u32 = 129;
pub const CYW43_IOCTL_SET_MONITOR: u32 = 217;
pub const CYW43_IOCTL_GET_RSSI: u32 = 254;
pub const CYW43_IOCTL_GET_VAR: u32 = 524;
pub const CYW43_IOCTL_SET_VAR: u32 = 527;
pub const CYW43_EV_SET_SSID: u32 = 0;
pub const CYW43_EV_JOIN: u32 = 1;
pub const CYW43_EV_AUTH: u32 = 3;
pub const CYW43_EV_DEAUTH: u32 = 5;
pub const CYW43_EV_DEAUTH_IND: u32 = 6;
pub const CYW43_EV_ASSOC: u32 = 7;
pub const CYW43_EV_DISASSOC: u32 = 11;
pub const CYW43_EV_DISASSOC_IND: u32 = 12;
pub const CYW43_EV_LINK: u32 = 16;
pub const CYW43_EV_PRUNE: u32 = 23;
pub const CYW43_EV_PSK_SUP: u32 = 46;
pub const CYW43_EV_ESCAN_RESULT: u32 = 69;
pub const CYW43_EV_CSA_COMPLETE_IND: u32 = 80;
pub const CYW43_EV_ASSOC_REQ_IE: u32 = 87;
pub const CYW43_EV_ASSOC_RESP_IE: u32 = 88;
pub const CYW43_STATUS_SUCCESS: u32 = 0;
pub const CYW43_STATUS_FAIL: u32 = 1;
pub const CYW43_STATUS_TIMEOUT: u32 = 2;
pub const CYW43_STATUS_NO_NETWORKS: u32 = 3;
pub const CYW43_STATUS_ABORT: u32 = 4;
pub const CYW43_STATUS_NO_ACK: u32 = 5;
pub const CYW43_STATUS_UNSOLICITED: u32 = 6;
pub const CYW43_STATUS_ATTEMPT: u32 = 7;
pub const CYW43_STATUS_PARTIAL: u32 = 8;
pub const CYW43_STATUS_NEWSCAN: u32 = 9;
pub const CYW43_STATUS_NEWASSOC: u32 = 10;
pub const CYW43_SUP_DISCONNECTED: u32 = 0;
pub const CYW43_SUP_CONNECTING: u32 = 1;
pub const CYW43_SUP_IDREQUIRED: u32 = 2;
pub const CYW43_SUP_AUTHENTICATING: u32 = 3;
pub const CYW43_SUP_AUTHENTICATED: u32 = 4;
pub const CYW43_SUP_KEYXCHANGE: u32 = 5;
pub const CYW43_SUP_KEYED: u32 = 6;
pub const CYW43_SUP_TIMEOUT: u32 = 7;
pub const CYW43_SUP_LAST_BASIC_STATE: u32 = 8;
pub const CYW43_SUP_KEYXCHANGE_WAIT_M1: u32 = 4;
pub const CYW43_SUP_KEYXCHANGE_PREP_M2: u32 = 5;
pub const CYW43_SUP_KEYXCHANGE_WAIT_M3: u32 = 8;
pub const CYW43_SUP_KEYXCHANGE_PREP_M4: u32 = 9;
pub const CYW43_SUP_KEYXCHANGE_WAIT_G1: u32 = 10;
pub const CYW43_SUP_KEYXCHANGE_PREP_G2: u32 = 11;
pub const CYW43_REASON_INITIAL_ASSOC: u32 = 0;
pub const CYW43_REASON_LOW_RSSI: u32 = 1;
pub const CYW43_REASON_DEAUTH: u32 = 2;
pub const CYW43_REASON_DISASSOC: u32 = 3;
pub const CYW43_REASON_BCNS_LOST: u32 = 4;
pub const CYW43_REASON_FAST_ROAM_FAILED: u32 = 5;
pub const CYW43_REASON_DIRECTED_ROAM: u32 = 6;
pub const CYW43_REASON_TSPEC_REJECTED: u32 = 7;
pub const CYW43_REASON_BETTER_AP: u32 = 8;
pub const CYW43_REASON_PRUNE_ENCR_MISMATCH: u32 = 1;
pub const CYW43_REASON_PRUNE_BCAST_BSSID: u32 = 2;
pub const CYW43_REASON_PRUNE_MAC_DENY: u32 = 3;
pub const CYW43_REASON_PRUNE_MAC_NA: u32 = 4;
pub const CYW43_REASON_PRUNE_REG_PASSV: u32 = 5;
pub const CYW43_REASON_PRUNE_SPCT_MGMT: u32 = 6;
pub const CYW43_REASON_PRUNE_RADAR: u32 = 7;
pub const CYW43_REASON_RSN_MISMATCH: u32 = 8;
pub const CYW43_REASON_PRUNE_NO_COMMON_RATES: u32 = 9;
pub const CYW43_REASON_PRUNE_BASIC_RATES: u32 = 10;
pub const CYW43_REASON_PRUNE_CCXFAST_PREVAP: u32 = 11;
pub const CYW43_REASON_PRUNE_CIPHER_NA: u32 = 12;
pub const CYW43_REASON_PRUNE_KNOWN_STA: u32 = 13;
pub const CYW43_REASON_PRUNE_CCXFAST_DROAM: u32 = 14;
pub const CYW43_REASON_PRUNE_WDS_PEER: u32 = 15;
pub const CYW43_REASON_PRUNE_QBSS_LOAD: u32 = 16;
pub const CYW43_REASON_PRUNE_HOME_AP: u32 = 17;
pub const CYW43_REASON_PRUNE_AP_BLOCKED: u32 = 18;
pub const CYW43_REASON_PRUNE_NO_DIAG_SUPPORT: u32 = 19;
pub const CYW43_REASON_SUP_OTHER: u32 = 0;
pub const CYW43_REASON_SUP_DECRYPT_KEY_DATA: u32 = 1;
pub const CYW43_REASON_SUP_BAD_UCAST_WEP128: u32 = 2;
pub const CYW43_REASON_SUP_BAD_UCAST_WEP40: u32 = 3;
pub const CYW43_REASON_SUP_UNSUP_KEY_LEN: u32 = 4;
pub const CYW43_REASON_SUP_PW_KEY_CIPHER: u32 = 5;
pub const CYW43_REASON_SUP_MSG3_TOO_MANY_IE: u32 = 6;
pub const CYW43_REASON_SUP_MSG3_IE_MISMATCH: u32 = 7;
pub const CYW43_REASON_SUP_NO_INSTALL_FLAG: u32 = 8;
pub const CYW43_REASON_SUP_MSG3_NO_GTK: u32 = 9;
pub const CYW43_REASON_SUP_GRP_KEY_CIPHER: u32 = 10;
pub const CYW43_REASON_SUP_GRP_MSG1_NO_GTK: u32 = 11;
pub const CYW43_REASON_SUP_GTK_DECRYPT_FAIL: u32 = 12;
pub const CYW43_REASON_SUP_SEND_FAIL: u32 = 13;
pub const CYW43_REASON_SUP_DEAUTH: u32 = 14;
pub const CYW43_REASON_SUP_WPA_PSK_TMO: u32 = 15;
pub const CYW43_WPA_AUTH_PSK: u32 = 4;
pub const CYW43_WPA2_AUTH_PSK: u32 = 128;
pub const CYW43_AUTH_OPEN: u32 = 0;
pub const CYW43_AUTH_WPA_TKIP_PSK: u32 = 2097154;
pub const CYW43_AUTH_WPA2_AES_PSK: u32 = 4194308;
pub const CYW43_AUTH_WPA2_MIXED_PSK: u32 = 4194310;
pub const CYW43_NO_POWERSAVE_MODE: u32 = 0;
pub const CYW43_PM1_POWERSAVE_MODE: u32 = 1;
pub const CYW43_PM2_POWERSAVE_MODE: u32 = 2;
pub const CYW43_BUS_MAX_BLOCK_SIZE: u32 = 64;
pub const CYW43_CHANNEL_NONE: u32 = 4294967295;
pub const CYW43_TRACE_ASYNC_EV: u32 = 1;
pub const CYW43_TRACE_ETH_TX: u32 = 2;
pub const CYW43_TRACE_ETH_RX: u32 = 4;
pub const CYW43_TRACE_ETH_FULL: u32 = 8;
pub const CYW43_TRACE_MAC: u32 = 16;
pub const CYW43_LINK_DOWN: u32 = 0;
pub const CYW43_LINK_JOIN: u32 = 1;
pub const CYW43_LINK_NOIP: u32 = 2;
pub const CYW43_LINK_UP: u32 = 3;
pub const CYW43_LINK_FAIL: i32 = -1;
pub const CYW43_LINK_NONET: i32 = -2;
pub const CYW43_LINK_BADAUTH: i32 = -3;
pub const ASYNC_CONTEXT_FLAG_CALLBACK_FROM_NON_IRQ: u32 = 1;
pub const ASYNC_CONTEXT_FLAG_CALLBACK_FROM_IRQ: u32 = 2;
pub const ASYNC_CONTEXT_FLAG_POLLED: u32 = 4;
pub const PARAM_ASSERTIONS_ENABLED_CYW43_ARCH: u32 = 0;
pub const PICO_CYW43_ARCH_DEBUG_ENABLED: u32 = 1;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ad_context {
    pub data: *const u8,
    pub offset: u8,
    pub length: u8,
}
pub type ad_context_t = ad_context;
extern "C" {
    pub fn ad_iterator_init(context: *mut ad_context_t, ad_len: u8, ad_data: *const u8);
}
extern "C" {
    pub fn ad_iterator_has_more(context: *const ad_context_t) -> bool;
}
extern "C" {
    pub fn ad_iterator_next(context: *mut ad_context_t);
}
extern "C" {
    pub fn ad_iterator_get_data_type(context: *const ad_context_t) -> u8;
}
extern "C" {
    pub fn ad_iterator_get_data_len(context: *const ad_context_t) -> u8;
}
extern "C" {
    pub fn ad_iterator_get_data(context: *const ad_context_t) -> *const u8;
}
extern "C" {
    pub fn ad_data_contains_uuid16(ad_len: u8, ad_data: *const u8, uuid16: u16) -> bool;
}
extern "C" {
    pub fn ad_data_contains_uuid128(ad_len: u8, ad_data: *const u8, uuid128: *const u8) -> bool;
}
#[doc = " @brief hci connection handle type"]
pub type hci_con_handle_t = u16;
#[doc = " @brief Bluetooth address"]
pub type bd_addr_t = [u8; 6usize];
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_LE_PUBLIC: bd_addr_type_t = bd_addr_type_t(0);
}
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_LE_RANDOM: bd_addr_type_t = bd_addr_type_t(1);
}
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_LE_PUBLIC_IDENTITY: bd_addr_type_t = bd_addr_type_t(2);
}
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_LE_RANDOM_IDENTITY: bd_addr_type_t = bd_addr_type_t(3);
}
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_SCO: bd_addr_type_t = bd_addr_type_t(252);
}
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_ACL: bd_addr_type_t = bd_addr_type_t(253);
}
impl bd_addr_type_t {
    pub const BD_ADDR_TYPE_UNKNOWN: bd_addr_type_t = bd_addr_type_t(254);
}
impl ::core::ops::BitOr<bd_addr_type_t> for bd_addr_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        bd_addr_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for bd_addr_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: bd_addr_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<bd_addr_type_t> for bd_addr_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        bd_addr_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for bd_addr_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: bd_addr_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Address types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct bd_addr_type_t(pub cty::c_uint);
impl hci_link_type_t {
    pub const HCI_LINK_TYPE_SCO: hci_link_type_t = hci_link_type_t(0);
}
impl hci_link_type_t {
    pub const HCI_LINK_TYPE_ACL: hci_link_type_t = hci_link_type_t(1);
}
impl hci_link_type_t {
    pub const HCI_LINK_TYPE_ESCO: hci_link_type_t = hci_link_type_t(2);
}
impl ::core::ops::BitOr<hci_link_type_t> for hci_link_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_link_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_link_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_link_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_link_type_t> for hci_link_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_link_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_link_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_link_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Link types for BR/EDR Connections"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_link_type_t(pub cty::c_uint);
pub type link_key_t = [u8; 16usize];
impl link_key_type_t {
    pub const INVALID_LINK_KEY: link_key_type_t = link_key_type_t(65535);
}
impl link_key_type_t {
    pub const COMBINATION_KEY: link_key_type_t = link_key_type_t(0);
}
impl link_key_type_t {
    pub const LOCAL_UNIT_KEY: link_key_type_t = link_key_type_t(1);
}
impl link_key_type_t {
    pub const REMOTE_UNIT_KEY: link_key_type_t = link_key_type_t(2);
}
impl link_key_type_t {
    pub const DEBUG_COMBINATION_KEY: link_key_type_t = link_key_type_t(3);
}
impl link_key_type_t {
    pub const UNAUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P192: link_key_type_t =
        link_key_type_t(4);
}
impl link_key_type_t {
    pub const AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P192: link_key_type_t =
        link_key_type_t(5);
}
impl link_key_type_t {
    pub const CHANGED_COMBINATION_KEY: link_key_type_t = link_key_type_t(6);
}
impl link_key_type_t {
    pub const UNAUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256: link_key_type_t =
        link_key_type_t(7);
}
impl link_key_type_t {
    pub const AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256: link_key_type_t =
        link_key_type_t(8);
}
impl ::core::ops::BitOr<link_key_type_t> for link_key_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        link_key_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for link_key_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: link_key_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<link_key_type_t> for link_key_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        link_key_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for link_key_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: link_key_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @brief link key type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct link_key_type_t(pub cty::c_uint);
impl le_privacy_mode_t {
    pub const LE_PRIVACY_MODE_NETWORK: le_privacy_mode_t = le_privacy_mode_t(0);
}
impl le_privacy_mode_t {
    pub const LE_PRIVACY_MODE_DEVICE: le_privacy_mode_t = le_privacy_mode_t(1);
}
impl ::core::ops::BitOr<le_privacy_mode_t> for le_privacy_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_privacy_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_privacy_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_privacy_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_privacy_mode_t> for le_privacy_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_privacy_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_privacy_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_privacy_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " LE Privacy 1.2"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_privacy_mode_t(pub cty::c_uint);
impl inquiry_mode_t {
    pub const INQUIRY_MODE_STANDARD: inquiry_mode_t = inquiry_mode_t(0);
}
impl inquiry_mode_t {
    pub const INQUIRY_MODE_RSSI: inquiry_mode_t = inquiry_mode_t(1);
}
impl inquiry_mode_t {
    pub const INQUIRY_MODE_RSSI_AND_EIR: inquiry_mode_t = inquiry_mode_t(2);
}
impl ::core::ops::BitOr<inquiry_mode_t> for inquiry_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        inquiry_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for inquiry_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: inquiry_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<inquiry_mode_t> for inquiry_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        inquiry_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for inquiry_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: inquiry_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @brief Inquiry modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct inquiry_mode_t(pub cty::c_uint);
impl page_scan_type_t {
    pub const PAGE_SCAN_MODE_STANDARD: page_scan_type_t = page_scan_type_t(0);
}
impl page_scan_type_t {
    pub const PAGE_SCAN_MODE_INTERLACED: page_scan_type_t = page_scan_type_t(1);
}
impl ::core::ops::BitOr<page_scan_type_t> for page_scan_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        page_scan_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for page_scan_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: page_scan_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<page_scan_type_t> for page_scan_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        page_scan_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for page_scan_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: page_scan_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @brief Page Scan Types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct page_scan_type_t(pub cty::c_uint);
impl inquiry_scan_type_t {
    pub const INQUIRY_SCAN_MODE_STANDARD: inquiry_scan_type_t = inquiry_scan_type_t(0);
}
impl inquiry_scan_type_t {
    pub const INQUIRY_SCAN_MODE_INTERLACED: inquiry_scan_type_t = inquiry_scan_type_t(1);
}
impl ::core::ops::BitOr<inquiry_scan_type_t> for inquiry_scan_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        inquiry_scan_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for inquiry_scan_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: inquiry_scan_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<inquiry_scan_type_t> for inquiry_scan_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        inquiry_scan_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for inquiry_scan_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: inquiry_scan_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @brief Inquiry Scan Types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct inquiry_scan_type_t(pub cty::c_uint);
impl hci_service_type_t {
    pub const HCI_SERVICE_TYPE_NO_TRAFFIC: hci_service_type_t = hci_service_type_t(0);
}
impl hci_service_type_t {
    pub const HCI_SERVICE_TYPE_BEST_EFFORT: hci_service_type_t = hci_service_type_t(1);
}
impl hci_service_type_t {
    pub const HCI_SERVICE_TYPE_GUARANTEED: hci_service_type_t = hci_service_type_t(2);
}
impl hci_service_type_t {
    pub const HCI_SERVICE_TYPE_INVALID: hci_service_type_t = hci_service_type_t(3);
}
impl ::core::ops::BitOr<hci_service_type_t> for hci_service_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_service_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_service_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_service_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_service_type_t> for hci_service_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_service_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_service_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_service_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Service Type used for QoS Setup and Flow Specification"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_service_type_t(pub cty::c_uint);
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_U_LAW_LOG: hci_audio_coding_format_t =
        hci_audio_coding_format_t(0);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_A_LAW_LOG: hci_audio_coding_format_t =
        hci_audio_coding_format_t(1);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_CVSD: hci_audio_coding_format_t =
        hci_audio_coding_format_t(2);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_TRANSPARENT: hci_audio_coding_format_t =
        hci_audio_coding_format_t(3);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_LINEAR_PCM: hci_audio_coding_format_t =
        hci_audio_coding_format_t(4);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_MSBC: hci_audio_coding_format_t =
        hci_audio_coding_format_t(5);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_LC3: hci_audio_coding_format_t = hci_audio_coding_format_t(6);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_G_729A: hci_audio_coding_format_t =
        hci_audio_coding_format_t(7);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_RFU: hci_audio_coding_format_t = hci_audio_coding_format_t(8);
}
impl hci_audio_coding_format_t {
    pub const HCI_AUDIO_CODING_FORMAT_VENDOR_SPECIFIC: hci_audio_coding_format_t =
        hci_audio_coding_format_t(255);
}
impl ::core::ops::BitOr<hci_audio_coding_format_t> for hci_audio_coding_format_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_audio_coding_format_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_audio_coding_format_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_audio_coding_format_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_audio_coding_format_t> for hci_audio_coding_format_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_audio_coding_format_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_audio_coding_format_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_audio_coding_format_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Other assigned numbers, Assigned_Numbers_Host Controller Interface.pdf"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_audio_coding_format_t(pub cty::c_uint);
impl hci_role_t {
    pub const HCI_ROLE_MASTER: hci_role_t = hci_role_t(0);
}
impl hci_role_t {
    pub const HCI_ROLE_SLAVE: hci_role_t = hci_role_t(1);
}
impl hci_role_t {
    pub const HCI_ROLE_INVALID: hci_role_t = hci_role_t(255);
}
impl ::core::ops::BitOr<hci_role_t> for hci_role_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_role_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_role_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_role_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_role_t> for hci_role_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_role_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_role_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_role_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_role_t(pub cty::c_uint);
impl rpn_baud {
    pub const RPN_BAUD_2400: rpn_baud = rpn_baud(0);
}
impl rpn_baud {
    pub const RPN_BAUD_4800: rpn_baud = rpn_baud(1);
}
impl rpn_baud {
    pub const RPN_BAUD_7200: rpn_baud = rpn_baud(2);
}
impl rpn_baud {
    pub const RPN_BAUD_9600: rpn_baud = rpn_baud(3);
}
impl rpn_baud {
    pub const RPN_BAUD_19200: rpn_baud = rpn_baud(4);
}
impl rpn_baud {
    pub const RPN_BAUD_38400: rpn_baud = rpn_baud(5);
}
impl rpn_baud {
    pub const RPN_BAUD_57600: rpn_baud = rpn_baud(6);
}
impl rpn_baud {
    pub const RPN_BAUD_115200: rpn_baud = rpn_baud(7);
}
impl rpn_baud {
    pub const RPN_BAUD_230400: rpn_baud = rpn_baud(8);
}
impl ::core::ops::BitOr<rpn_baud> for rpn_baud {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        rpn_baud(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for rpn_baud {
    #[inline]
    fn bitor_assign(&mut self, rhs: rpn_baud) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<rpn_baud> for rpn_baud {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        rpn_baud(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for rpn_baud {
    #[inline]
    fn bitand_assign(&mut self, rhs: rpn_baud) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rpn_baud(pub cty::c_uint);
pub use self::rpn_baud as rpn_baud_t;
impl rpn_data_bits {
    pub const RPN_DATA_BITS_5: rpn_data_bits = rpn_data_bits(0);
}
impl rpn_data_bits {
    pub const RPN_DATA_BITS_6: rpn_data_bits = rpn_data_bits(0);
}
impl rpn_data_bits {
    pub const RPN_DATA_BITS_7: rpn_data_bits = rpn_data_bits(0);
}
impl rpn_data_bits {
    pub const RPN_DATA_BITS_8: rpn_data_bits = rpn_data_bits(0);
}
impl ::core::ops::BitOr<rpn_data_bits> for rpn_data_bits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        rpn_data_bits(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for rpn_data_bits {
    #[inline]
    fn bitor_assign(&mut self, rhs: rpn_data_bits) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<rpn_data_bits> for rpn_data_bits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        rpn_data_bits(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for rpn_data_bits {
    #[inline]
    fn bitand_assign(&mut self, rhs: rpn_data_bits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rpn_data_bits(pub cty::c_uint);
pub use self::rpn_data_bits as rpn_data_bits_t;
impl rpn_stop_bits {
    pub const RPN_STOP_BITS_1_0: rpn_stop_bits = rpn_stop_bits(0);
}
impl rpn_stop_bits {
    pub const RPN_STOP_BITS_1_5: rpn_stop_bits = rpn_stop_bits(1);
}
impl ::core::ops::BitOr<rpn_stop_bits> for rpn_stop_bits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        rpn_stop_bits(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for rpn_stop_bits {
    #[inline]
    fn bitor_assign(&mut self, rhs: rpn_stop_bits) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<rpn_stop_bits> for rpn_stop_bits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        rpn_stop_bits(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for rpn_stop_bits {
    #[inline]
    fn bitand_assign(&mut self, rhs: rpn_stop_bits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rpn_stop_bits(pub cty::c_uint);
pub use self::rpn_stop_bits as rpn_stop_bits_t;
impl rpn_parity {
    pub const RPN_PARITY_NONE: rpn_parity = rpn_parity(0);
}
impl rpn_parity {
    pub const RPN_PARITY_ODD: rpn_parity = rpn_parity(1);
}
impl rpn_parity {
    pub const RPN_PARITY_EVEN: rpn_parity = rpn_parity(3);
}
impl rpn_parity {
    pub const RPN_PARITY_MARK: rpn_parity = rpn_parity(5);
}
impl rpn_parity {
    pub const RPN_PARITY_SPACE: rpn_parity = rpn_parity(7);
}
impl ::core::ops::BitOr<rpn_parity> for rpn_parity {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        rpn_parity(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for rpn_parity {
    #[inline]
    fn bitor_assign(&mut self, rhs: rpn_parity) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<rpn_parity> for rpn_parity {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        rpn_parity(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for rpn_parity {
    #[inline]
    fn bitand_assign(&mut self, rhs: rpn_parity) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct rpn_parity(pub cty::c_uint);
pub use self::rpn_parity as rpn_parity_t;
impl security_description_t {
    pub const BNEP_SECURITY_NONE: security_description_t = security_description_t(0);
}
impl security_description_t {
    pub const BNEP_SECURITY_SERVICE_LEVEL_ENFORCED: security_description_t =
        security_description_t(1);
}
impl security_description_t {
    pub const BNEP_SECURITY_802_1X: security_description_t = security_description_t(2);
}
impl ::core::ops::BitOr<security_description_t> for security_description_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        security_description_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for security_description_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: security_description_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<security_description_t> for security_description_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        security_description_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for security_description_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: security_description_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " PAN Profile"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct security_description_t(pub cty::c_uint);
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_PSTN: net_access_type_t = net_access_type_t(0);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_ISDN: net_access_type_t = net_access_type_t(1);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_DSL: net_access_type_t = net_access_type_t(2);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_CABLE_MODEM: net_access_type_t = net_access_type_t(3);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_10MB_ETHERNET: net_access_type_t = net_access_type_t(4);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_100MB_ETHERNET: net_access_type_t = net_access_type_t(5);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_4MB_TOKEN_RING: net_access_type_t = net_access_type_t(6);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_16MB_TOKEN_RING: net_access_type_t = net_access_type_t(7);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_100MB_TOKEN_RING: net_access_type_t = net_access_type_t(8);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_FDDI: net_access_type_t = net_access_type_t(9);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_GSM: net_access_type_t = net_access_type_t(10);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_CDMA: net_access_type_t = net_access_type_t(11);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_GPRS: net_access_type_t = net_access_type_t(12);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_3G: net_access_type_t = net_access_type_t(13);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_CELULAR: net_access_type_t = net_access_type_t(14);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_OTHER: net_access_type_t = net_access_type_t(65534);
}
impl net_access_type_t {
    pub const PAN_NET_ACCESS_TYPE_NONE: net_access_type_t = net_access_type_t(65535);
}
impl ::core::ops::BitOr<net_access_type_t> for net_access_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        net_access_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for net_access_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: net_access_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<net_access_type_t> for net_access_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        net_access_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for net_access_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: net_access_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct net_access_type_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gatt_date_time_t {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hours: u8,
    pub minutes: u8,
    pub seconds: u8,
}
impl gatt_microphone_control_mute_t {
    pub const GATT_MICROPHONE_CONTROL_MUTE_OFF: gatt_microphone_control_mute_t =
        gatt_microphone_control_mute_t(0);
}
impl gatt_microphone_control_mute_t {
    pub const GATT_MICROPHONE_CONTROL_MUTE_ON: gatt_microphone_control_mute_t =
        gatt_microphone_control_mute_t(1);
}
impl gatt_microphone_control_mute_t {
    pub const GATT_MICROPHONE_CONTROL_MUTE_DISABLED: gatt_microphone_control_mute_t =
        gatt_microphone_control_mute_t(2);
}
impl ::core::ops::BitOr<gatt_microphone_control_mute_t> for gatt_microphone_control_mute_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gatt_microphone_control_mute_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gatt_microphone_control_mute_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gatt_microphone_control_mute_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gatt_microphone_control_mute_t> for gatt_microphone_control_mute_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gatt_microphone_control_mute_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gatt_microphone_control_mute_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gatt_microphone_control_mute_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gatt_microphone_control_mute_t(pub cty::c_uint);
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_REQUEST: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(1);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_RESPONSE: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(2);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_CONFIRM: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(3);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_RANDOM: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(4);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_FAILED: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(5);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_ENCRYPTION_INFORMATION: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(6);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_MASTER_IDENTIFICATION: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(7);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_IDENTITY_INFORMATION: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(8);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_IDENTITY_ADDRESS_INFORMATION: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(9);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_SIGNING_INFORMATION: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(10);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_SECURITY_REQUEST: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(11);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_PUBLIC_KEY: SECURITY_MANAGER_COMMANDS = SECURITY_MANAGER_COMMANDS(12);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_PAIRING_DHKEY_CHECK: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(13);
}
impl SECURITY_MANAGER_COMMANDS {
    pub const SM_CODE_KEYPRESS_NOTIFICATION: SECURITY_MANAGER_COMMANDS =
        SECURITY_MANAGER_COMMANDS(14);
}
impl ::core::ops::BitOr<SECURITY_MANAGER_COMMANDS> for SECURITY_MANAGER_COMMANDS {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        SECURITY_MANAGER_COMMANDS(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for SECURITY_MANAGER_COMMANDS {
    #[inline]
    fn bitor_assign(&mut self, rhs: SECURITY_MANAGER_COMMANDS) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<SECURITY_MANAGER_COMMANDS> for SECURITY_MANAGER_COMMANDS {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        SECURITY_MANAGER_COMMANDS(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for SECURITY_MANAGER_COMMANDS {
    #[inline]
    fn bitand_assign(&mut self, rhs: SECURITY_MANAGER_COMMANDS) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " SM - LE Security Manager"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SECURITY_MANAGER_COMMANDS(pub cty::c_uint);
impl io_capability_t {
    pub const IO_CAPABILITY_DISPLAY_ONLY: io_capability_t = io_capability_t(0);
}
impl io_capability_t {
    pub const IO_CAPABILITY_DISPLAY_YES_NO: io_capability_t = io_capability_t(1);
}
impl io_capability_t {
    pub const IO_CAPABILITY_KEYBOARD_ONLY: io_capability_t = io_capability_t(2);
}
impl io_capability_t {
    pub const IO_CAPABILITY_NO_INPUT_NO_OUTPUT: io_capability_t = io_capability_t(3);
}
impl io_capability_t {
    pub const IO_CAPABILITY_KEYBOARD_DISPLAY: io_capability_t = io_capability_t(4);
}
impl ::core::ops::BitOr<io_capability_t> for io_capability_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        io_capability_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for io_capability_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: io_capability_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<io_capability_t> for io_capability_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        io_capability_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for io_capability_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: io_capability_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct io_capability_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_audio_sink_t {
    #[doc = " @brief Setup audio codec for specified samplerate and number of channels\n @param Channels (1=mono, 2=stereo)\n @param Sample rate\n @param Playback callback\n @return 1 on success"]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            channels: u8,
            samplerate: u32,
            playback: ::core::option::Option<
                unsafe extern "C" fn(buffer: *mut i16, num_samples: u16),
            >,
        ) -> cty::c_int,
    >,
    #[doc = " @brief Get the current playback sample rate, may differ from the\n        specified sample rate"]
    pub get_samplerate: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    #[doc = " @brief Set volume\n @param Volume 0..127"]
    pub set_volume: ::core::option::Option<unsafe extern "C" fn(volume: u8)>,
    #[doc = " @brief Start stream"]
    pub start_stream: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Stop stream"]
    pub stop_stream: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Close audio codec"]
    pub close: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_audio_source_t {
    #[doc = " @brief Setup audio codec for specified samplerate and number of channels\n @param Channels (1=mono, 2=stereo)\n @param Sample rate\n @param Recording callback\n @return 1 on success"]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            channels: u8,
            samplerate: u32,
            recording: ::core::option::Option<
                unsafe extern "C" fn(buffer: *const i16, num_samples: u16),
            >,
        ) -> cty::c_int,
    >,
    #[doc = " @brief Get the current recording sample rate, may differ from the\n        specified sameple rate"]
    pub get_samplerate: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    #[doc = " @brief Set Gain\n @param Gain 0..127"]
    pub set_gain: ::core::option::Option<unsafe extern "C" fn(gain: u8)>,
    #[doc = " @brief Start stream"]
    pub start_stream: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Stop stream"]
    pub stop_stream: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " @brief Close audio codec"]
    pub close: ::core::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    #[doc = " @brief Get BTstack Audio Sink Instance\n @return btstack_audio_sink implementation"]
    pub fn btstack_audio_sink_get_instance() -> *const btstack_audio_sink_t;
}
extern "C" {
    #[doc = " @brief Get BTstack Audio Source Instance\n @return btstack_audio_source implementation"]
    pub fn btstack_audio_source_get_instance() -> *const btstack_audio_source_t;
}
extern "C" {
    #[doc = " @brief Get BTstack Audio Sink Instance\n @param btstack_audio_sink implementation"]
    pub fn btstack_audio_sink_set_instance(audio_sink_impl: *const btstack_audio_sink_t);
}
extern "C" {
    #[doc = " @brief Get BTstack Audio Source Instance\n @param btstack_audio_source implementation"]
    pub fn btstack_audio_source_set_instance(audio_source_impl: *const btstack_audio_source_t);
}
extern "C" {
    pub fn btstack_audio_portaudio_sink_get_instance() -> *const btstack_audio_sink_t;
}
extern "C" {
    pub fn btstack_audio_portaudio_source_get_instance() -> *const btstack_audio_source_t;
}
extern "C" {
    pub fn btstack_audio_embedded_sink_get_instance() -> *const btstack_audio_sink_t;
}
extern "C" {
    pub fn btstack_audio_embedded_source_get_instance() -> *const btstack_audio_source_t;
}
extern "C" {
    pub fn btstack_audio_esp32_sink_get_instance() -> *const btstack_audio_sink_t;
}
extern "C" {
    pub fn btstack_audio_esp32_source_get_instance() -> *const btstack_audio_source_t;
}
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type wint_t = cty::c_int;
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = cty::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type _fpos_t = cty::c_long;
pub type __size_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
}
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __daddr_t = cty::c_long;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __va_list = u32;
pub type __ULong = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: cty::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: cty::c_int,
    pub _emergency: [cty::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: cty::c_int,
    pub _cvtbuf: *mut cty::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut cty::c_char,
    pub _asctime_buf: [cty::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: cty::c_int,
    pub _rand_next: cty::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _signal_buf: [cty::c_char; 24usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: cty::c_int,
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> cty::c_int,
        >,
        arg3: *mut _glue,
    ) -> cty::c_int;
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const cty::c_void, arg2: *mut cty::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut cty::c_void, arg2: cty::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut cty::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn fls(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn flsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn flsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn index(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const cty::c_void,
        arg2: cty::c_int,
        arg3: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut cty::c_void, arg2: cty::c_int, arg3: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strerror(arg1: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strstr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: cty::c_int, arg2: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_int,
        arg4: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const cty::c_char, arg2: cty::c_uint) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strndup_r(arg1: *mut _reent, arg2: *const cty::c_char, arg3: usize)
        -> *mut cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: usize) -> cty::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const cty::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: usize,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__signo: cty::c_int) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_linked_item {
    pub next: *mut btstack_linked_item,
}
pub type btstack_linked_item_t = btstack_linked_item;
pub type btstack_linked_list_t = *mut btstack_linked_item_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_linked_list_iterator_t {
    pub advance_on_next: cty::c_int,
    pub prev: *mut btstack_linked_item_t,
    pub curr: *mut btstack_linked_item_t,
}
extern "C" {
    #[doc = " @brief Test if list is empty.\n @param list\n @return true if list is empty"]
    pub fn btstack_linked_list_empty(list: *mut btstack_linked_list_t) -> bool;
}
extern "C" {
    #[doc = " @brief Add item to list as first element.\n @param list\n @param item\n @return true if item was added, false if item already in list"]
    pub fn btstack_linked_list_add(
        list: *mut btstack_linked_list_t,
        item: *mut btstack_linked_item_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Add item to list as last element.\n @param list\n @param item\n @return true if item was added, false if item already in list"]
    pub fn btstack_linked_list_add_tail(
        list: *mut btstack_linked_list_t,
        item: *mut btstack_linked_item_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Pop (get + remove) first element.\n @param list\n @return first element or NULL if list is empty"]
    pub fn btstack_linked_list_pop(list: *mut btstack_linked_list_t) -> *mut btstack_linked_item_t;
}
extern "C" {
    #[doc = " @brief Remove item from list\n @param list\n @param item\n @return true if item was removed, false if it is no't in list"]
    pub fn btstack_linked_list_remove(
        list: *mut btstack_linked_list_t,
        item: *mut btstack_linked_item_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get first element.\n @param list\n @return first element or NULL if list is empty"]
    pub fn btstack_linked_list_get_first_item(
        list: *mut btstack_linked_list_t,
    ) -> *mut btstack_linked_item_t;
}
extern "C" {
    #[doc = " @brief Get last element.\n @param list\n @return first element or NULL if list is empty"]
    pub fn btstack_linked_list_get_last_item(
        list: *mut btstack_linked_list_t,
    ) -> *mut btstack_linked_item_t;
}
extern "C" {
    #[doc = " @brief Counts number of items in list\n @return number of items in list"]
    pub fn btstack_linked_list_count(list: *mut btstack_linked_list_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Initialize Linked List Iterator\n @note robust against removal of current element by btstack_linked_list_remove\n @param it iterator context\n @param list"]
    pub fn btstack_linked_list_iterator_init(
        it: *mut btstack_linked_list_iterator_t,
        list: *mut btstack_linked_list_t,
    );
}
extern "C" {
    #[doc = " @brief Has next element\n @param it iterator context\n @return true if next element is available"]
    pub fn btstack_linked_list_iterator_has_next(it: *mut btstack_linked_list_iterator_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get next list eleemnt\n @param it iterator context\n @return list element"]
    pub fn btstack_linked_list_iterator_next(
        it: *mut btstack_linked_list_iterator_t,
    ) -> *mut btstack_linked_item_t;
}
extern "C" {
    #[doc = " @brief Remove current list element from list\n @param it iterator context"]
    pub fn btstack_linked_list_iterator_remove(it: *mut btstack_linked_list_iterator_t);
}
extern "C" {
    pub fn test_linked_list();
}
pub type btstack_packet_handler_t = ::core::option::Option<
    unsafe extern "C" fn(packet_type: u8, channel: u16, packet: *mut u8, size: u16),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_packet_callback_registration_t {
    pub item: btstack_linked_item_t,
    pub callback: btstack_packet_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_context_callback_registration_t {
    pub item: *mut btstack_linked_item_t,
    pub callback: ::core::option::Option<unsafe extern "C" fn(context: *mut cty::c_void)>,
    pub context: *mut cty::c_void,
}
#[doc = " @brief 128 bit key used with AES128 in Security Manager"]
pub type sm_key_t = [u8; 16usize];
pub type device_name_t = [u8; 249usize];
extern "C" {
    #[doc = " @brief Minimum function for uint32_t\n @param a\n @param b\n @return value"]
    pub fn btstack_min(a: u32, b: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Maximum function for uint32_t\n @param a\n @param b\n @return value"]
    pub fn btstack_max(a: u32, b: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Calculate delta between two uint32_t points in time\n @return time_a - time_b - result > 0 if time_a is newer than time_b"]
    pub fn btstack_time_delta(time_a: u32, time_b: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Calculate delta between two uint16_t points in time\n @return time_a - time_b - result > 0 if time_a is newer than time_b"]
    pub fn btstack_time16_delta(time_a: u16, time_b: u16) -> i16;
}
extern "C" {
    #[doc = " @brief Read 16/24/32 bit little endian value from buffer\n @param buffer\n @param position in buffer\n @return value"]
    pub fn little_endian_read_16(buffer: *const u8, position: cty::c_int) -> u16;
}
extern "C" {
    pub fn little_endian_read_24(buffer: *const u8, position: cty::c_int) -> u32;
}
extern "C" {
    pub fn little_endian_read_32(buffer: *const u8, position: cty::c_int) -> u32;
}
extern "C" {
    #[doc = " @brief Write 16/32 bit little endian value into buffer\n @param buffer\n @param position in buffer\n @param value"]
    pub fn little_endian_store_16(buffer: *mut u8, position: u16, value: u16);
}
extern "C" {
    pub fn little_endian_store_24(buffer: *mut u8, position: u16, value: u32);
}
extern "C" {
    pub fn little_endian_store_32(buffer: *mut u8, position: u16, value: u32);
}
extern "C" {
    #[doc = " @brief Read 16/24/32 bit big endian value from buffer\n @param buffer\n @param position in buffer\n @return value"]
    pub fn big_endian_read_16(buffer: *const u8, position: cty::c_int) -> u32;
}
extern "C" {
    pub fn big_endian_read_24(buffer: *const u8, position: cty::c_int) -> u32;
}
extern "C" {
    pub fn big_endian_read_32(buffer: *const u8, position: cty::c_int) -> u32;
}
extern "C" {
    #[doc = " @brief Write 16/32 bit big endian value into buffer\n @param buffer\n @param position in buffer\n @param value"]
    pub fn big_endian_store_16(buffer: *mut u8, position: u16, value: u16);
}
extern "C" {
    pub fn big_endian_store_24(buffer: *mut u8, position: u16, value: u32);
}
extern "C" {
    pub fn big_endian_store_32(buffer: *mut u8, position: u16, value: u32);
}
extern "C" {
    #[doc = " @brief Copy from source to destination and reverse byte order\n @param src\n @param dest\n @param len"]
    pub fn reverse_bytes(src: *const u8, dest: *mut u8, len: cty::c_int);
}
extern "C" {
    #[doc = " @brief Wrapper around reverse_bytes for common buffer sizes\n @param src\n @param dest"]
    pub fn reverse_24(src: *const u8, dest: *mut u8);
}
extern "C" {
    pub fn reverse_48(src: *const u8, dest: *mut u8);
}
extern "C" {
    pub fn reverse_56(src: *const u8, dest: *mut u8);
}
extern "C" {
    pub fn reverse_64(src: *const u8, dest: *mut u8);
}
extern "C" {
    pub fn reverse_128(src: *const u8, dest: *mut u8);
}
extern "C" {
    pub fn reverse_256(src: *const u8, dest: *mut u8);
}
extern "C" {
    pub fn reverse_bd_addr(src: *mut u8, dest: *mut u8);
}
extern "C" {
    #[doc = " @brief Check if all bytes in buffer are zero\n @param buffer\n @param size\n @return true if all bytes is buffer are zero"]
    pub fn btstack_is_null(buffer: *const u8, size: u16) -> bool;
}
extern "C" {
    #[doc = " @brief ASCII character for 4-bit nibble\n @return character"]
    pub fn char_for_nibble(nibble: cty::c_int) -> cty::c_char;
}
extern "C" {
    #[doc = " @brif 4-bit nibble from ASCII character\n @return value"]
    pub fn nibble_for_char(c: cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Compare two Bluetooth addresses\n @param a\n @param b\n @return 0 if equal"]
    pub fn bd_addr_cmp(a: *mut u8, b: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Copy Bluetooth address\n @param dest\n @param src"]
    pub fn bd_addr_copy(dest: *mut u8, src: *mut u8);
}
extern "C" {
    #[doc = " @brief Use printf to write hexdump as single line of data"]
    pub fn printf_hexdump(data: *const cty::c_void, size: cty::c_int);
}
extern "C" {
    #[doc = " @brief Create human readable representation for UUID128\n @note uses fixed global buffer\n @return pointer to UUID128 string"]
    pub fn uuid128_to_str(uuid: *const u8) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " @brief Create human readable represenationt of Bluetooth address\n @note uses fixed global buffer\n @param delimiter\n @return pointer to Bluetooth address string"]
    pub fn bd_addr_to_str_with_delimiter(addr: *mut u8, delimiter: cty::c_char)
        -> *mut cty::c_char;
}
extern "C" {
    #[doc = " @brief Create human readable represenationt of Bluetooth address\n @note uses fixed global buffer\n @return pointer to Bluetooth address string"]
    pub fn bd_addr_to_str(addr: *mut u8) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " @brief Replace address placeholder '00:00:00:00:00:00' with Bluetooth address\n @param buffer\n @param size\n @param address"]
    pub fn btstack_replace_bd_addr_placeholder(buffer: *mut u8, size: u16, address: *mut u8);
}
extern "C" {
    #[doc = " @brief Parse Bluetooth address\n @param address_string\n @param buffer for parsed address\n @return 1 if string was parsed successfully"]
    pub fn sscanf_bd_addr(addr_string: *const cty::c_char, addr: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Constructs UUID128 from 16 or 32 bit UUID using Bluetooth base UUID\n @param uuid128 output buffer\n @param short_uuid"]
    pub fn uuid_add_bluetooth_prefix(uuid128: *mut u8, short_uuid: u32);
}
extern "C" {
    #[doc = " @brief Checks if UUID128 has Bluetooth base UUID prefix\n @param uui128 to test\n @return 1 if it can be expressed as UUID32"]
    pub fn uuid_has_bluetooth_prefix(uuid128: *const u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Parse unsigned number\n @param str to parse\n @return value"]
    pub fn btstack_atoi(str_: *const cty::c_char) -> u32;
}
extern "C" {
    #[doc = " @brief Return number of digits of a uint32 number\n @param uint32_number\n @return num_digits"]
    pub fn string_len_for_uint32(i: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Return number of set bits in a uint32 number\n @param uint32_number\n @return num_set_bits"]
    pub fn count_set_bits_uint32(x: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Check CRC8 using ETSI TS 101 369 V6.3.0.\n @note Only used by RFCOMM\n @param data\n @param len\n @param check_sum"]
    pub fn btstack_crc8_check(data: *mut u8, len: u16, check_sum: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Calculate CRC8 using ETSI TS 101 369 V6.3.0.\n @note Only used by RFCOMM\n @param data\n @param len"]
    pub fn btstack_crc8_calc(data: *mut u8, len: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Get next cid\n @param current_cid\n @return next cid skiping 0"]
    pub fn btstack_next_cid_ignoring_zero(current_cid: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Copy string (up to dst_size-1 characters) from src into dst buffer with terminating '\\0'\n @note replaces strncpy + dst[dst_size-1] = '\\0'\n @param dst\n @param dst_size\n @param src\n @retun bytes_copied including trailing 0"]
    pub fn btstack_strcpy(dst: *mut cty::c_char, dst_size: u16, src: *const cty::c_char) -> u16;
}
extern "C" {
    #[doc = " @brief Append src string to string in dst buffer with terminating '\\0'\n @note max total string length will be dst_size-1 characters\n @param dst\n @param dst_size\n @param src"]
    pub fn btstack_strcat(dst: *mut cty::c_char, dst_size: u16, src: *const cty::c_char);
}
extern "C" {
    #[doc = " Returns the number of leading 0-bits in x, starting at the most significant bit position.\n If x is 0, the result is undefined.\n @note maps to __builtin_clz for gcc and clang\n @param value\n @return number of leading 0-bits"]
    pub fn btstack_clz(value: u32) -> u8;
}
extern "C" {
    #[doc = " @brief Copy chunk of data into a virtual buffer backed by a physical buffer.\n Used to provide chunk of data of larger buffer that is constructed on the fly, e.g. serializing data struct\n\n For example, copy field2 to buffer, with buffer_offset = 11\n\n           field1  field2  field3     field4        field5  filed6\n struct:  -------|-------|----------|-------------|-------|--------------\n buffer:             ------------------\n result:             ----|\n\n When also copying field3 and field4 to buffer, with buffer_offset = 11\n\n           field1  field2  field3     field4        field5  filed6\n struct:  -------|-------|----------|-------------|-------|--------------\n buffer:             ------------------\n result:             ----|----------|--\n\n @param field_data\n @param field_len\n @param field_offset  position of field in complete data block\n @param buffer_data\n @param buffer_len\n @param buffer_offset position of buffer in complete data block\n @return bytes_copied number of bytes actually stored in buffer"]
    pub fn btstack_virtual_memcpy(
        field_data: *const u8,
        field_len: u16,
        field_offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
        buffer_offset: u16,
    ) -> u16;
}
impl POWER_NOTIFICATION_t {
    pub const POWER_WILL_SLEEP: POWER_NOTIFICATION_t = POWER_NOTIFICATION_t(1);
}
impl POWER_NOTIFICATION_t {
    pub const POWER_WILL_WAKE_UP: POWER_NOTIFICATION_t = POWER_NOTIFICATION_t(2);
}
impl ::core::ops::BitOr<POWER_NOTIFICATION_t> for POWER_NOTIFICATION_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        POWER_NOTIFICATION_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for POWER_NOTIFICATION_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: POWER_NOTIFICATION_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<POWER_NOTIFICATION_t> for POWER_NOTIFICATION_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        POWER_NOTIFICATION_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for POWER_NOTIFICATION_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: POWER_NOTIFICATION_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct POWER_NOTIFICATION_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_control_t {
    pub init: ::core::option::Option<unsafe extern "C" fn(config: *const cty::c_void)>,
    pub on: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    pub off: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    pub sleep: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    pub wake: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    pub register_for_power_notifications: ::core::option::Option<
        unsafe extern "C" fn(
            cb: ::core::option::Option<unsafe extern "C" fn(event: POWER_NOTIFICATION_t)>,
        ),
    >,
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_RANDOM: btstack_crypto_operation_t = btstack_crypto_operation_t(0);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_AES128: btstack_crypto_operation_t = btstack_crypto_operation_t(1);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_CMAC_GENERATOR: btstack_crypto_operation_t =
        btstack_crypto_operation_t(2);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_CMAC_MESSAGE: btstack_crypto_operation_t =
        btstack_crypto_operation_t(3);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_ECC_P256_GENERATE_KEY: btstack_crypto_operation_t =
        btstack_crypto_operation_t(4);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_ECC_P256_CALCULATE_DHKEY: btstack_crypto_operation_t =
        btstack_crypto_operation_t(5);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_CCM_DIGEST_BLOCK: btstack_crypto_operation_t =
        btstack_crypto_operation_t(6);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_CCM_ENCRYPT_BLOCK: btstack_crypto_operation_t =
        btstack_crypto_operation_t(7);
}
impl btstack_crypto_operation_t {
    pub const BTSTACK_CRYPTO_CCM_DECRYPT_BLOCK: btstack_crypto_operation_t =
        btstack_crypto_operation_t(8);
}
impl ::core::ops::BitOr<btstack_crypto_operation_t> for btstack_crypto_operation_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        btstack_crypto_operation_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for btstack_crypto_operation_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: btstack_crypto_operation_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<btstack_crypto_operation_t> for btstack_crypto_operation_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        btstack_crypto_operation_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for btstack_crypto_operation_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: btstack_crypto_operation_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct btstack_crypto_operation_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_crypto_t {
    pub context_callback: btstack_context_callback_registration_t,
    pub operation: btstack_crypto_operation_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_crypto_random_t {
    pub btstack_crypto: btstack_crypto_t,
    pub buffer: *mut u8,
    pub size: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_crypto_aes128_t {
    pub btstack_crypto: btstack_crypto_t,
    pub key: *const u8,
    pub plaintext: *const u8,
    pub ciphertext: *mut u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btstack_crypto_aes128_cmac_t {
    pub btstack_crypto: btstack_crypto_t,
    pub key: *const u8,
    pub size: u16,
    pub data: btstack_crypto_aes128_cmac_t__bindgen_ty_1,
    pub hash: *mut u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btstack_crypto_aes128_cmac_t__bindgen_ty_1 {
    pub get_byte_callback: ::core::option::Option<unsafe extern "C" fn(pos: u16) -> u8>,
    pub message: *const u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_crypto_ecc_p256_t {
    pub btstack_crypto: btstack_crypto_t,
    pub public_key: *mut u8,
    pub dhkey: *mut u8,
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_CALCULATE_X1: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(0);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_W4_X1: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(1);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_CALCULATE_AAD_XN: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(2);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_W4_AAD_XN: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(3);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_CALCULATE_XN: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(4);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_W4_XN: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(5);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_CALCULATE_S0: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(6);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_W4_S0: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(7);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_CALCULATE_SN: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(8);
}
impl btstack_crypto_ccm_state_t {
    pub const CCM_W4_SN: btstack_crypto_ccm_state_t = btstack_crypto_ccm_state_t(9);
}
impl ::core::ops::BitOr<btstack_crypto_ccm_state_t> for btstack_crypto_ccm_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        btstack_crypto_ccm_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for btstack_crypto_ccm_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: btstack_crypto_ccm_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<btstack_crypto_ccm_state_t> for btstack_crypto_ccm_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        btstack_crypto_ccm_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for btstack_crypto_ccm_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: btstack_crypto_ccm_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct btstack_crypto_ccm_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_crypto_ccm_t {
    pub btstack_crypto: btstack_crypto_t,
    pub state: btstack_crypto_ccm_state_t,
    pub key: *const u8,
    pub nonce: *const u8,
    pub input: *const u8,
    pub output: *mut u8,
    pub x_i: [u8; 16usize],
    pub aad_offset: u16,
    pub aad_len: u16,
    pub message_len: u16,
    pub counter: u16,
    pub block_len: u16,
    pub auth_len: u8,
    pub aad_remainder_len: u8,
}
extern "C" {
    #[doc = " Initialize crypto functions"]
    pub fn btstack_crypto_init();
}
extern "C" {
    #[doc = " Generate random data\n @param request\n @param buffer for output\n @param size of requested random data\n @param callback\n @param callback_arg\n @note request needs to stay avaliable until callback (i.e. not provided on stack)"]
    pub fn btstack_crypto_random_generate(
        request: *mut btstack_crypto_random_t,
        buffer: *mut u8,
        size: u16,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Encrypt plaintext using AES128\n @param request\n @param key (16 bytes)\n @param plaintext (16 bytes)\n @param ciphertext (16 bytes)\n @param callback\n @param callback_arg\n @note request needs to stay avaliable until callback (i.e. not provided on stack)"]
    pub fn btstack_crypto_aes128_encrypt(
        request: *mut btstack_crypto_aes128_t,
        key: *const u8,
        plaintext: *const u8,
        ciphertext: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Calculate Cipher-based Message Authentication Code (CMAC) using AES128 and a generator function to provide data\n @param request\n @param key (16 bytes)\n @param size of message\n @param generator provides byte at requested position\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_aes128_cmac_generator(
        request: *mut btstack_crypto_aes128_cmac_t,
        key: *const u8,
        size: u16,
        get_byte_callback: ::core::option::Option<unsafe extern "C" fn(pos: u16) -> u8>,
        hash: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Calculate Cipher-based Message Authentication Code (CMAC) using AES128 and complete message\n @param request\n @param key (16 bytes)\n @param size of message\n @param message\n @param hash result\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_aes128_cmac_message(
        request: *mut btstack_crypto_aes128_cmac_t,
        key: *const u8,
        size: u16,
        message: *const u8,
        hash: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Calculate AES128-CMAC with key ZERO and complete message\n @param request\n @param size of message\n @param message\n @param hash\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_aes128_cmac_zero(
        request: *mut btstack_crypto_aes128_cmac_t,
        size: u16,
        message: *const u8,
        hash: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Generate Elliptic Curve Public/Private Key Pair (FIPS P-256)\n @note BTstack uses a single ECC key pair per reset.\n @note If LE Controller is used for ECC, private key cannot be read or managed\n @param request\n @param public_key (64 bytes)\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_ecc_p256_generate_key(
        request: *mut btstack_crypto_ecc_p256_t,
        public_key: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Calculate Diffie-Hellman Key based on local private key and remote public key\n @param request\n @param public_key (64 bytes)\n @param dhkey (32 bytes)\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_ecc_p256_calculate_dhkey(
        request: *mut btstack_crypto_ecc_p256_t,
        public_key: *const u8,
        dhkey: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    pub fn btstack_crypto_ecc_p256_validate_public_key(public_key: *const u8) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize Counter with CBC-MAC for Bluetooth Mesh (L=2)\n @param request\n @param nonce\n @param key\n @param message_len\n @param additional_authenticated_data_len must be smaller than 0xff00\n @param auth_len"]
    pub fn btstack_crypto_ccm_init(
        request: *mut btstack_crypto_ccm_t,
        key: *const u8,
        nonce: *const u8,
        message_len: u16,
        additional_authenticated_data_len: u16,
        auth_len: u8,
    );
}
extern "C" {
    #[doc = " Get authentication value after encrypt or decrypt operation\n @param request\n @param authentication_value"]
    pub fn btstack_crypto_ccm_get_authentication_value(
        request: *mut btstack_crypto_ccm_t,
        authentication_value: *mut u8,
    );
}
extern "C" {
    #[doc = " Digest Additional Authentication Data - can be called multipled times up to total additional_authenticated_data_len specified in btstack_crypto_ccm_init\n @param request\n @param additional_authenticated_data\n @param additional_authenticated_data_len\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_ccm_digest(
        request: *mut btstack_crypto_ccm_t,
        additional_authenticated_data: *mut u8,
        additional_authenticated_data_len: u16,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Encrypt block - can be called multiple times. len must be a multiply of 16 for all but the last call\n @param request\n @param len (16 bytes for all but the last block)\n @param plaintext  (16 bytes)\n @param ciphertext (16 bytes)\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_ccm_encrypt_block(
        request: *mut btstack_crypto_ccm_t,
        len: u16,
        plaintext: *const u8,
        ciphertext: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Decrypt block - can be called multiple times. len must be a multiply of 16 for all but the last call\n @param request\n @param len (16 for all but last block)\n @param ciphertext (16 bytes)\n @param plaintext  (16 bytes)\n @param callback\n @param callback_arg"]
    pub fn btstack_crypto_ccm_decrypt_block(
        request: *mut btstack_crypto_ccm_t,
        len: u16,
        ciphertext: *const u8,
        plaintext: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Encrypt plaintext using AES128\n @note Prototype for custom AES128 implementation\n @param key (16 bytes)\n @param plaintext (16 bytes)\n @param ciphertext (16 bytes)"]
    pub fn btstack_aes128_calc(key: *const u8, plaintext: *const u8, ciphertext: *mut u8);
}
extern "C" {
    #[doc = " @brief De-Init BTstack Crypto"]
    pub fn btstack_crypto_deinit();
}
extern "C" {
    pub fn btstack_crypto_ecc_p256_set_key(public_key: *const u8, private_key: *const u8);
}
extern "C" {
    pub fn btstack_crypto_idle() -> cty::c_int;
}
extern "C" {
    pub fn btstack_crypto_reset();
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
impl hci_dump_format_t {
    pub const HCI_DUMP_INVALID: hci_dump_format_t = hci_dump_format_t(0);
}
impl hci_dump_format_t {
    pub const HCI_DUMP_BLUEZ: hci_dump_format_t = hci_dump_format_t(1);
}
impl hci_dump_format_t {
    pub const HCI_DUMP_PACKETLOGGER: hci_dump_format_t = hci_dump_format_t(2);
}
impl hci_dump_format_t {
    pub const HCI_DUMP_BTSNOOP: hci_dump_format_t = hci_dump_format_t(3);
}
impl ::core::ops::BitOr<hci_dump_format_t> for hci_dump_format_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_dump_format_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_dump_format_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_dump_format_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_dump_format_t> for hci_dump_format_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_dump_format_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_dump_format_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_dump_format_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_dump_format_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_dump_t {
    pub reset: ::core::option::Option<unsafe extern "C" fn()>,
    pub log_packet: ::core::option::Option<
        unsafe extern "C" fn(packet_type: u8, in_: u8, packet: *mut u8, len: u16),
    >,
    pub log_message: ::core::option::Option<
        unsafe extern "C" fn(log_level: cty::c_int, format: *const cty::c_char, argptr: va_list),
    >,
}
extern "C" {
    #[doc = " @brief Init HCI Dump\n @param hci_dump_impl - platform-specific implementation"]
    pub fn hci_dump_init(hci_dump_impl: *const hci_dump_t);
}
extern "C" {
    #[doc = " @brief Enable packet logging\n @param enabled default: true"]
    pub fn hci_dump_enable_packet_log(enabled: bool);
}
extern "C" {
    #[doc = " @brief"]
    pub fn hci_dump_enable_log_level(log_level: cty::c_int, enable: cty::c_int);
}
extern "C" {
    pub fn hci_dump_set_max_packets(packets: cty::c_int);
}
extern "C" {
    #[doc = " @brief Dump Packet\n @param packet_type\n @param in is 1 for incoming, 0 for outoing\n @param packet\n @param len"]
    pub fn hci_dump_packet(packet_type: u8, in_: u8, packet: *mut u8, len: u16);
}
extern "C" {
    #[doc = " @brief Dump Message\n @param log_level\n @param format"]
    pub fn hci_dump_log(log_level: cty::c_int, format: *const cty::c_char, ...);
}
extern "C" {
    #[doc = " @brief Setup header for PacketLogger format\n @param buffer\n @param tv_sec\n @param tv_us\n @param packet_type\n @param in\n @param len"]
    pub fn hci_dump_setup_header_packetlogger(
        buffer: *mut u8,
        tv_sec: u32,
        tv_us: u32,
        packet_type: u8,
        in_: u8,
        len: u16,
    );
}
extern "C" {
    #[doc = " @brief Setup header for BLUEZ (hcidump) format\n @param buffer\n @param tv_sec\n @param tv_us\n @param packet_type\n @param in\n @param len"]
    pub fn hci_dump_setup_header_bluez(
        buffer: *mut u8,
        tv_sec: u32,
        tv_us: u32,
        packet_type: u8,
        in_: u8,
        len: u16,
    );
}
extern "C" {
    #[doc = " @brief Setup header for BT Snoop format\n @param buffer\n @param ts_usec_high upper 32-bit of 64-bit microsecond timestamp\n @param ts_usec_low  lower 2-bit of 64-bit microsecond timestamp\n @param cumulative_drops since last packet was recorded\n @param packet_type\n @param in\n @param len"]
    pub fn hci_dump_setup_header_btsnoop(
        buffer: *mut u8,
        ts_usec_high: u32,
        ts_usec_low: u32,
        cumulative_drops: u32,
        packet_type: u8,
        in_: u8,
        len: u16,
    );
}
extern "C" {
    pub fn __assert(arg1: *const cty::c_char, arg2: cty::c_int, arg3: *const cty::c_char) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const cty::c_char,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: *const cty::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " @brief Log Security Manager key via log_info\n @param name\n @param key to log"]
    pub fn log_info_key(name: *const cty::c_char, key: *mut u8);
}
extern "C" {
    #[doc = " @brief Hexdump via log_info\n @param data\n @param size"]
    pub fn log_info_hexdump(data: *const cty::c_void, size: cty::c_int);
}
extern "C" {
    #[doc = " @brief Hexdump via log_debug\n @param data\n @param size"]
    pub fn log_debug_hexdump(data: *const cty::c_void, size: cty::c_int);
}
impl btstack_chipset_result_t {
    pub const BTSTACK_CHIPSET_DONE: btstack_chipset_result_t = btstack_chipset_result_t(0);
}
impl btstack_chipset_result_t {
    pub const BTSTACK_CHIPSET_VALID_COMMAND: btstack_chipset_result_t = btstack_chipset_result_t(1);
}
impl btstack_chipset_result_t {
    pub const BTSTACK_CHIPSET_WARMSTART_REQUIRED: btstack_chipset_result_t =
        btstack_chipset_result_t(2);
}
impl btstack_chipset_result_t {
    pub const BTSTACK_CHIPSET_NO_INIT_SCRIPT: btstack_chipset_result_t =
        btstack_chipset_result_t(3);
}
impl ::core::ops::BitOr<btstack_chipset_result_t> for btstack_chipset_result_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        btstack_chipset_result_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for btstack_chipset_result_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: btstack_chipset_result_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<btstack_chipset_result_t> for btstack_chipset_result_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        btstack_chipset_result_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for btstack_chipset_result_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: btstack_chipset_result_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct btstack_chipset_result_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_chipset_t {
    #[doc = " chipset driver name"]
    pub name: *const cty::c_char,
    #[doc = " init driver\n allows to reset init script index\n @param transport_config"]
    pub init: ::core::option::Option<unsafe extern "C" fn(transport_config: *const cty::c_void)>,
    #[doc = " support custom init sequences after RESET command\n @param  hci_cmd_buffer to store generated command\n @return result see btstack_chipset_result_t"]
    pub next_command: ::core::option::Option<
        unsafe extern "C" fn(hci_cmd_buffer: *mut u8) -> btstack_chipset_result_t,
    >,
    #[doc = " provide UART Baud Rate change command.\n @param baudrate\n @param hci_cmd_buffer to store generated command"]
    pub set_baudrate_command:
        ::core::option::Option<unsafe extern "C" fn(baudrate: u32, hci_cmd_buffer: *mut u8)>,
    #[doc = " provide Set BD Addr command\n @param baudrate\n @param hci_cmd_buffer to store generated command"]
    pub set_bd_addr_command:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut u8, hci_cmd_buffer: *mut u8)>,
}
impl HCI_POWER_MODE {
    pub const HCI_POWER_OFF: HCI_POWER_MODE = HCI_POWER_MODE(0);
}
impl HCI_POWER_MODE {
    pub const HCI_POWER_ON: HCI_POWER_MODE = HCI_POWER_MODE(1);
}
impl HCI_POWER_MODE {
    pub const HCI_POWER_SLEEP: HCI_POWER_MODE = HCI_POWER_MODE(2);
}
impl ::core::ops::BitOr<HCI_POWER_MODE> for HCI_POWER_MODE {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HCI_POWER_MODE(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HCI_POWER_MODE {
    #[inline]
    fn bitor_assign(&mut self, rhs: HCI_POWER_MODE) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HCI_POWER_MODE> for HCI_POWER_MODE {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HCI_POWER_MODE(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HCI_POWER_MODE {
    #[inline]
    fn bitand_assign(&mut self, rhs: HCI_POWER_MODE) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = "  Hardware state of Bluetooth controller"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HCI_POWER_MODE(pub cty::c_uint);
impl HCI_STATE {
    pub const HCI_STATE_OFF: HCI_STATE = HCI_STATE(0);
}
impl HCI_STATE {
    pub const HCI_STATE_INITIALIZING: HCI_STATE = HCI_STATE(1);
}
impl HCI_STATE {
    pub const HCI_STATE_WORKING: HCI_STATE = HCI_STATE(2);
}
impl HCI_STATE {
    pub const HCI_STATE_HALTING: HCI_STATE = HCI_STATE(3);
}
impl HCI_STATE {
    pub const HCI_STATE_SLEEPING: HCI_STATE = HCI_STATE(4);
}
impl HCI_STATE {
    pub const HCI_STATE_FALLING_ASLEEP: HCI_STATE = HCI_STATE(5);
}
impl ::core::ops::BitOr<HCI_STATE> for HCI_STATE {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HCI_STATE(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HCI_STATE {
    #[inline]
    fn bitor_assign(&mut self, rhs: HCI_STATE) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HCI_STATE> for HCI_STATE {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HCI_STATE(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HCI_STATE {
    #[inline]
    fn bitand_assign(&mut self, rhs: HCI_STATE) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " State of BTstack"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HCI_STATE(pub cty::c_uint);
#[doc = " compact HCI Command packet description"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_cmd_t {
    pub opcode: u16,
    pub format: *const cty::c_char,
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_INQUIRY: hci_opcode_t = hci_opcode_t(1025);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_INQUIRY_CANCEL: hci_opcode_t = hci_opcode_t(1026);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_PERIODIC_INQUIRY_MODE: hci_opcode_t = hci_opcode_t(1027);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_EXIT_PERIODIC_INQUIRY_MODE: hci_opcode_t = hci_opcode_t(1028);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_CREATE_CONNECTION: hci_opcode_t = hci_opcode_t(1029);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_DISCONNECT: hci_opcode_t = hci_opcode_t(1030);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_CREATE_CONNECTION_CANCEL: hci_opcode_t = hci_opcode_t(1032);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_ACCEPT_CONNECTION_REQUEST: hci_opcode_t = hci_opcode_t(1033);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_REJECT_CONNECTION_REQUEST: hci_opcode_t = hci_opcode_t(1034);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LINK_KEY_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(1035);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LINK_KEY_REQUEST_NEGATIVE_REPLY: hci_opcode_t = hci_opcode_t(1036);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_PIN_CODE_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(1037);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_PIN_CODE_REQUEST_NEGATIVE_REPLY: hci_opcode_t = hci_opcode_t(1038);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_CHANGE_CONNECTION_PACKET_TYPE: hci_opcode_t = hci_opcode_t(1039);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_AUTHENTICATION_REQUESTED: hci_opcode_t = hci_opcode_t(1041);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SET_CONNECTION_ENCRYPTION: hci_opcode_t = hci_opcode_t(1043);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_CHANGE_CONNECTION_LINK_KEY: hci_opcode_t = hci_opcode_t(1045);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_REMOTE_NAME_REQUEST: hci_opcode_t = hci_opcode_t(1049);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_REMOTE_NAME_REQUEST_CANCEL: hci_opcode_t = hci_opcode_t(1050);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_REMOTE_SUPPORTED_FEATURES_COMMAND: hci_opcode_t =
        hci_opcode_t(1051);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_REMOTE_EXTENDED_FEATURES_COMMAND: hci_opcode_t =
        hci_opcode_t(1052);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_REMOTE_VERSION_INFORMATION: hci_opcode_t = hci_opcode_t(1053);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SETUP_SYNCHRONOUS_CONNECTION: hci_opcode_t = hci_opcode_t(1064);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_ACCEPT_SYNCHRONOUS_CONNECTION: hci_opcode_t = hci_opcode_t(1065);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_IO_CAPABILITY_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(1067);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_USER_CONFIRMATION_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(1068);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY: hci_opcode_t =
        hci_opcode_t(1069);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_USER_PASSKEY_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(1070);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_USER_PASSKEY_REQUEST_NEGATIVE_REPLY: hci_opcode_t = hci_opcode_t(1071);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_REMOTE_OOB_DATA_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(1072);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY: hci_opcode_t =
        hci_opcode_t(1075);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_IO_CAPABILITY_REQUEST_NEGATIVE_REPLY: hci_opcode_t =
        hci_opcode_t(1076);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_ENHANCED_SETUP_SYNCHRONOUS_CONNECTION: hci_opcode_t =
        hci_opcode_t(1085);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_ENHANCED_ACCEPT_SYNCHRONOUS_CONNECTION: hci_opcode_t =
        hci_opcode_t(1086);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY: hci_opcode_t =
        hci_opcode_t(1093);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_HOLD_MODE: hci_opcode_t = hci_opcode_t(2049);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SNIFF_MODE: hci_opcode_t = hci_opcode_t(2051);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_EXIT_SNIFF_MODE: hci_opcode_t = hci_opcode_t(2052);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_PARK_STATE: hci_opcode_t = hci_opcode_t(2053);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_EXIT_PARK_STATE: hci_opcode_t = hci_opcode_t(2054);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_QOS_SETUP: hci_opcode_t = hci_opcode_t(2055);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_ROLE_DISCOVERY: hci_opcode_t = hci_opcode_t(2057);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SWITCH_ROLE_COMMAND: hci_opcode_t = hci_opcode_t(2059);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LINK_POLICY_SETTINGS: hci_opcode_t = hci_opcode_t(2060);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_LINK_POLICY_SETTINGS: hci_opcode_t = hci_opcode_t(2061);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_DEFAULT_LINK_POLICY_SETTING: hci_opcode_t = hci_opcode_t(2063);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_FLOW_SPECIFICATION: hci_opcode_t = hci_opcode_t(2064);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SNIFF_SUBRATING: hci_opcode_t = hci_opcode_t(2065);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SET_EVENT_MASK: hci_opcode_t = hci_opcode_t(3073);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_RESET: hci_opcode_t = hci_opcode_t(3075);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_FLUSH: hci_opcode_t = hci_opcode_t(3080);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_PIN_TYPE: hci_opcode_t = hci_opcode_t(3081);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_PIN_TYPE: hci_opcode_t = hci_opcode_t(3082);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_DELETE_STORED_LINK_KEY: hci_opcode_t = hci_opcode_t(3090);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_LOCAL_NAME: hci_opcode_t = hci_opcode_t(3091);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOCAL_NAME: hci_opcode_t = hci_opcode_t(3092);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_PAGE_TIMEOUT: hci_opcode_t = hci_opcode_t(3095);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_PAGE_TIMEOUT: hci_opcode_t = hci_opcode_t(3096);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_SCAN_ENABLE: hci_opcode_t = hci_opcode_t(3098);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_PAGE_SCAN_ACTIVITY: hci_opcode_t = hci_opcode_t(3099);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_PAGE_SCAN_ACTIVITY: hci_opcode_t = hci_opcode_t(3100);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_INQUIRY_SCAN_ACTIVITY: hci_opcode_t = hci_opcode_t(3101);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_INQUIRY_SCAN_ACTIVITY: hci_opcode_t = hci_opcode_t(3102);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_AUTHENTICATION_ENABLE: hci_opcode_t = hci_opcode_t(3104);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_CLASS_OF_DEVICE: hci_opcode_t = hci_opcode_t(3108);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_AUTOMATIC_FLUSH_TIMEOUT: hci_opcode_t = hci_opcode_t(3112);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_NUM_BROADCAST_RETRANSMISSIONS: hci_opcode_t = hci_opcode_t(3113);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_NUM_BROADCAST_RETRANSMISSIONS: hci_opcode_t = hci_opcode_t(3114);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_TRANSMIT_POWER_LEVEL: hci_opcode_t = hci_opcode_t(3117);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE: hci_opcode_t =
        hci_opcode_t(3119);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SET_CONTROLLER_TO_HOST_FLOW_CONTROL: hci_opcode_t = hci_opcode_t(3121);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_HOST_BUFFER_SIZE: hci_opcode_t = hci_opcode_t(3123);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_HOST_NUMBER_OF_COMPLETED_PACKETS: hci_opcode_t = hci_opcode_t(3125);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LINK_SUPERVISION_TIMEOUT: hci_opcode_t = hci_opcode_t(3126);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_LINK_SUPERVISION_TIMEOUT: hci_opcode_t = hci_opcode_t(3127);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_CURRENT_IAC_LAP_TWO_IACS: hci_opcode_t = hci_opcode_t(3130);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_INQUIRY_SCAN_TYPE: hci_opcode_t = hci_opcode_t(3138);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_INQUIRY_SCAN_TYPE: hci_opcode_t = hci_opcode_t(3139);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_INQUIRY_MODE: hci_opcode_t = hci_opcode_t(3140);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_INQUIRY_MODE: hci_opcode_t = hci_opcode_t(3141);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_PAGE_SCAN_TYPE: hci_opcode_t = hci_opcode_t(3142);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_PAGE_SCAN_TYPE: hci_opcode_t = hci_opcode_t(3143);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_EXTENDED_INQUIRY_RESPONSE: hci_opcode_t = hci_opcode_t(3154);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_SIMPLE_PAIRING_MODE: hci_opcode_t = hci_opcode_t(3158);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOCAL_OOB_DATA: hci_opcode_t = hci_opcode_t(3159);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING: hci_opcode_t =
        hci_opcode_t(3163);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SET_EVENT_MASK_2: hci_opcode_t = hci_opcode_t(3171);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LE_HOST_SUPPORTED: hci_opcode_t = hci_opcode_t(3180);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_LE_HOST_SUPPORTED: hci_opcode_t = hci_opcode_t(3181);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_SECURE_CONNECTIONS_HOST_SUPPORT: hci_opcode_t =
        hci_opcode_t(3194);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOCAL_EXTENDED_OOB_DATA: hci_opcode_t = hci_opcode_t(3197);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_EXTENDED_PAGE_TIMEOUT: hci_opcode_t = hci_opcode_t(3198);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_EXTENDED_PAGE_TIMEOUT: hci_opcode_t = hci_opcode_t(3199);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_EXTENDED_INQUIRY_LENGTH: hci_opcode_t = hci_opcode_t(3200);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_EXTENDED_INQUIRY_LENGTH: hci_opcode_t = hci_opcode_t(3201);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SET_ECOSYSTEM_BASE_INTERVAL: hci_opcode_t = hci_opcode_t(3202);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_CONFIGURE_DATA_PATH: hci_opcode_t = hci_opcode_t(3203);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_SET_MIN_ENCRYPTION_KEY_SIZE: hci_opcode_t = hci_opcode_t(3204);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOOPBACK_MODE: hci_opcode_t = hci_opcode_t(6145);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_LOOPBACK_MODE: hci_opcode_t = hci_opcode_t(6146);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_ENABLE_DEVICE_UNDER_TEST_MODE: hci_opcode_t = hci_opcode_t(6147);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_SIMPLE_PAIRING_DEBUG_MODE: hci_opcode_t = hci_opcode_t(6148);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_WRITE_SECURE_CONNECTIONS_TEST_MODE: hci_opcode_t = hci_opcode_t(6154);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOCAL_VERSION_INFORMATION: hci_opcode_t = hci_opcode_t(4097);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOCAL_SUPPORTED_COMMANDS: hci_opcode_t = hci_opcode_t(4098);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_LOCAL_SUPPORTED_FEATURES: hci_opcode_t = hci_opcode_t(4099);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_BUFFER_SIZE: hci_opcode_t = hci_opcode_t(4101);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_BD_ADDR: hci_opcode_t = hci_opcode_t(4105);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_RSSI: hci_opcode_t = hci_opcode_t(5125);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_READ_ENCRYPTION_KEY_SIZE: hci_opcode_t = hci_opcode_t(5128);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EVENT_MASK: hci_opcode_t = hci_opcode_t(8193);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_BUFFER_SIZE: hci_opcode_t = hci_opcode_t(8194);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_LOCAL_SUPPORTED_FEATURES: hci_opcode_t = hci_opcode_t(8195);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_RANDOM_ADDRESS: hci_opcode_t = hci_opcode_t(8197);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_ADVERTISING_PARAMETERS: hci_opcode_t = hci_opcode_t(8198);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_ADVERTISING_CHANNEL_TX_POWER: hci_opcode_t =
        hci_opcode_t(8199);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_ADVERTISING_DATA: hci_opcode_t = hci_opcode_t(8200);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_SCAN_RESPONSE_DATA: hci_opcode_t = hci_opcode_t(8201);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_ADVERTISE_ENABLE: hci_opcode_t = hci_opcode_t(8202);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_SCAN_PARAMETERS: hci_opcode_t = hci_opcode_t(8203);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_SCAN_ENABLE: hci_opcode_t = hci_opcode_t(8204);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CREATE_CONNECTION: hci_opcode_t = hci_opcode_t(8205);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CREATE_CONNECTION_CANCEL: hci_opcode_t = hci_opcode_t(8206);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_WHITE_LIST_SIZE: hci_opcode_t = hci_opcode_t(8207);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CLEAR_WHITE_LIST: hci_opcode_t = hci_opcode_t(8208);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ADD_DEVICE_TO_WHITE_LIST: hci_opcode_t = hci_opcode_t(8209);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOVE_DEVICE_FROM_WHITE_LIST: hci_opcode_t = hci_opcode_t(8210);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CONNECTION_UPDATE: hci_opcode_t = hci_opcode_t(8211);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_HOST_CHANNEL_CLASSIFICATION: hci_opcode_t = hci_opcode_t(8212);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_CHANNEL_MAP: hci_opcode_t = hci_opcode_t(8213);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_REMOTE_USED_FEATURES: hci_opcode_t = hci_opcode_t(8214);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ENCRYPT: hci_opcode_t = hci_opcode_t(8215);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_RAND: hci_opcode_t = hci_opcode_t(8216);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_START_ENCRYPTION: hci_opcode_t = hci_opcode_t(8217);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_LONG_TERM_KEY_REQUEST_REPLY: hci_opcode_t = hci_opcode_t(8218);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_LONG_TERM_KEY_NEGATIVE_REPLY: hci_opcode_t = hci_opcode_t(8219);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_SUPPORTED_STATES: hci_opcode_t = hci_opcode_t(8220);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_RECEIVER_TEST: hci_opcode_t = hci_opcode_t(8221);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_TRANSMITTER_TEST: hci_opcode_t = hci_opcode_t(8222);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_TEST_END: hci_opcode_t = hci_opcode_t(8223);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOTE_CONNECTION_PARAMETER_REQUEST_REPLY: hci_opcode_t =
        hci_opcode_t(8224);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOTE_CONNECTION_PARAMETER_REQUEST_NEGATIVE_REPLY: hci_opcode_t =
        hci_opcode_t(8225);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_DATA_LENGTH: hci_opcode_t = hci_opcode_t(8226);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH: hci_opcode_t =
        hci_opcode_t(8227);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH: hci_opcode_t =
        hci_opcode_t(8228);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_LOCAL_P256_PUBLIC_KEY: hci_opcode_t = hci_opcode_t(8229);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_GENERATE_DHKEY: hci_opcode_t = hci_opcode_t(8230);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ADD_DEVICE_TO_RESOLVING_LIST: hci_opcode_t = hci_opcode_t(8231);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST: hci_opcode_t =
        hci_opcode_t(8232);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CLEAR_RESOLVING_LIST: hci_opcode_t = hci_opcode_t(8233);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_RESOLVING_LIST_SIZE: hci_opcode_t = hci_opcode_t(8234);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_PEER_RESOLVABLE_ADDRESS: hci_opcode_t = hci_opcode_t(8235);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_LOCAL_RESOLVABLE_ADDRESS: hci_opcode_t = hci_opcode_t(8236);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_ADDRESS_RESOLUTION_ENABLED: hci_opcode_t = hci_opcode_t(8237);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT: hci_opcode_t =
        hci_opcode_t(8238);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_MAXIMUM_DATA_LENGTH: hci_opcode_t = hci_opcode_t(8239);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_PHY: hci_opcode_t = hci_opcode_t(8240);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_DEFAULT_PHY: hci_opcode_t = hci_opcode_t(8241);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PHY: hci_opcode_t = hci_opcode_t(8242);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_RECEIVER_TEST_V2: hci_opcode_t = hci_opcode_t(8243);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_TRANSMITTER_TEST_V2: hci_opcode_t = hci_opcode_t(8244);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_ADVERTISING_SET_RANDOM_ADDRESS: hci_opcode_t =
        hci_opcode_t(8245);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EXTENDED_ADVERTISING_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8246);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EXTENDED_ADVERTISING_DATA: hci_opcode_t = hci_opcode_t(8247);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EXTENDED_SCAN_RESPONSE_DATA: hci_opcode_t = hci_opcode_t(8248);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EXTENDED_ADVERTISING_ENABLE: hci_opcode_t = hci_opcode_t(8249);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_MAXIMUM_ADVERTISING_DATA_LENGTH: hci_opcode_t =
        hci_opcode_t(8250);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_NUMBER_OF_SUPPORTED_ADVERTISING_SETS: hci_opcode_t =
        hci_opcode_t(8251);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOVE_ADVERTISING_SET: hci_opcode_t = hci_opcode_t(8252);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CLEAR_ADVERTISING_SETS: hci_opcode_t = hci_opcode_t(8253);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PERIODIC_ADVERTISING_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8254);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PERIODIC_ADVERTISING_DATA: hci_opcode_t = hci_opcode_t(8255);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PERIODIC_ADVERTISING_ENABLE: hci_opcode_t = hci_opcode_t(8256);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EXTENDED_SCAN_PARAMETERS: hci_opcode_t = hci_opcode_t(8257);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_EXTENDED_SCAN_ENABLE: hci_opcode_t = hci_opcode_t(8258);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_EXTENDED_CREATE_CONNECTION: hci_opcode_t = hci_opcode_t(8259);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC: hci_opcode_t = hci_opcode_t(8260);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_PERIODIC_ADVERTISING_CREATE_SYNC_CANCEL: hci_opcode_t =
        hci_opcode_t(8261);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_PERIODIC_ADVERTISING_TERMINATE_SYNC: hci_opcode_t =
        hci_opcode_t(8262);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ADD_DEVICE_TO_PERIODIC_ADVERTISER_LIST: hci_opcode_t =
        hci_opcode_t(8263);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOVE_DEVICE_FROM_PERIODIC_ADVERTISER_LIST: hci_opcode_t =
        hci_opcode_t(8264);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CLEAR_PERIODIC_ADVERTISER_LIST: hci_opcode_t = hci_opcode_t(8265);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_PERIODIC_ADVERTISER_LIST_SIZE: hci_opcode_t =
        hci_opcode_t(8266);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_TRANSMIT_POWER: hci_opcode_t = hci_opcode_t(8267);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_RF_PATH_COMPENSATION: hci_opcode_t = hci_opcode_t(8268);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_WRITE_RF_PATH_COMPENSATION: hci_opcode_t = hci_opcode_t(8269);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PRIVACY_MODE: hci_opcode_t = hci_opcode_t(8270);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_RECEIVER_TEST_V3: hci_opcode_t = hci_opcode_t(8271);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_TRANSMITTER_TEST_V3: hci_opcode_t = hci_opcode_t(8272);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8273);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CONNECTIONLESS_CTE_TRANSMIT_ENABLE: hci_opcode_t =
        hci_opcode_t(8274);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CONNECTIONLESS_IQ_SAMPLING_ENABLE: hci_opcode_t =
        hci_opcode_t(8275);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CONNECTION_CTE_RECEIVE_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8276);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CONNECTION_CTE_TRANSMIT_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8277);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CONNECTION_CTE_REQUEST_ENABLE: hci_opcode_t = hci_opcode_t(8278);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CONNECTION_CTE_RESPONSE_ENABLE: hci_opcode_t = hci_opcode_t(8279);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_ANTENNA_INFORMATION: hci_opcode_t = hci_opcode_t(8280);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PERIODIC_ADVERTISING_RECEIVE_ENABLE: hci_opcode_t =
        hci_opcode_t(8281);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER: hci_opcode_t =
        hci_opcode_t(8282);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_PERIODIC_ADVERTISING_SET_INFO_TRANSFER: hci_opcode_t =
        hci_opcode_t(8283);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8284);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_DEFAULT_PERIODIC_ADVERTISING_SYNC_TRANSFER_PARAMETERS:
        hci_opcode_t = hci_opcode_t(8285);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_GENERATE_DHKEY_V2: hci_opcode_t = hci_opcode_t(8286);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_MODIFY_SLEEP_CLOCK_ACCURACY: hci_opcode_t = hci_opcode_t(8287);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_BUFFER_SIZE_V2: hci_opcode_t = hci_opcode_t(8288);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_ISO_TX_SYNC: hci_opcode_t = hci_opcode_t(8289);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CIG_PARAMETERS: hci_opcode_t = hci_opcode_t(8290);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_CIG_PARAMETERS_TEST: hci_opcode_t = hci_opcode_t(8291);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CREATE_CIS: hci_opcode_t = hci_opcode_t(8292);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOVE_CIG: hci_opcode_t = hci_opcode_t(8293);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ACCEPT_CIS_REQUEST: hci_opcode_t = hci_opcode_t(8294);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REJECT_CIS_REQUEST: hci_opcode_t = hci_opcode_t(8295);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CREATE_BIG: hci_opcode_t = hci_opcode_t(8296);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_CREATE_BIG_TEST: hci_opcode_t = hci_opcode_t(8297);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_TERMINATE_BIG: hci_opcode_t = hci_opcode_t(8298);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_BIG_CREATE_SYNC: hci_opcode_t = hci_opcode_t(8299);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_BIG_TERMINATE_SYNC: hci_opcode_t = hci_opcode_t(8300);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REQUEST_PEER_SCA: hci_opcode_t = hci_opcode_t(8301);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SETUP_ISO_DATA_PATH: hci_opcode_t = hci_opcode_t(8302);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_REMOVE_ISO_DATA_PATH: hci_opcode_t = hci_opcode_t(8303);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ISO_TRANSMIT_TEST: hci_opcode_t = hci_opcode_t(8304);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ISO_RECEIVE_TEST: hci_opcode_t = hci_opcode_t(8305);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ISO_READ_TEST_COUNTERS: hci_opcode_t = hci_opcode_t(8306);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ISO_TEST_END: hci_opcode_t = hci_opcode_t(8307);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_HOST_FEATURE: hci_opcode_t = hci_opcode_t(8308);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_ISO_LINK_QUALITY: hci_opcode_t = hci_opcode_t(8309);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL: hci_opcode_t =
        hci_opcode_t(8310);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL: hci_opcode_t = hci_opcode_t(8311);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PATH_LOSS_REPORTING_PARAMETERS: hci_opcode_t =
        hci_opcode_t(8312);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_PATH_LOSS_REPORTING_ENABLE: hci_opcode_t = hci_opcode_t(8313);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE: hci_opcode_t =
        hci_opcode_t(8314);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_LE_TRANSMITTER_TEST_V4: hci_opcode_t = hci_opcode_t(8315);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_BCM_WRITE_SCO_PCM_INT: hci_opcode_t = hci_opcode_t(64540);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_BCM_SET_SLEEP_MODE: hci_opcode_t = hci_opcode_t(64551);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_BCM_WRITE_I2SPCM_INTERFACE_PARAM: hci_opcode_t = hci_opcode_t(64621);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_BCM_ENABLE_WBS: hci_opcode_t = hci_opcode_t(64638);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_BCM_WRITE_TX_POWER_TABLE: hci_opcode_t = hci_opcode_t(64969);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_BCM_SET_TX_PWR: hci_opcode_t = hci_opcode_t(64933);
}
impl hci_opcode_t {
    pub const HCI_OPCODE_HCI_TI_VS_CONFIGURE_DDIP: hci_opcode_t = hci_opcode_t(64853);
}
impl ::core::ops::BitOr<hci_opcode_t> for hci_opcode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_opcode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_opcode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_opcode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_opcode_t> for hci_opcode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_opcode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_opcode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_opcode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_opcode_t(pub cty::c_uint);
extern "C" {
    pub static hci_accept_connection_request: hci_cmd_t;
}
extern "C" {
    pub static hci_accept_synchronous_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_authentication_requested: hci_cmd_t;
}
extern "C" {
    pub static hci_change_connection_link_key: hci_cmd_t;
}
extern "C" {
    pub static hci_change_connection_packet_type: hci_cmd_t;
}
extern "C" {
    pub static hci_configure_data_path: hci_cmd_t;
}
extern "C" {
    pub static hci_create_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_create_connection_cancel: hci_cmd_t;
}
extern "C" {
    pub static hci_delete_stored_link_key: hci_cmd_t;
}
extern "C" {
    pub static hci_disconnect: hci_cmd_t;
}
extern "C" {
    pub static hci_enable_device_under_test_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_enhanced_accept_synchronous_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_enhanced_setup_synchronous_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_exit_park_state: hci_cmd_t;
}
extern "C" {
    pub static hci_exit_periodic_inquiry_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_exit_sniff_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_flow_specification: hci_cmd_t;
}
extern "C" {
    pub static hci_flush: hci_cmd_t;
}
extern "C" {
    pub static hci_hold_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_host_buffer_size: hci_cmd_t;
}
extern "C" {
    pub static hci_inquiry: hci_cmd_t;
}
extern "C" {
    pub static hci_inquiry_cancel: hci_cmd_t;
}
extern "C" {
    pub static hci_io_capability_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_io_capability_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_link_key_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_link_key_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_park_state: hci_cmd_t;
}
extern "C" {
    pub static hci_periodic_inquiry_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_pin_code_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_pin_code_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_qos_setup: hci_cmd_t;
}
extern "C" {
    pub static hci_read_bd_addr: hci_cmd_t;
}
extern "C" {
    pub static hci_read_buffer_size: hci_cmd_t;
}
extern "C" {
    pub static hci_read_encryption_key_size: hci_cmd_t;
}
extern "C" {
    pub static hci_read_extended_inquiry_length: hci_cmd_t;
}
extern "C" {
    pub static hci_read_extended_page_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_read_inquiry_scan_activity: hci_cmd_t;
}
extern "C" {
    pub static hci_read_le_host_supported: hci_cmd_t;
}
extern "C" {
    pub static hci_read_link_policy_settings: hci_cmd_t;
}
extern "C" {
    pub static hci_read_link_supervision_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_read_local_extended_oob_data: hci_cmd_t;
}
extern "C" {
    pub static hci_read_local_name: hci_cmd_t;
}
extern "C" {
    pub static hci_read_local_oob_data: hci_cmd_t;
}
extern "C" {
    pub static hci_read_local_supported_commands: hci_cmd_t;
}
extern "C" {
    pub static hci_read_local_supported_features: hci_cmd_t;
}
extern "C" {
    pub static hci_read_local_version_information: hci_cmd_t;
}
extern "C" {
    pub static hci_read_loopback_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_read_num_broadcast_retransmissions: hci_cmd_t;
}
extern "C" {
    pub static hci_read_page_scan_activity: hci_cmd_t;
}
extern "C" {
    pub static hci_read_page_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_read_pin_type: hci_cmd_t;
}
extern "C" {
    pub static hci_read_remote_extended_features_command: hci_cmd_t;
}
extern "C" {
    pub static hci_read_remote_supported_features_command: hci_cmd_t;
}
extern "C" {
    pub static hci_read_remote_version_information: hci_cmd_t;
}
extern "C" {
    pub static hci_read_rssi: hci_cmd_t;
}
extern "C" {
    pub static hci_read_transmit_power_level: hci_cmd_t;
}
extern "C" {
    pub static hci_reject_connection_request: hci_cmd_t;
}
extern "C" {
    pub static hci_remote_name_request: hci_cmd_t;
}
extern "C" {
    pub static hci_remote_name_request_cancel: hci_cmd_t;
}
extern "C" {
    pub static hci_remote_oob_data_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_remote_oob_data_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_remote_oob_extended_data_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_reset: hci_cmd_t;
}
extern "C" {
    pub static hci_role_discovery: hci_cmd_t;
}
extern "C" {
    pub static hci_set_connection_encryption: hci_cmd_t;
}
extern "C" {
    pub static hci_set_controller_to_host_flow_control: hci_cmd_t;
}
extern "C" {
    pub static hci_set_ecosystem_base_interval: hci_cmd_t;
}
extern "C" {
    pub static hci_set_event_mask: hci_cmd_t;
}
extern "C" {
    pub static hci_set_event_mask_2: hci_cmd_t;
}
extern "C" {
    pub static hci_set_min_encryption_key_size: hci_cmd_t;
}
extern "C" {
    pub static hci_setup_synchronous_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_sniff_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_sniff_subrating: hci_cmd_t;
}
extern "C" {
    pub static hci_switch_role_command: hci_cmd_t;
}
extern "C" {
    pub static hci_user_confirmation_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_user_confirmation_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_user_passkey_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_user_passkey_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_write_authentication_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_write_automatic_flush_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_write_class_of_device: hci_cmd_t;
}
extern "C" {
    pub static hci_write_current_iac_lap_two_iacs: hci_cmd_t;
}
extern "C" {
    pub static hci_write_default_erroneous_data_reporting: hci_cmd_t;
}
extern "C" {
    pub static hci_write_default_link_policy_setting: hci_cmd_t;
}
extern "C" {
    pub static hci_write_extended_inquiry_length: hci_cmd_t;
}
extern "C" {
    pub static hci_write_extended_inquiry_response: hci_cmd_t;
}
extern "C" {
    pub static hci_write_extended_page_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_write_inquiry_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_write_inquiry_scan_activity: hci_cmd_t;
}
extern "C" {
    pub static hci_write_inquiry_scan_type: hci_cmd_t;
}
extern "C" {
    pub static hci_write_le_host_supported: hci_cmd_t;
}
extern "C" {
    pub static hci_write_link_policy_settings: hci_cmd_t;
}
extern "C" {
    pub static hci_write_link_supervision_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_write_local_name: hci_cmd_t;
}
extern "C" {
    pub static hci_write_loopback_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_write_num_broadcast_retransmissions: hci_cmd_t;
}
extern "C" {
    pub static hci_write_page_scan_activity: hci_cmd_t;
}
extern "C" {
    pub static hci_write_page_scan_type: hci_cmd_t;
}
extern "C" {
    pub static hci_write_page_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_write_pin_type: hci_cmd_t;
}
extern "C" {
    pub static hci_write_scan_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_write_secure_connections_host_support: hci_cmd_t;
}
extern "C" {
    pub static hci_write_secure_connections_test_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_write_simple_pairing_debug_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_write_simple_pairing_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_write_synchronous_flow_control_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_accept_cis_request: hci_cmd_t;
}
extern "C" {
    pub static hci_le_add_device_to_periodic_advertiser_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_add_device_to_resolving_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_add_device_to_white_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_big_create_sync: hci_cmd_t;
}
extern "C" {
    pub static hci_le_big_terminate_sync: hci_cmd_t;
}
extern "C" {
    pub static hci_le_clear_advertising_sets: hci_cmd_t;
}
extern "C" {
    pub static hci_le_clear_periodic_advertiser_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_clear_resolving_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_clear_white_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_connection_cte_request_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_connection_cte_response_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_connection_update: hci_cmd_t;
}
extern "C" {
    pub static hci_le_create_big: hci_cmd_t;
}
extern "C" {
    pub static hci_le_create_big_test: hci_cmd_t;
}
extern "C" {
    pub static hci_le_create_cis: hci_cmd_t;
}
extern "C" {
    pub static hci_le_create_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_le_create_connection_cancel: hci_cmd_t;
}
extern "C" {
    pub static hci_le_encrypt: hci_cmd_t;
}
extern "C" {
    pub static hci_le_enhanced_read_transmit_power_level: hci_cmd_t;
}
extern "C" {
    pub static hci_le_extended_create_connection: hci_cmd_t;
}
extern "C" {
    pub static hci_le_generate_dhkey: hci_cmd_t;
}
extern "C" {
    pub static hci_le_generate_dhkey_v2: hci_cmd_t;
}
extern "C" {
    pub static hci_le_iso_read_test_counters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_iso_receive_test: hci_cmd_t;
}
extern "C" {
    pub static hci_le_iso_test_end: hci_cmd_t;
}
extern "C" {
    pub static hci_le_iso_transmit_test: hci_cmd_t;
}
extern "C" {
    pub static hci_le_long_term_key_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_le_long_term_key_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_le_modify_sleep_clock_accuracy: hci_cmd_t;
}
extern "C" {
    pub static hci_le_periodic_advertising_create_sync: hci_cmd_t;
}
extern "C" {
    pub static hci_le_periodic_advertising_create_sync_cancel: hci_cmd_t;
}
extern "C" {
    pub static hci_le_periodic_advertising_set_info_transfer: hci_cmd_t;
}
extern "C" {
    pub static hci_le_periodic_advertising_sync_transfer: hci_cmd_t;
}
extern "C" {
    pub static hci_le_periodic_advertising_terminate_sync: hci_cmd_t;
}
extern "C" {
    pub static hci_le_rand: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_advertising_channel_tx_power: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_antenna_information: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_buffer_size: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_buffer_size_v2: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_channel_map: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_iso_link_quality: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_iso_tx_sync: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_local_p256_public_key: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_local_resolvable_address: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_local_supported_features: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_maximum_advertising_data_length: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_maximum_data_length: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_number_of_supported_advertising_sets: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_peer_resolvable_address: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_periodic_advertiser_list_size: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_phy: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_remote_transmit_power_level: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_remote_used_features: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_resolving_list_size: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_rf_path_compensation: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_suggested_default_data_length: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_supported_states: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_transmit_power: hci_cmd_t;
}
extern "C" {
    pub static hci_le_read_white_list_size: hci_cmd_t;
}
extern "C" {
    pub static hci_le_receiver_test: hci_cmd_t;
}
extern "C" {
    pub static hci_le_receiver_test_v2: hci_cmd_t;
}
extern "C" {
    pub static hci_le_receiver_test_v3: hci_cmd_t;
}
extern "C" {
    pub static hci_le_reject_cis_request: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remote_connection_parameter_request_negative_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remote_connection_parameter_request_reply: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remove_advertising_set: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remove_cig: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remove_device_from_periodic_advertiser_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remove_device_from_resolving_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remove_device_from_white_list: hci_cmd_t;
}
extern "C" {
    pub static hci_le_remove_iso_data_path: hci_cmd_t;
}
extern "C" {
    pub static hci_le_request_peer_sca: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_address_resolution_enabled: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_advertise_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_advertising_data: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_advertising_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_advertising_set_random_address: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_cig_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_cig_parameters_test: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_connection_cte_receive_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_connection_cte_transmit_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_connectionless_cte_transmit_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_connectionless_cte_transmit_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_connectionless_iq_sampling_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_data_length: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_default_periodic_advertising_sync_transfer_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_default_phy: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_event_mask: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_extended_advertising_data: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_extended_advertising_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_extended_advertising_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_extended_scan_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_extended_scan_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_extended_scan_response_data: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_host_channel_classification: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_host_feature: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_path_loss_reporting_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_path_loss_reporting_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_periodic_advertising_data: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_periodic_advertising_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_periodic_advertising_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_periodic_advertising_receive_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_periodic_advertising_sync_transfer_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_phy: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_privacy_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_random_address: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_resolvable_private_address_timeout: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_scan_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_scan_parameters: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_scan_response_data: hci_cmd_t;
}
extern "C" {
    pub static hci_le_set_transmit_power_reporting_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_le_setup_iso_data_path: hci_cmd_t;
}
extern "C" {
    pub static hci_le_start_encryption: hci_cmd_t;
}
extern "C" {
    pub static hci_le_terminate_big: hci_cmd_t;
}
extern "C" {
    pub static hci_le_test_end: hci_cmd_t;
}
extern "C" {
    pub static hci_le_transmitter_test: hci_cmd_t;
}
extern "C" {
    pub static hci_le_transmitter_test_v2: hci_cmd_t;
}
extern "C" {
    pub static hci_le_transmitter_test_v3: hci_cmd_t;
}
extern "C" {
    pub static hci_le_transmitter_test_v4: hci_cmd_t;
}
extern "C" {
    pub static hci_le_write_rf_path_compensation: hci_cmd_t;
}
extern "C" {
    pub static hci_le_write_suggested_default_data_length: hci_cmd_t;
}
extern "C" {
    pub static hci_opcode_hci_le_read_buffer_size_v2: hci_cmd_t;
}
extern "C" {
    pub static hci_bcm_enable_wbs: hci_cmd_t;
}
extern "C" {
    pub static hci_bcm_set_sleep_mode: hci_cmd_t;
}
extern "C" {
    pub static hci_bcm_write_i2spcm_interface_param: hci_cmd_t;
}
extern "C" {
    pub static hci_bcm_write_sco_pcm_int: hci_cmd_t;
}
extern "C" {
    pub static hci_bcm_write_tx_power_table: hci_cmd_t;
}
extern "C" {
    pub static hci_bcm_set_tx_pwr: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_avrp_enable: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_configure_ddip: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_drpb_enable_rf_calibration: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_drpb_tester_con_rx: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_drpb_tester_con_tx: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_drpb_tester_packet_tx_rx: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_wbs_associate: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_wbs_disassociate: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_write_codec_config: hci_cmd_t;
}
extern "C" {
    pub static hci_ti_write_hardware_register: hci_cmd_t;
}
extern "C" {
    pub static hci_rtk_configure_sco_routing: hci_cmd_t;
}
extern "C" {
    #[doc = " construct HCI Command based on template\n\n Format:\n   1,2,3,4: one to four byte value\n   H: HCI connection handle\n   B: Bluetooth Baseband Address (BD_ADDR)\n   D: 8 byte data block\n   E: Extended Inquiry Result\n   N: Name up to 248 chars, \\0 terminated\n   P: 16 byte Pairing code\n   A: 31 bytes advertising data\n   S: Service Record (Data Element Sequence)"]
    pub fn hci_cmd_create_from_template(
        hci_cmd_buffer: *mut u8,
        cmd: *const hci_cmd_t,
        argptr: va_list,
    ) -> u16;
}
impl gap_security_level_t {
    pub const LEVEL_0: gap_security_level_t = gap_security_level_t(0);
}
impl gap_security_level_t {
    pub const LEVEL_1: gap_security_level_t = gap_security_level_t(1);
}
impl gap_security_level_t {
    pub const LEVEL_2: gap_security_level_t = gap_security_level_t(2);
}
impl gap_security_level_t {
    pub const LEVEL_3: gap_security_level_t = gap_security_level_t(3);
}
impl gap_security_level_t {
    pub const LEVEL_4: gap_security_level_t = gap_security_level_t(4);
}
impl ::core::ops::BitOr<gap_security_level_t> for gap_security_level_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gap_security_level_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gap_security_level_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gap_security_level_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gap_security_level_t> for gap_security_level_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gap_security_level_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gap_security_level_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gap_security_level_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gap_security_level_t(pub cty::c_uint);
impl gap_security_mode_t {
    pub const GAP_SECURITY_MODE_1: gap_security_mode_t = gap_security_mode_t(1);
}
impl gap_security_mode_t {
    pub const GAP_SECURITY_MODE_2: gap_security_mode_t = gap_security_mode_t(2);
}
impl gap_security_mode_t {
    pub const GAP_SECURITY_MODE_3: gap_security_mode_t = gap_security_mode_t(3);
}
impl gap_security_mode_t {
    pub const GAP_SECURITY_MODE_4: gap_security_mode_t = gap_security_mode_t(4);
}
impl ::core::ops::BitOr<gap_security_mode_t> for gap_security_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gap_security_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gap_security_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gap_security_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gap_security_mode_t> for gap_security_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gap_security_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gap_security_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gap_security_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gap_security_mode_t(pub cty::c_uint);
impl gap_security_state {
    pub const GAP_SECURITY_NONE: gap_security_state = gap_security_state(0);
}
impl gap_security_state {
    pub const GAP_SECURITY_ENCRYPTED: gap_security_state = gap_security_state(1);
}
impl gap_security_state {
    pub const GAP_SECURITY_AUTHENTICATED: gap_security_state = gap_security_state(2);
}
impl ::core::ops::BitOr<gap_security_state> for gap_security_state {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gap_security_state(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gap_security_state {
    #[inline]
    fn bitor_assign(&mut self, rhs: gap_security_state) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gap_security_state> for gap_security_state {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gap_security_state(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gap_security_state {
    #[inline]
    fn bitand_assign(&mut self, rhs: gap_security_state) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gap_security_state(pub cty::c_uint);
impl gap_connection_type_t {
    pub const GAP_CONNECTION_INVALID: gap_connection_type_t = gap_connection_type_t(0);
}
impl gap_connection_type_t {
    pub const GAP_CONNECTION_ACL: gap_connection_type_t = gap_connection_type_t(1);
}
impl gap_connection_type_t {
    pub const GAP_CONNECTION_SCO: gap_connection_type_t = gap_connection_type_t(2);
}
impl gap_connection_type_t {
    pub const GAP_CONNECTION_LE: gap_connection_type_t = gap_connection_type_t(3);
}
impl ::core::ops::BitOr<gap_connection_type_t> for gap_connection_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gap_connection_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gap_connection_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gap_connection_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gap_connection_type_t> for gap_connection_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gap_connection_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gap_connection_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gap_connection_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gap_connection_type_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_connection_parameter_range {
    pub le_conn_interval_min: u16,
    pub le_conn_interval_max: u16,
    pub le_conn_latency_min: u16,
    pub le_conn_latency_max: u16,
    pub le_supervision_timeout_min: u16,
    pub le_supervision_timeout_max: u16,
}
pub type le_connection_parameter_range_t = le_connection_parameter_range;
impl gap_random_address_type_t {
    pub const GAP_RANDOM_ADDRESS_TYPE_OFF: gap_random_address_type_t = gap_random_address_type_t(0);
}
impl gap_random_address_type_t {
    pub const GAP_RANDOM_ADDRESS_TYPE_STATIC: gap_random_address_type_t =
        gap_random_address_type_t(1);
}
impl gap_random_address_type_t {
    pub const GAP_RANDOM_ADDRESS_NON_RESOLVABLE: gap_random_address_type_t =
        gap_random_address_type_t(2);
}
impl gap_random_address_type_t {
    pub const GAP_RANDOM_ADDRESS_RESOLVABLE: gap_random_address_type_t =
        gap_random_address_type_t(3);
}
impl ::core::ops::BitOr<gap_random_address_type_t> for gap_random_address_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gap_random_address_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gap_random_address_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gap_random_address_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gap_random_address_type_t> for gap_random_address_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gap_random_address_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gap_random_address_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gap_random_address_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gap_random_address_type_t(pub cty::c_uint);
impl authorization_state_t {
    pub const AUTHORIZATION_UNKNOWN: authorization_state_t = authorization_state_t(0);
}
impl authorization_state_t {
    pub const AUTHORIZATION_PENDING: authorization_state_t = authorization_state_t(1);
}
impl authorization_state_t {
    pub const AUTHORIZATION_DECLINED: authorization_state_t = authorization_state_t(2);
}
impl authorization_state_t {
    pub const AUTHORIZATION_GRANTED: authorization_state_t = authorization_state_t(3);
}
impl ::core::ops::BitOr<authorization_state_t> for authorization_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        authorization_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for authorization_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: authorization_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<authorization_state_t> for authorization_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        authorization_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for authorization_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: authorization_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct authorization_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_extended_advertising_parameters_t {
    pub advertising_event_properties: u16,
    pub primary_advertising_interval_min: u16,
    pub primary_advertising_interval_max: u16,
    pub primary_advertising_channel_map: u8,
    pub own_address_type: bd_addr_type_t,
    pub peer_address_type: bd_addr_type_t,
    pub peer_address: bd_addr_t,
    pub advertising_filter_policy: u8,
    pub advertising_tx_power: i8,
    pub primary_advertising_phy: u8,
    pub secondary_advertising_max_skip: u8,
    pub secondary_advertising_phy: u8,
    pub advertising_sid: u8,
    pub scan_request_notification_enable: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_periodic_advertising_parameters_t {
    pub periodic_advertising_interval_min: u16,
    pub periodic_advertising_interval_max: u16,
    pub periodic_advertising_properties: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_advertising_set_t {
    pub item: btstack_linked_item_t,
    pub extended_params: le_extended_advertising_parameters_t,
    pub periodic_params: le_periodic_advertising_parameters_t,
    pub random_address: bd_addr_t,
    pub adv_data: *const u8,
    pub scan_data: *const u8,
    pub periodic_data: *const u8,
    pub adv_data_len: u16,
    pub scan_data_len: u16,
    pub periodic_data_len: u16,
    pub adv_data_pos: u16,
    pub scan_data_pos: u16,
    pub periodic_data_pos: u16,
    pub enable_timeout: u16,
    pub advertising_handle: u8,
    pub enable_max_scan_events: u8,
    pub periodic_include_adi: bool,
    pub state: u8,
    pub tasks: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_audio_big_params_t {
    pub big_handle: u8,
    pub advertising_handle: u8,
    pub num_bis: u8,
    pub sdu_interval_us: u32,
    pub max_sdu: u16,
    pub max_transport_latency_ms: u16,
    pub rtn: u8,
    pub phy: u8,
    pub packing: u8,
    pub framing: u8,
    pub encryption: u8,
    pub broadcast_code: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_audio_big_sync_params_t {
    pub big_handle: u8,
    pub sync_handle: u8,
    pub encryption: u8,
    pub broadcast_code: [u8; 16usize],
    pub mse: u8,
    pub big_sync_timeout_10ms: u16,
    pub num_bis: u8,
    pub bis_indices: [u8; 2usize],
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_CREATE: le_audio_big_state_t = le_audio_big_state_t(0);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_W4_ESTABLISHED: le_audio_big_state_t = le_audio_big_state_t(1);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_SETUP_ISO_PATH: le_audio_big_state_t = le_audio_big_state_t(2);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_W4_SETUP_ISO_PATH: le_audio_big_state_t = le_audio_big_state_t(3);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_W4_SETUP_ISO_PATH_THEN_TERMINATE: le_audio_big_state_t =
        le_audio_big_state_t(4);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_SETUP_ISO_PATHS_FAILED: le_audio_big_state_t =
        le_audio_big_state_t(5);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_ACTIVE: le_audio_big_state_t = le_audio_big_state_t(6);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_TERMINATE: le_audio_big_state_t = le_audio_big_state_t(7);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_W4_TERMINATED_AFTER_SETUP_FAILED: le_audio_big_state_t =
        le_audio_big_state_t(8);
}
impl le_audio_big_state_t {
    pub const LE_AUDIO_BIG_STATE_W4_TERMINATED: le_audio_big_state_t = le_audio_big_state_t(9);
}
impl ::core::ops::BitOr<le_audio_big_state_t> for le_audio_big_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_big_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_big_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_big_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_big_state_t> for le_audio_big_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_big_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_big_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_big_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_big_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct le_audio_big_t {
    pub item: btstack_linked_item_t,
    pub big_handle: u8,
    pub state: le_audio_big_state_t,
    pub state_vars: le_audio_big_t__bindgen_ty_1,
    pub num_bis: u8,
    pub bis_con_handles: [hci_con_handle_t; 2usize],
    pub params: *const le_audio_big_params_t,
    pub can_send_now_requested: bool,
    pub num_completed_timestamp_previous_valid: bool,
    pub num_completed_timestamp_current_valid: bool,
    pub num_completed_timestamp_previous_ms: u32,
    pub num_completed_timestamp_current_ms: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union le_audio_big_t__bindgen_ty_1 {
    pub next_bis: u8,
    pub status: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct le_audio_big_sync_t {
    pub item: btstack_linked_item_t,
    pub big_handle: u8,
    pub state: le_audio_big_state_t,
    pub state_vars: le_audio_big_sync_t__bindgen_ty_1,
    pub num_bis: u8,
    pub bis_con_handles: [hci_con_handle_t; 2usize],
    pub params: *const le_audio_big_sync_params_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union le_audio_big_sync_t__bindgen_ty_1 {
    pub next_bis: u8,
    pub status: u8,
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_CREATE: le_audio_cig_state_t = le_audio_cig_state_t(0);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_W4_ESTABLISHED: le_audio_cig_state_t = le_audio_cig_state_t(1);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_W4_CIS_REQUEST: le_audio_cig_state_t = le_audio_cig_state_t(2);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_CREATE_CIS: le_audio_cig_state_t = le_audio_cig_state_t(3);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_W4_CREATE_CIS: le_audio_cig_state_t = le_audio_cig_state_t(4);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_SETUP_ISO_PATH: le_audio_cig_state_t = le_audio_cig_state_t(5);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_W4_SETUP_ISO_PATH: le_audio_cig_state_t = le_audio_cig_state_t(6);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_ACTIVE: le_audio_cig_state_t = le_audio_cig_state_t(7);
}
impl le_audio_cig_state_t {
    pub const LE_AUDIO_CIG_STATE_REMOVE: le_audio_cig_state_t = le_audio_cig_state_t(8);
}
impl ::core::ops::BitOr<le_audio_cig_state_t> for le_audio_cig_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_cig_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_cig_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_cig_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_cig_state_t> for le_audio_cig_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_cig_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_cig_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_cig_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_cig_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_audio_cis_params_t {
    pub cis_id: u8,
    pub max_sdu_c_to_p: u16,
    pub max_sdu_p_to_c: u16,
    pub phy_c_to_p: u8,
    pub phy_p_to_c: u8,
    pub rtn_c_to_p: u8,
    pub rtn_p_to_c: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_audio_cig_params_t {
    pub cig_id: u8,
    pub sdu_interval_c_to_p: u32,
    pub sdu_interval_p_to_c: u32,
    pub worst_case_sca: u8,
    pub packing: u8,
    pub framing: u8,
    pub max_transport_latency_c_to_p: u16,
    pub max_transport_latency_p_to_c: u16,
    pub num_cis: u8,
    pub cis_params: [le_audio_cis_params_t; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct le_audio_cig_t {
    pub item: btstack_linked_item_t,
    pub cig_id: u8,
    pub params: *mut le_audio_cig_params_t,
    pub state: le_audio_cig_state_t,
    pub state_vars: le_audio_cig_t__bindgen_ty_1,
    pub num_cis: u8,
    pub cis_con_handles: [hci_con_handle_t; 2usize],
    pub acl_con_handles: [hci_con_handle_t; 2usize],
    pub cis_setup_active: [bool; 2usize],
    pub cis_established: [bool; 2usize],
    pub can_send_now_requested: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union le_audio_cig_t__bindgen_ty_1 {
    pub next_cis: u8,
    pub status: u8,
}
extern "C" {
    #[doc = " @brief Read RSSI\n @param con_handle\n @events: GAP_EVENT_RSSI_MEASUREMENT"]
    pub fn gap_read_rssi(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Gets local address."]
    pub fn gap_local_bd_addr(address_buffer: *mut u8);
}
extern "C" {
    #[doc = " @brief Disconnect connection with handle\n @param handle"]
    pub fn gap_disconnect(handle: hci_con_handle_t) -> u8;
}
extern "C" {
    #[doc = " @brief Get connection type\n @param con_handle\n @result connection_type"]
    pub fn gap_get_connection_type(connection_handle: hci_con_handle_t) -> gap_connection_type_t;
}
extern "C" {
    #[doc = " @brief Get HCI connection role\n @param con_handle\n @result hci_role_t HCI_ROLE_MASTER / HCI_ROLE_SLAVE / HCI_ROLE_INVALID (if connection does not exist)"]
    pub fn gap_get_role(connection_handle: hci_con_handle_t) -> hci_role_t;
}
extern "C" {
    #[doc = " @brief Request role switch\n @note this only requests the role switch. A HCI_EVENT_ROLE_CHANGE is emitted and its status field will indicate if the switch was succesful\n @param addr\n @param hci_role_t HCI_ROLE_MASTER / HCI_ROLE_SLAVE\n @result status"]
    pub fn gap_request_role(addr: *mut u8, role: hci_role_t) -> u8;
}
extern "C" {
    #[doc = " @brief Sets local name.\n @note Default name is 'BTstack 00:00:00:00:00:00'\n @note '00:00:00:00:00:00' in local_name will be replaced with actual bd addr\n @param name is not copied, make sure memory stays valid"]
    pub fn gap_set_local_name(local_name: *const cty::c_char);
}
extern "C" {
    #[doc = " @brief Set Extended Inquiry Response data\n @note If not set, local name will be used for EIR data (see gap_set_local_name)\n @note '00:00:00:00:00:00' in local_name will be replaced with actual bd addr\n @param eir_data size HCI_EXTENDED_INQUIRY_RESPONSE_DATA_LEN (240) bytes, is not copied make sure memory stays valid"]
    pub fn gap_set_extended_inquiry_response(data: *const u8);
}
extern "C" {
    #[doc = " @brief Set class of device"]
    pub fn gap_set_class_of_device(class_of_device: u32);
}
extern "C" {
    #[doc = " @brief Set default link policy settings for all classic ACL links\n @param default_link_policy_settings - see LM_LINK_POLICY_* in bluetooth.h\n @note common value: LM_LINK_POLICY_ENABLE_ROLE_SWITCH | LM_LINK_POLICY_ENABLE_SNIFF_MODE to enable role switch and sniff mode"]
    pub fn gap_set_default_link_policy_settings(default_link_policy_settings: u16);
}
extern "C" {
    #[doc = " @brief Set Allow Role Switch param for outgoing classic ACL links\n @param allow_role_switch - true: allow remote device to request role switch, false: stay master"]
    pub fn gap_set_allow_role_switch(allow_role_switch: bool);
}
extern "C" {
    #[doc = " @brief Set  link supervision timeout for outgoing classic ACL links\n @param default_link_supervision_timeout * 0.625 ms, default 0x7d00 = 20 seconds, 0 = no link supervision timeout"]
    pub fn gap_set_link_supervision_timeout(link_supervision_timeout: u16);
}
extern "C" {
    #[doc = " @brief Enable link watchdog. If no ACL packet is sent within timeout_ms, the link will get disconnected\n note: current implementation uses the automatic flush timeout controller feature with a max timeout of 1.28s\n @param timeout_ms"]
    pub fn gap_enable_link_watchdog(timeout_ms: u16);
}
extern "C" {
    #[doc = " @brief Enable/disable bonding. Default is enabled.\n @param enabled"]
    pub fn gap_set_bondable_mode(enabled: cty::c_int);
}
extern "C" {
    #[doc = " @brief Get bondable mode.\n @return 1 if bondable"]
    pub fn gap_get_bondable_mode() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set security mode for all outgoing and incoming connections. Default: GAP_SECURITY_MODE_4\n @param security_mode is GAP_SECURITY_MODE_2 or GAP_SECURITY_MODE_4\n @return status ERROR_CODE_SUCCESS or ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE"]
    pub fn gap_set_security_mode(security_mode: gap_security_mode_t) -> u8;
}
extern "C" {
    #[doc = " @brief Get security mode\n @return security_mode"]
    pub fn gap_get_security_mode() -> gap_security_mode_t;
}
extern "C" {
    #[doc = " @brief Set security level for all outgoing and incoming connections. Default: LEVEL_2\n @param security_level\n @note has to be called before services or profiles are initialized"]
    pub fn gap_set_security_level(security_level: gap_security_level_t);
}
extern "C" {
    #[doc = " @brief Get security level\n @return security_level"]
    pub fn gap_get_security_level() -> gap_security_level_t;
}
extern "C" {
    #[doc = " @brief Set Secure Connections Only Mode for BR/EDR (Classic) Default: false\n @param enable"]
    pub fn gap_set_secure_connections_only_mode(enable: bool);
}
extern "C" {
    #[doc = " @breif Get Secure Connections Only Mode\n @param enabled"]
    pub fn gap_get_secure_connections_only_mode() -> bool;
}
extern "C" {
    #[doc = " @brief Set minimal security level for registered services\n @param security_level\n @note Called by L2CAP based on registered services"]
    pub fn gap_set_minimal_service_security_level(security_level: gap_security_level_t);
}
extern "C" {
    #[doc = " @brief Register filter for rejecting classic connections. Callback will return 1 accept connection, 0 on reject."]
    pub fn gap_register_classic_connection_filter(
        accept_callback: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut u8, link_type: hci_link_type_t) -> cty::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @brief Enable will enable SSP during init. Default: true"]
    pub fn gap_ssp_set_enable(enable: cty::c_int);
}
extern "C" {
    #[doc = " @brief Set IO Capability. BTstack will return capability to SSP requests"]
    pub fn gap_ssp_set_io_capability(ssp_io_capability: cty::c_int);
}
extern "C" {
    #[doc = " @brief Set Authentication Requirements using during SSP"]
    pub fn gap_ssp_set_authentication_requirement(authentication_requirement: cty::c_int);
}
extern "C" {
    #[doc = " @brief Enable/disable Secure Connections. Default: true if supported by Controller"]
    pub fn gap_secure_connections_enable(enable: bool);
}
extern "C" {
    #[doc = " @brief Query if Secure Connections can be used for Classic connections.\n @note Requires gap_secure_connections_enable == true and Controller to support it"]
    pub fn gap_secure_connections_active() -> bool;
}
extern "C" {
    #[doc = " @brief If set, BTstack will confirm a numeric comparison and enter '000000' if requested."]
    pub fn gap_ssp_set_auto_accept(auto_accept: cty::c_int);
}
extern "C" {
    #[doc = " @brief Set required encryption key size for GAP Levels 1-3 on ccassic connections. Default: 16 bytes\n @param encryption_key_size in bytes. Valid 7..16"]
    pub fn gap_set_required_encryption_key_size(encryption_key_size: u8);
}
extern "C" {
    #[doc = " @brief Start dedicated bonding with device. Disconnect after bonding.\n @param device\n @param request MITM protection\n @return error, if max num acl connections active\n @result GAP_DEDICATED_BONDING_COMPLETE"]
    pub fn gap_dedicated_bonding(
        device: *mut u8,
        mitm_protection_required: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn gap_security_level_for_link_key_type(
        link_key_type: link_key_type_t,
    ) -> gap_security_level_t;
}
extern "C" {
    #[doc = " @brief map link keys to secure connection yes/no"]
    pub fn gap_secure_connection_for_link_key_type(link_key_type: link_key_type_t) -> bool;
}
extern "C" {
    #[doc = " @brief map link keys to authenticated"]
    pub fn gap_authenticated_for_link_key_type(link_key_type: link_key_type_t) -> bool;
}
extern "C" {
    pub fn gap_security_level(con_handle: hci_con_handle_t) -> gap_security_level_t;
}
extern "C" {
    pub fn gap_request_security_level(con_handle: hci_con_handle_t, level: gap_security_level_t);
}
extern "C" {
    pub fn gap_mitm_protection_required_for_security_level(level: gap_security_level_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set Page Scan Type\n @param page_scan_interval * 0.625 ms, range: 0x0012..0x1000, default: 0x0800\n @param page_scan_windows  * 0.625 ms, range: 0x0011..page_scan_interval, default: 0x0012"]
    pub fn gap_set_page_scan_activity(page_scan_interval: u16, page_scan_window: u16);
}
extern "C" {
    #[doc = " @brief Set Page Scan Type\n @param page_scan_mode"]
    pub fn gap_set_page_scan_type(page_scan_type: page_scan_type_t);
}
extern "C" {
    #[doc = " @brief Set Page Timeout\n @param page_timeout * 0.625 ms, range: 0x0001..0xffff, default: 0x6000 (ca 15 seconds)"]
    pub fn gap_set_page_timeout(page_timeout: u16);
}
extern "C" {
    #[doc = " @brief Set parameters for LE Scan\n @param scan_type 0 = passive, 1 = active\n @param scan_interval range 0x0004..0x4000, unit 0.625 ms\n @param scan_window range 0x0004..0x4000, unit 0.625 ms\n @param scanning_filter_policy 0 = all devices, 1 = all from whitelist"]
    pub fn gap_set_scan_params(
        scan_type: u8,
        scan_interval: u16,
        scan_window: u16,
        scanning_filter_policy: u8,
    );
}
extern "C" {
    #[doc = " @brief Set parameters for LE Scan\n @deprecated Use gap_set_scan_params instead"]
    pub fn gap_set_scan_parameters(scan_type: u8, scan_interval: u16, scan_window: u16);
}
extern "C" {
    #[doc = " @brief Set duplicate filter for LE Scan\n @param enabled if enabled, only one advertisements per BD_ADDR is reported, default: false"]
    pub fn gap_set_scan_duplicate_filter(enabled: bool);
}
extern "C" {
    #[doc = " @brief Start LE Scan"]
    pub fn gap_start_scan();
}
extern "C" {
    #[doc = " @brief Stop LE Scan"]
    pub fn gap_stop_scan();
}
extern "C" {
    #[doc = " @brief Enable privacy by using random addresses\n @param random_address_type to use (incl. OFF)"]
    pub fn gap_random_address_set_mode(random_address_type: gap_random_address_type_t);
}
extern "C" {
    #[doc = " @brief Get privacy mode"]
    pub fn gap_random_address_get_mode() -> gap_random_address_type_t;
}
extern "C" {
    #[doc = " @brief Sets update period for random address\n @param period_ms in ms"]
    pub fn gap_random_address_set_update_period(period_ms: cty::c_int);
}
extern "C" {
    #[doc = " @brief Sets a fixed random address for advertising\n @param addr\n @note Sets random address mode to type static"]
    pub fn gap_random_address_set(addr: *mut u8);
}
extern "C" {
    #[doc = " @brief Set Advertisement Data\n @param advertising_data_length\n @param advertising_data (max 31 octets)\n @note data is not copied, pointer has to stay valid\n @note '00:00:00:00:00:00' in advertising_data will be replaced with actual bd addr"]
    pub fn gap_advertisements_set_data(advertising_data_length: u8, advertising_data: *mut u8);
}
extern "C" {
    #[doc = " @brief Set Advertisement Parameters\n @param adv_int_min\n @param adv_int_max\n @param adv_type\n @param direct_address_type\n @param direct_address\n @param channel_map\n @param filter_policy\n @note own_address_type is used from gap_random_address_set_mode"]
    pub fn gap_advertisements_set_params(
        adv_int_min: u16,
        adv_int_max: u16,
        adv_type: u8,
        direct_address_typ: u8,
        direct_address: *mut u8,
        channel_map: u8,
        filter_policy: u8,
    );
}
extern "C" {
    #[doc = " @brief Enable/Disable Advertisements. OFF by default.\n @param enabled"]
    pub fn gap_advertisements_enable(enabled: cty::c_int);
}
extern "C" {
    #[doc = " @brief Set Scan Response Data\n\n @note For scan response data, scannable undirected advertising (ADV_SCAN_IND) need to be used\n\n @param advertising_data_length\n @param advertising_data (max 31 octets)\n @note data is not copied, pointer has to stay valid\n @note '00:00:00:00:00:00' in scan_response_data will be replaced with actual bd addr"]
    pub fn gap_scan_response_set_data(scan_response_data_length: u8, scan_response_data: *mut u8);
}
extern "C" {
    #[doc = " @brief Provide storage for new advertising set and setup on Controller\n @param storage to use by stack, needs to stay valid until adv set is removed with gap_extended_advertising_remove\n @param advertising_parameters\n @param out_advertising_handle to use with other adv config commands\n @return status\n @events: GAP_SUBEVENT_ADVERTISING_SET_INSTALLED"]
    pub fn gap_extended_advertising_setup(
        storage: *mut le_advertising_set_t,
        advertising_parameters: *const le_extended_advertising_parameters_t,
        out_advertising_handle: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @param Set advertising params for advertising set\n @param advertising_handle\n @param advertising_parameters\n @return status"]
    pub fn gap_extended_advertising_set_params(
        advertising_handle: u8,
        advertising_parameters: *const le_extended_advertising_parameters_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @param Get advertising params for advertising set, e.g. to update params\n @param advertising_handle\n @param advertising_parameters\n @return status"]
    pub fn gap_extended_advertising_get_params(
        advertising_handle: u8,
        advertising_parameters: *mut le_extended_advertising_parameters_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @param Set periodic advertising params for advertising set\n @param advertising_handle\n @param advertising_parameters\n @return status"]
    pub fn gap_periodic_advertising_set_params(
        advertising_handle: u8,
        advertising_parameters: *const le_periodic_advertising_parameters_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @param Get params for periodic advertising set, e.g. to update params\n @param advertising_handle\n @param advertising_parameters\n @return status"]
    pub fn gap_periodic_advertising_get_params(
        advertising_handle: u8,
        advertising_parameters: *mut le_periodic_advertising_parameters_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @param Set random addrress for advertising set\n @param advertising_handle\n @param random_address\n @return status"]
    pub fn gap_extended_advertising_set_random_address(
        advertising_handle: u8,
        random_address: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set Advertising Data for a advertisement set\n @param advertising_handle\n @param advertising_data_length\n @param advertising_data\n @return status"]
    pub fn gap_extended_advertising_set_adv_data(
        advertising_handle: u8,
        advertising_data_length: u16,
        advertising_data: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set Scan Response Data for a advertisement set\n @param advertising_handle\n @param scan_response_data_length\n @param scan_response_data\n @return status"]
    pub fn gap_extended_advertising_set_scan_response_data(
        advertising_handle: u8,
        scan_response_data_length: u16,
        scan_response_data: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set data for periodic advertisement set\n @param advertising_handle\n @param periodic_data_length\n @param periodic_data\n @return status"]
    pub fn gap_periodic_advertising_set_data(
        advertising_handle: u8,
        periodic_data_length: u16,
        periodic_data: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Start advertising advertising set\n @param advertising_handle\n @param timeout in 10ms, or 0 == no timeout\n @param num_extended_advertising_events Controller shall send, or 0 == no max number\n @return status"]
    pub fn gap_extended_advertising_start(
        advertising_handle: u8,
        timeout: u16,
        num_extended_advertising_events: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Stop advertising\n @param advertising_handle\n @return status"]
    pub fn gap_extended_advertising_stop(advertising_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Start periodic advertising for given advertising set\n @param advertising_handle\n @param include_adi\n @return status"]
    pub fn gap_periodic_advertising_start(advertising_handle: u8, include_adi: bool) -> u8;
}
extern "C" {
    #[doc = " @brief Stop periodic advertising for given advertising set\n @param advertising_handle\n @return status"]
    pub fn gap_periodic_advertising_stop(advertising_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Set Default Periodic Advertising Sync Transfer Parameters\n @note The parameters are used for all subsequent connections over the LE transport.\n       If mode != 0, an HCI_LE_Periodic_Advertising_Sync_Transfer_Received event will be emitted by the Controller\n @param mode 0 = ignore (default), 1 = periodic advertising events disabled\n             2 = periodic advertising events enabled with duplicate filtering\n             3 = periodic advertising events enabled with duplicate filtering\n @return status\n @param skip The number of periodic advertising packets that can be skipped after a successful receive\n @param sync_timeout Range: 0x000A to 0x4000, Time = N*10 ms, Time Range: 100 ms to 163.84 s\n @param cte_type  bit 0 = Do not sync to packets with an AoA Constant Tone Extension\n                  bit 1 = Do not sync to packets with an AoD Constant Tone Extension with 1 s slots\n                  bit 2 = Do not sync to packets with an AoD Constant Tone Extension with 2 s slots\n                  bit 3 = Do not sync to packets without a Constant Tone Extension"]
    pub fn gap_periodic_advertising_sync_transfer_set_default_parameters(
        mode: u8,
        skip: u16,
        sync_timeout: u16,
        cte_type: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Send Periodic Advertising Sync Transfer to connected device\n @param con_handle of connected device\n @param service_data 16-bit data to trasnfer to remote host\n @param sync_handle of periodic advertising train to transfer\n @return"]
    pub fn gap_periodic_advertising_sync_transfer_send(
        con_handle: hci_con_handle_t,
        service_data: u16,
        sync_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Remove advertising set from Controller\n @param advertising_handle\n @return status\n @events GAP_SUBEVENT_ADVERTISING_SET_REMOVED"]
    pub fn gap_extended_advertising_remove(advertising_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Create Broadcast Isochronous Group (BIG)\n @param storage to use by stack, needs to stay valid until adv set is removed with gap_big_terminate\n @param big_params\n @return status\n @events GAP_SUBEVENT_BIG_CREATED unless interrupted by call to gap_big_terminate"]
    pub fn gap_big_create(
        storage: *mut le_audio_big_t,
        big_params: *mut le_audio_big_params_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Terminate Broadcast Isochronous Group (BIG)\n @param big_handle\n @return status\n @events: GAP_SUBEVENT_BIG_TERMINATED"]
    pub fn gap_big_terminate(big_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Synchronize to Broadcast Isochronous Group (BIG)\n @param storage to use by stack, needs to stay valid until adv set is removed with gap_big_terminate\n @param big_sync_params\n @return status\n @events GAP_SUBEVENT_BIG_SYNC_CREATED unless interrupted by call to gap_big_sync_terminate"]
    pub fn gap_big_sync_create(
        storage: *mut le_audio_big_sync_t,
        big_sync_params: *mut le_audio_big_sync_params_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Stop synchronizing to Broadcast Isochronous Group (BIG). Triggers GAP_SUBEVENT_BIG_SYNC_STOPPED\n @note Also used to stop synchronizing before BIG Sync was established\n @param big_handle\n @return status\n @events GAP_SUBEVENT_BIG_SYNC_STOPPED"]
    pub fn gap_big_sync_terminate(big_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Create Connected Isochronous Group (CIG)\n @param storage to use by stack, needs to stay valid until CIG removed with gap_cig_remove\n @param cig_params\n @return status\n @events GAP_SUBEVENT_CIG_CREATED unless interrupted by call to gap_cig_remove"]
    pub fn gap_cig_create(
        storage: *mut le_audio_cig_t,
        cig_params: *mut le_audio_cig_params_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Remove Connected Isochronous Group (CIG)\n @param cig_handle\n @return status\n @events GAP_SUBEVENT_CIG_TERMINATED"]
    pub fn gap_cig_remove(cig_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Create Connected Isochronous Streams (CIS)\n @note number of CIS from cig_params in gap_cig_create is used\n @param cig_handle\n @param cis_con_handles array of CIS Connection Handles\n @param acl_con_handles array of ACL Connection Handles\n @return status\n @events GAP_SUBEVENT_CIS_CREATED unless interrupted by call to gap_cig_remove"]
    pub fn gap_cis_create(
        cig_handle: u8,
        cis_con_handles: *mut hci_con_handle_t,
        acl_con_handles: *mut hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Accept Connected Isochronous Stream (CIS)\n @param cis_con_handle\n @return status\n @events GAP_SUBEVENT_CIS_CREATED"]
    pub fn gap_cis_accept(cis_con_handle: hci_con_handle_t) -> u8;
}
extern "C" {
    #[doc = " @brief Reject Connected Isochronous Stream (CIS)\n @param cis_con_handle\n @return status\n @events GAP_SUBEVENT_CIS_CREATED"]
    pub fn gap_cis_reject(cis_con_handle: hci_con_handle_t) -> u8;
}
extern "C" {
    #[doc = " @brief Set connection parameters for outgoing connections\n @param conn_scan_interval (unit: 0.625 msec), default: 60 ms\n @param conn_scan_window (unit: 0.625 msec), default: 30 ms\n @param conn_interval_min (unit: 1.25ms), default: 10 ms\n @param conn_interval_max (unit: 1.25ms), default: 30 ms\n @param conn_latency, default: 4\n @param supervision_timeout (unit: 10ms), default: 720 ms\n @param min_ce_length (unit: 0.625ms), default: 10 ms\n @param max_ce_length (unit: 0.625ms), default: 30 ms"]
    pub fn gap_set_connection_parameters(
        conn_scan_interval: u16,
        conn_scan_window: u16,
        conn_interval_min: u16,
        conn_interval_max: u16,
        conn_latency: u16,
        supervision_timeout: u16,
        min_ce_length: u16,
        max_ce_length: u16,
    );
}
extern "C" {
    #[doc = " @brief Request an update of the connection parameter for a given LE connection\n @param handle\n @param conn_interval_min (unit: 1.25ms)\n @param conn_interval_max (unit: 1.25ms)\n @param conn_latency\n @param supervision_timeout (unit: 10ms)\n @return 0 if ok"]
    pub fn gap_request_connection_parameter_update(
        con_handle: hci_con_handle_t,
        conn_interval_min: u16,
        conn_interval_max: u16,
        conn_latency: u16,
        supervision_timeout: u16,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Updates the connection parameters for a given LE connection\n @param handle\n @param conn_interval_min (unit: 1.25ms)\n @param conn_interval_max (unit: 1.25ms)\n @param conn_latency\n @param supervision_timeout (unit: 10ms)\n @return 0 if ok"]
    pub fn gap_update_connection_parameters(
        con_handle: hci_con_handle_t,
        conn_interval_min: u16,
        conn_interval_max: u16,
        conn_latency: u16,
        supervision_timeout: u16,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set accepted connection parameter range\n @param range"]
    pub fn gap_get_connection_parameter_range(range: *mut le_connection_parameter_range_t);
}
extern "C" {
    #[doc = " @brief Get accepted connection parameter range\n @param range"]
    pub fn gap_set_connection_parameter_range(range: *mut le_connection_parameter_range_t);
}
extern "C" {
    #[doc = " @brief Test if connection parameters are inside in existing rage\n @param conn_interval_min (unit: 1.25ms)\n @param conn_interval_max (unit: 1.25ms)\n @param conn_latency\n @param supervision_timeout (unit: 10ms)\n @return 1 if included"]
    pub fn gap_connection_parameter_range_included(
        existing_range: *mut le_connection_parameter_range_t,
        le_conn_interval_min: u16,
        le_conn_interval_max: u16,
        le_conn_latency: u16,
        le_supervision_timeout: u16,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set max number of connections in LE Peripheral role (if Bluetooth Controller supports it)\n @note: default: 1\n @param max_peripheral_connections"]
    pub fn gap_set_max_number_peripheral_connections(max_peripheral_connections: cty::c_int);
}
extern "C" {
    #[doc = " @brief Add Device to Whitelist\n @param address_typ\n @param address\n @return 0 if ok"]
    pub fn gap_whitelist_add(address_type: bd_addr_type_t, address: *mut u8) -> u8;
}
extern "C" {
    #[doc = " @brief Remove Device from Whitelist\n @param address_typ\n @param address\n @return 0 if ok"]
    pub fn gap_whitelist_remove(address_type: bd_addr_type_t, address: *mut u8) -> u8;
}
extern "C" {
    #[doc = " @brief Clear Whitelist\n @return 0 if ok"]
    pub fn gap_whitelist_clear() -> u8;
}
extern "C" {
    #[doc = " @brief Connect to remote LE device"]
    pub fn gap_connect(addr: *mut u8, addr_type: bd_addr_type_t) -> u8;
}
extern "C" {
    #[doc = "  @brief Connect with Whitelist\n  @note Explicit whitelist management and this connect with whitelist replace deprecated gap_auto_connection_* functions\n  @return - if ok"]
    pub fn gap_connect_with_whitelist() -> u8;
}
extern "C" {
    #[doc = " @brief Cancel connection process initiated by gap_connect"]
    pub fn gap_connect_cancel() -> u8;
}
extern "C" {
    #[doc = " @brief Auto Connection Establishment - Start Connecting to device\n @deprecated Please setup Whitelist with gap_whitelist_* and start connecting with gap_connect_with_whitelist\n @param address_type\n @param address\n @return 0 if ok"]
    pub fn gap_auto_connection_start(address_type: bd_addr_type_t, address: *mut u8) -> u8;
}
extern "C" {
    #[doc = " @brief Auto Connection Establishment - Stop Connecting to device\n @deprecated Please setup Whitelist with gap_whitelist_* and start connecting with gap_connect_with_whitelist\n @param address_type\n @param address\n @return 0 if ok"]
    pub fn gap_auto_connection_stop(address_type: bd_addr_type_t, address: *mut u8) -> u8;
}
extern "C" {
    #[doc = " @brief Auto Connection Establishment - Stop everything\n @deprecated Please setup Whitelist with gap_whitelist_* and start connecting with gap_connect_with_whitelist\n @note  Convenience function to stop all active auto connection attempts"]
    pub fn gap_auto_connection_stop_all() -> u8;
}
extern "C" {
    #[doc = " @brief Set LE PHY\n @param con_handle\n @param all_phys 0 = set rx/tx, 1 = set only rx, 2 = set only tx\n @param tx_phys 1 = 1M, 2 = 2M, 4 = Coded\n @param rx_phys 1 = 1M, 2 = 2M, 4 = Coded\n @param phy_options 0 = no preferred coding for Coded, 1 = S=2 coding (500 kbit), 2 = S=8 coding (125 kbit)\n @return 0 if ok"]
    pub fn gap_le_set_phy(
        con_handle: hci_con_handle_t,
        all_phys: u8,
        tx_phys: u8,
        rx_phys: u8,
        phy_options: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Get connection interval\n @param con_handle\n @return connection interval, otherwise 0 if error"]
    pub fn gap_le_connection_interval(con_handle: hci_con_handle_t) -> u16;
}
extern "C" {
    #[doc = " @brief Get encryption key size.\n @param con_handle\n @return 0 if not encrypted, 7-16 otherwise"]
    pub fn gap_encryption_key_size(con_handle: hci_con_handle_t) -> u8;
}
extern "C" {
    #[doc = " @brief Get authentication property.\n @param con_handle\n @return 1 if bonded with OOB/Passkey (AND MITM protection)"]
    pub fn gap_authenticated(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get secure connection property\n @param con_handle\n @return 1 if bonded usiung LE Secure Connections"]
    pub fn gap_secure_connection(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief Queries authorization state.\n @param con_handle\n @return authorization_state for the current session"]
    pub fn gap_authorization_state(con_handle: hci_con_handle_t) -> authorization_state_t;
}
extern "C" {
    #[doc = " @brief Get bonded property (BR/EDR/LE)\n @note LE: has to be called after identity resolving is complete\n @param con_handle\n @return true if bonded"]
    pub fn gap_bonded(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get own addr type and address used for LE for next scan/advertisement/connect operation"]
    pub fn gap_le_get_own_address(addr_type: *mut u8, addr: *mut u8);
}
extern "C" {
    #[doc = " @brief Get own addr type and address used for LE advertisements (Peripheral)"]
    pub fn gap_le_get_own_advertisements_address(addr_type: *mut u8, addr: *mut u8);
}
extern "C" {
    #[doc = " @brief Get own addr type and address used for LE connections (Central)"]
    pub fn gap_le_get_own_connection_address(addr_type: *mut u8, addr: *mut u8);
}
extern "C" {
    #[doc = " @brief Get state of connection re-encryption for bonded devices when in central role\n @note used by gatt_client and att_server to wait for re-encryption\n @param con_handle\n @return 1 if security setup is active"]
    pub fn gap_reconnect_security_setup_active(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Delete bonding information for remote device\n @note On most desktop ports, the LE Device DB uses a TLV and there is one TLV storage per\n       Controller resp. its Bluetooth Address. As the Bluetooth Address is retrieved during\n       power up, this function only works, when the stack is in working state for these ports.\n @param address_type\n @param address"]
    pub fn gap_delete_bonding(address_type: bd_addr_type_t, address: *mut u8);
}
extern "C" {
    #[doc = " Set Privacy Mode for use in Resolving List. Default: LE_PRIVACY_MODE_DEVICE\n @note Only applies for new devices added to resolving list, please call before startup\n @param privacy_mode"]
    pub fn gap_set_peer_privacy_mode(privacy_mode: le_privacy_mode_t);
}
extern "C" {
    #[doc = " @brief Load LE Device DB entries into Controller Resolving List to allow filtering on\n        bonded devies with resolvable private addresses\n @return EROOR_CODE_SUCCESS if supported by Controller"]
    pub fn gap_load_resolving_list_from_le_device_db() -> u8;
}
extern "C" {
    #[doc = " @brief Get local persistent IRK"]
    pub fn gap_get_persistent_irk() -> *const u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_transport_t {
    #[doc = " transport name"]
    pub name: *const cty::c_char,
    #[doc = " init transport\n @param transport_config"]
    pub init: ::core::option::Option<unsafe extern "C" fn(transport_config: *const cty::c_void)>,
    #[doc = " open transport connection"]
    pub open: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    #[doc = " close transport connection"]
    pub close: ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>,
    #[doc = " register packet handler for HCI packets: ACL, SCO, and Events"]
    pub register_packet_handler: ::core::option::Option<
        unsafe extern "C" fn(
            handler: ::core::option::Option<
                unsafe extern "C" fn(packet_type: u8, packet: *mut u8, size: u16),
            >,
        ),
    >,
    #[doc = " support async transport layers, e.g. IRQ driven without buffers"]
    pub can_send_packet_now:
        ::core::option::Option<unsafe extern "C" fn(packet_type: u8) -> cty::c_int>,
    #[doc = " send packet"]
    pub send_packet: ::core::option::Option<
        unsafe extern "C" fn(packet_type: u8, packet: *mut u8, size: cty::c_int) -> cty::c_int,
    >,
    #[doc = " extension for UART transport implementations"]
    pub set_baudrate: ::core::option::Option<unsafe extern "C" fn(baudrate: u32) -> cty::c_int>,
    #[doc = " extension for UART H5 on CSR: reset BCSP/H5 Link"]
    pub reset_link: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " extension for USB transport implementations: config SCO connections"]
    pub set_sco_config: ::core::option::Option<
        unsafe extern "C" fn(voice_setting: u16, num_connections: cty::c_int),
    >,
}
impl hci_transport_config_type_t {
    pub const HCI_TRANSPORT_CONFIG_UART: hci_transport_config_type_t =
        hci_transport_config_type_t(0);
}
impl hci_transport_config_type_t {
    pub const HCI_TRANSPORT_CONFIG_USB: hci_transport_config_type_t =
        hci_transport_config_type_t(1);
}
impl ::core::ops::BitOr<hci_transport_config_type_t> for hci_transport_config_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_transport_config_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_transport_config_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_transport_config_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_transport_config_type_t> for hci_transport_config_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_transport_config_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_transport_config_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_transport_config_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_transport_config_type_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_transport_config_t {
    pub type_: hci_transport_config_type_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_transport_config_uart_t {
    pub type_: hci_transport_config_type_t,
    pub baudrate_init: u32,
    pub baudrate_main: u32,
    pub flowcontrol: cty::c_int,
    pub device_name: *const cty::c_char,
    pub parity: cty::c_int,
}
pub type btstack_time_t = u32;
impl btstack_data_source_callback_type_t {
    pub const DATA_SOURCE_CALLBACK_POLL: btstack_data_source_callback_type_t =
        btstack_data_source_callback_type_t(1);
}
impl btstack_data_source_callback_type_t {
    pub const DATA_SOURCE_CALLBACK_READ: btstack_data_source_callback_type_t =
        btstack_data_source_callback_type_t(2);
}
impl btstack_data_source_callback_type_t {
    pub const DATA_SOURCE_CALLBACK_WRITE: btstack_data_source_callback_type_t =
        btstack_data_source_callback_type_t(4);
}
impl ::core::ops::BitOr<btstack_data_source_callback_type_t>
    for btstack_data_source_callback_type_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        btstack_data_source_callback_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for btstack_data_source_callback_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: btstack_data_source_callback_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<btstack_data_source_callback_type_t>
    for btstack_data_source_callback_type_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        btstack_data_source_callback_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for btstack_data_source_callback_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: btstack_data_source_callback_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Callback types for run loop data sources"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct btstack_data_source_callback_type_t(pub cty::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btstack_data_source {
    pub item: btstack_linked_item_t,
    pub source: btstack_data_source__bindgen_ty_1,
    pub process: ::core::option::Option<
        unsafe extern "C" fn(
            ds: *mut btstack_data_source,
            callback_type: btstack_data_source_callback_type_t,
        ),
    >,
    pub flags: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btstack_data_source__bindgen_ty_1 {
    pub fd: cty::c_int,
    pub handle: *mut cty::c_void,
}
pub type btstack_data_source_t = btstack_data_source;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_timer_source {
    pub item: btstack_linked_item_t,
    pub timeout: btstack_time_t,
    pub process: ::core::option::Option<unsafe extern "C" fn(ts: *mut btstack_timer_source)>,
    pub context: *mut cty::c_void,
}
pub type btstack_timer_source_t = btstack_timer_source;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_run_loop {
    pub init: ::core::option::Option<unsafe extern "C" fn()>,
    pub add_data_source:
        ::core::option::Option<unsafe extern "C" fn(data_source: *mut btstack_data_source_t)>,
    pub remove_data_source: ::core::option::Option<
        unsafe extern "C" fn(data_source: *mut btstack_data_source_t) -> bool,
    >,
    pub enable_data_source_callbacks: ::core::option::Option<
        unsafe extern "C" fn(data_source: *mut btstack_data_source_t, callbacks: u16),
    >,
    pub disable_data_source_callbacks: ::core::option::Option<
        unsafe extern "C" fn(data_source: *mut btstack_data_source_t, callbacks: u16),
    >,
    pub set_timer: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut btstack_timer_source_t, timeout_in_ms: u32),
    >,
    pub add_timer: ::core::option::Option<unsafe extern "C" fn(timer: *mut btstack_timer_source_t)>,
    pub remove_timer:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut btstack_timer_source_t) -> bool>,
    pub execute: ::core::option::Option<unsafe extern "C" fn()>,
    pub dump_timer: ::core::option::Option<unsafe extern "C" fn()>,
    pub get_time_ms: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub poll_data_sources_from_irq: ::core::option::Option<unsafe extern "C" fn()>,
    pub execute_on_main_thread: ::core::option::Option<
        unsafe extern "C" fn(callback_registration: *mut btstack_context_callback_registration_t),
    >,
    pub trigger_exit: ::core::option::Option<unsafe extern "C" fn()>,
}
pub type btstack_run_loop_t = btstack_run_loop;
extern "C" {
    pub static mut btstack_run_loop_base_timers: btstack_linked_list_t;
}
extern "C" {
    pub static mut btstack_run_loop_base_data_sources: btstack_linked_list_t;
}
extern "C" {
    pub static mut btstack_run_loop_base_callbacks: btstack_linked_list_t;
}
extern "C" {
    #[doc = " @brief Init"]
    pub fn btstack_run_loop_base_init();
}
extern "C" {
    #[doc = " @brief Add timer source.\n @param timer to add"]
    pub fn btstack_run_loop_base_add_timer(timer: *mut btstack_timer_source_t);
}
extern "C" {
    #[doc = " @brief Remove timer source.\n @param timer to remove\n @return true if timer was removed"]
    pub fn btstack_run_loop_base_remove_timer(timer: *mut btstack_timer_source_t) -> bool;
}
extern "C" {
    #[doc = " @brief Process timers: remove expired timers from list and call their process function\n @param now"]
    pub fn btstack_run_loop_base_process_timers(now: u32);
}
extern "C" {
    #[doc = " @brief Dump list of timers via log_info"]
    pub fn btstack_run_loop_base_dump_timer();
}
extern "C" {
    #[doc = " @brief Get time until first timer fires\n @return -1 if no timers, time until next timeout otherwise"]
    pub fn btstack_run_loop_base_get_time_until_timeout(now: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Add data source to run loop\n @param data_source to add"]
    pub fn btstack_run_loop_base_add_data_source(data_source: *mut btstack_data_source_t);
}
extern "C" {
    #[doc = " @brief Remove data source from run loop\n @param data_source to remove\n @return true if data srouce was removed"]
    pub fn btstack_run_loop_base_remove_data_source(
        data_source: *mut btstack_data_source_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Enable callbacks for a data source\n @param data_source to remove\n @param callback_types to enable"]
    pub fn btstack_run_loop_base_enable_data_source_callbacks(
        data_source: *mut btstack_data_source_t,
        callback_types: u16,
    );
}
extern "C" {
    #[doc = " @brief Enable callbacks for a data source\n @param data_source to remove\n @param callback_types to disable"]
    pub fn btstack_run_loop_base_disable_data_source_callbacks(
        data_source: *mut btstack_data_source_t,
        callback_types: u16,
    );
}
extern "C" {
    #[doc = " @brief Poll data sources. It calls the procss function for all data sources where DATA_SOURCE_CALLBACK_POLL is set"]
    pub fn btstack_run_loop_base_poll_data_sources();
}
extern "C" {
    #[doc = " @bried Add Callbacks to list of callbacks to execute with btstack_run_loop_base_execute_callbacks"]
    pub fn btstack_run_loop_base_add_callback(
        callback_registration: *mut btstack_context_callback_registration_t,
    );
}
extern "C" {
    #[doc = " @bried Process Callbacks: remove all callback-registrations and call the registered function with its context"]
    pub fn btstack_run_loop_base_execute_callbacks();
}
extern "C" {
    #[doc = " @brief Init main run loop. Must be called before any other run loop call.\n\n Use btstack_run_loop_$(btstack_run_loop_TYPE)_get_instance() from btstack_run_loop_$(btstack_run_loop_TYPE).h to get instance"]
    pub fn btstack_run_loop_init(run_loop: *const btstack_run_loop_t);
}
extern "C" {
    #[doc = " @brief Set timer based on current time in milliseconds."]
    pub fn btstack_run_loop_set_timer(timer: *mut btstack_timer_source_t, timeout_in_ms: u32);
}
extern "C" {
    #[doc = " @brief Set callback that will be executed when timer expires."]
    pub fn btstack_run_loop_set_timer_handler(
        timer: *mut btstack_timer_source_t,
        process: ::core::option::Option<unsafe extern "C" fn(_timer: *mut btstack_timer_source_t)>,
    );
}
extern "C" {
    #[doc = " @brief Set context for this timer"]
    pub fn btstack_run_loop_set_timer_context(
        timer: *mut btstack_timer_source_t,
        context: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief Get context for this timer"]
    pub fn btstack_run_loop_get_timer_context(
        timer: *mut btstack_timer_source_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Add timer source."]
    pub fn btstack_run_loop_add_timer(timer: *mut btstack_timer_source_t);
}
extern "C" {
    #[doc = " @brief Remove timer source."]
    pub fn btstack_run_loop_remove_timer(timer: *mut btstack_timer_source_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get current time in ms\n @note 32-bit ms counter will overflow after approx. 52 days"]
    pub fn btstack_run_loop_get_time_ms() -> u32;
}
extern "C" {
    #[doc = " @brief Dump timers using log_info"]
    pub fn btstack_run_loop_timer_dump();
}
extern "C" {
    #[doc = " @brief Set data source callback."]
    pub fn btstack_run_loop_set_data_source_handler(
        data_source: *mut btstack_data_source_t,
        process: ::core::option::Option<
            unsafe extern "C" fn(
                _data_source: *mut btstack_data_source_t,
                callback_type: btstack_data_source_callback_type_t,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @brief Set data source file descriptor.\n @param data_source\n @param fd file descriptor\n @note No effect if port doensn't have file descriptors"]
    pub fn btstack_run_loop_set_data_source_fd(
        data_source: *mut btstack_data_source_t,
        fd: cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get data source file descriptor.\n @param data_source"]
    pub fn btstack_run_loop_get_data_source_fd(
        data_source: *mut btstack_data_source_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set data source file descriptor.\n @param data_source\n @param handle\n @note No effect if port doensn't have file descriptors"]
    pub fn btstack_run_loop_set_data_source_handle(
        data_source: *mut btstack_data_source_t,
        handle: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief Get data source file descriptor.\n @param data_source"]
    pub fn btstack_run_loop_get_data_source_handle(
        data_source: *mut btstack_data_source_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Enable callbacks for a data source\n @param data_source to remove\n @param callback types to enable"]
    pub fn btstack_run_loop_enable_data_source_callbacks(
        data_source: *mut btstack_data_source_t,
        callbacks: u16,
    );
}
extern "C" {
    #[doc = " @brief Enable callbacks for a data source\n @param data_source to remove\n @param callback types to disable"]
    pub fn btstack_run_loop_disable_data_source_callbacks(
        data_source: *mut btstack_data_source_t,
        callbacks: u16,
    );
}
extern "C" {
    #[doc = " @brief Add data source to run loop\n @param data_source to add"]
    pub fn btstack_run_loop_add_data_source(data_source: *mut btstack_data_source_t);
}
extern "C" {
    #[doc = " @brief Remove data source from run loop\n @param data_source to remove"]
    pub fn btstack_run_loop_remove_data_source(
        data_source: *mut btstack_data_source_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Poll data sources - called only from IRQ context\n @note Can be used to trigger processing of received peripheral data on the main thread\n       by registering a data source with DATA_SOURCE_CALLBACK_POLL and calling this\n       function from the IRQ handler."]
    pub fn btstack_run_loop_poll_data_sources_from_irq();
}
extern "C" {
    #[doc = " @brief Execute configured run loop. This function does not return."]
    pub fn btstack_run_loop_execute();
}
extern "C" {
    #[doc = " @brief Registers callback with run loop and mark main thread as ready\n @note If callback is already registered, the call will be ignored.\n       This function allows to implement, e.g., a quque-based message passing mechanism:\n       The external thread puts an item into a queue and call this function to trigger\n       processing by the BTstack main thread. If this happens multiple times, it is\n       guranteed that the callback will run at least once after the last item was added.\n @param callback_registration"]
    pub fn btstack_run_loop_execute_on_main_thread(
        callback_registration: *mut btstack_context_callback_registration_t,
    );
}
extern "C" {
    #[doc = " @brief Trigger exit of active run loop (started via btstack_run_loop_execute) if possible\n @note This is only supported if there's a loop in the btstack_run_loop_execute function.\n It is not supported if timers and data sources are only mapped to RTOS equivalents, e.g.\n in the Qt or Core Foundation implementations."]
    pub fn btstack_run_loop_trigger_exit();
}
extern "C" {
    #[doc = " @brief De-Init Run Loop"]
    pub fn btstack_run_loop_deinit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct att_connection {
    pub con_handle: hci_con_handle_t,
    pub mtu: u16,
    pub max_mtu: u16,
    pub mtu_exchanged: bool,
    pub encryption_key_size: u8,
    pub authenticated: u8,
    pub authorized: u8,
    pub secure_connection: u8,
}
pub type att_connection_t = att_connection;
#[doc = " @brief ATT Client Read Callback for Dynamic Data\n - if buffer == NULL, don't copy data, just return size of value\n - if buffer != NULL, copy data and return number bytes copied\n If ENABLE_ATT_DELAYED_READ_RESPONSE is defined, you may return ATT_READ_RESPONSE_PENDING if data isn't available yet\n @param con_handle of hci le connection\n @param attribute_handle to be read\n @param offset defines start of attribute value\n @param buffer\n @param buffer_size\n @return size of value if buffer is NULL, otherwise number of bytes copied"]
pub type att_read_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        con_handle: hci_con_handle_t,
        attribute_handle: u16,
        offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16,
>;
#[doc = " @brief ATT Client Write Callback for Dynamic Data\n Each Prepared Write Request triggers a callback with transaction mode ATT_TRANSACTION_MODE_ACTIVE.\n On Execute Write, the callback will be called with ATT_TRANSACTION_MODE_VALIDATE and allows to validate all queued writes and return an application error.\n If none of the registered callbacks return an error for ATT_TRANSACTION_MODE_VALIDATE and the callback will be called with ATT_TRANSACTION_MODE_EXECUTE.\n Otherwise, all callbacks will be called with ATT_TRANSACTION_MODE_CANCEL.\n\n If the additional validation step is not needed, just return 0 for all callbacks with transaction mode ATT_TRANSACTION_MODE_VALIDATE.\n\n @param con_handle of hci le connection\n @param attribute_handle to be written\n @param transaction - ATT_TRANSACTION_MODE_NONE for regular writes. For prepared writes: ATT_TRANSACTION_MODE_ACTIVE, ATT_TRANSACTION_MODE_VALIDATE, ATT_TRANSACTION_MODE_EXECUTE, ATT_TRANSACTION_MODE_CANCEL\n @param offset into the value - used for queued writes and long attributes\n @param buffer\n @param buffer_size\n @param signature used for signed write commmands\n @return 0 if write was ok, ATT_ERROR_PREPARE_QUEUE_FULL if no space in queue, ATT_ERROR_INVALID_OFFSET if offset is larger than max buffer"]
pub type att_write_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        con_handle: hci_con_handle_t,
        attribute_handle: u16,
        transaction_mode: u16,
        offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct att_service_handler {
    pub item: *mut btstack_linked_item_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub read_callback: att_read_callback_t,
    pub write_callback: att_write_callback_t,
    pub packet_handler: btstack_packet_handler_t,
}
pub type att_service_handler_t = att_service_handler;
extern "C" {
    #[doc = " @brief setup ATT database\n @param db"]
    pub fn att_set_db(db: *const u8);
}
extern "C" {
    pub fn att_set_read_callback(callback: att_read_callback_t);
}
extern "C" {
    #[doc = " @brief set callback for write of dynamic attributes\n @param callback"]
    pub fn att_set_write_callback(callback: att_write_callback_t);
}
extern "C" {
    #[doc = " @brief debug helper, dump ATT database to stdout using log_info"]
    pub fn att_dump_attributes();
}
extern "C" {
    #[doc = " @brief process ATT request against database and put response into response buffer\n @param att_connection used for mtu and security properties\n @param request_buffer, request_len: ATT request from clinet\n @param response_buffer for result\n @return len of data in response buffer. 0 = no response,\n          ATT_READ_RESPONSE_PENDING if it was returned at least once for dynamic data (requires ENABLE_ATT_DELAYED_READ_RESPONSE)"]
    pub fn att_handle_request(
        att_connection: *mut att_connection_t,
        request_buffer: *mut u8,
        request_len: u16,
        response_buffer: *mut u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief setup value notification in response buffer for a given handle and value\n @param att_connection\n @param attribute_handle\n @param value\n @param value_len\n @param response_buffer for notification"]
    pub fn att_prepare_handle_value_notification(
        att_connection: *mut att_connection_t,
        attribute_handle: u16,
        value: *const u8,
        value_len: u16,
        response_buffer: *mut u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief setup value indication in response buffer for a given handle and value\n @param att_connection\n @param attribute_handle\n @param value\n @param value_len\n @param response_buffer for indication"]
    pub fn att_prepare_handle_value_indication(
        att_connection: *mut att_connection_t,
        attribute_handle: u16,
        value: *const u8,
        value_len: u16,
        response_buffer: *mut u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief transcation queue of prepared writes, e.g., after disconnect\n @return att_connection"]
    pub fn att_clear_transaction_queue(att_connection: *mut att_connection_t);
}
extern "C" {
    #[doc = " @brief Handle read of blob like data for att_read_callback\n @param blob of data\n @param blob_size of blob\n @param offset from att_read_callback\n @param buffer from att_read_callback\n @param buffer_size from att_read_callback\n @return value size for buffer == 0 and num bytes copied otherwise"]
    pub fn att_read_callback_handle_blob(
        blob: *const u8,
        blob_size: u16,
        offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Handle read of little endian unsigned 32 bit value for att_read_callback\n @param value\n @param offset from att_read_callback\n @param buffer from att_read_callback\n @param buffer_size from att_read_callback\n @return value size for buffer == 0 and num bytes copied otherwise"]
    pub fn att_read_callback_handle_little_endian_32(
        value: u32,
        offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Handle read of little endian unsigned 16 bit value for att_read_callback\n @param value\n @param offset from att_read_callback\n @param buffer from att_read_callback\n @param buffer_size from att_read_callback\n @return value size for buffer == 0 and num bytes copied otherwise"]
    pub fn att_read_callback_handle_little_endian_16(
        value: u16,
        offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Handle read of single byte for att_read_callback\n @param blob of data\n @param blob_size of blob\n @param offset from att_read_callback\n @param buffer from att_read_callback\n @param buffer_size from att_read_callback\n @return value size for buffer == 0 and num bytes copied otherwise"]
    pub fn att_read_callback_handle_byte(
        value: u8,
        offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get UUID for handle\n @param attribute_handle\n @return 0 if not found"]
    pub fn att_uuid_for_handle(attribute_handle: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Get handle range for primary service.\n @param uuid16\n @param start_handle\n @param end_handle\n @return false if not found"]
    pub fn gatt_server_get_handle_range_for_service_with_uuid16(
        uuid16: u16,
        start_handle: *mut u16,
        end_handle: *mut u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get handle range for included service.\n @param start_handle\n @param end_handle\n @param uuid16\n @param out_included_service_handle\n @param out_included_service_start_handle\n @param out_included_service_end_handle\n @return false if not found"]
    pub fn gatt_server_get_included_service_with_uuid16(
        start_handle: u16,
        end_handle: u16,
        uuid16: u16,
        out_included_service_handle: *mut u16,
        out_included_service_start_handle: *mut u16,
        out_included_service_end_handle: *mut u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get value handle for characteristic.\n @param start_handle\n @param end_handle\n @param uuid16\n @return 0 if not found"]
    pub fn gatt_server_get_value_handle_for_characteristic_with_uuid16(
        start_handle: u16,
        end_handle: u16,
        uuid16: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get descriptor handle for characteristic.\n @param start_handle\n @param end_handle\n @param characteristic_uuid16\n @param descriptor_uuid16\n @return 0 if not found"]
    pub fn gatt_server_get_descriptor_handle_for_characteristic_with_uuid16(
        start_handle: u16,
        end_handle: u16,
        characteristic_uuid16: u16,
        descriptor_uuid16: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get client configuration handle for characteristic.\n @param start_handle\n @param end_handle\n @param characteristic_uuid16\n @return 0 if not found"]
    pub fn gatt_server_get_client_configuration_handle_for_characteristic_with_uuid16(
        start_handle: u16,
        end_handle: u16,
        characteristic_uuid16: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get server configuration handle for characteristic.\n @param start_handle\n @param end_handle\n @param characteristic_uuid16\n @param descriptor_uuid16\n @return 0 if not found"]
    pub fn gatt_server_get_server_configuration_handle_for_characteristic_with_uuid16(
        start_handle: u16,
        end_handle: u16,
        characteristic_uuid16: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get handle range for primary service.\n @param uuid128\n @param start_handle\n @param end_handle\n @return false if not found"]
    pub fn gatt_server_get_handle_range_for_service_with_uuid128(
        uuid128: *const u8,
        start_handle: *mut u16,
        end_handle: *mut u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get value handle.\n @param start_handle\n @param end_handle\n @param uuid128\n @return 0 if not found"]
    pub fn gatt_server_get_value_handle_for_characteristic_with_uuid128(
        start_handle: u16,
        end_handle: u16,
        uuid128: *const u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get client configuration handle.\n @param start_handle\n @param end_handle\n @param uuid128\n @return 0 if not found"]
    pub fn gatt_server_get_client_configuration_handle_for_characteristic_with_uuid128(
        start_handle: u16,
        end_handle: u16,
        uuid128: *const u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Check if writes to handle should be persistent\n @param handle\n @return 1 if persistent"]
    pub fn att_is_persistent_ccc(handle: u16) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: cty::c_int,
    pub rem: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: cty::c_longlong,
    pub rem: cty::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> cty::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut cty::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const cty::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const cty::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const cty::c_void,
        __base: *const cty::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn calloc(arg1: cty::c_uint, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn div(__numer: cty::c_int, __denom: cty::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: cty::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn getenv(__string: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _findenv(arg1: *const cty::c_char, arg2: *mut cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut cty::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut cty::c_char,
        arg2: *const *mut cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn labs(arg1: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn ldiv(__numer: cty::c_long, __denom: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const cty::c_char, arg2: usize) -> cty::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const cty::c_char, arg3: usize) -> cty::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const cty::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut cty::c_char, arg2: wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const cty::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const cty::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut cty::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut cty::c_char, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _mkostemp_r(arg1: *mut _reent, arg2: *mut cty::c_char, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _mkstemps_r(arg1: *mut _reent, arg2: *mut cty::c_char, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn qsort(__base: *mut cty::c_void, __nmemb: usize, __size: usize, _compar: __compar_fn_t);
}
extern "C" {
    pub fn rand() -> cty::c_int;
}
extern "C" {
    pub fn realloc(arg1: *mut cty::c_void, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn reallocarray(arg1: *mut cty::c_void, arg2: usize, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut cty::c_void, arg2: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn realpath(path: *const cty::c_char, resolved_path: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn srand(__seed: cty::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const cty::c_char, __end_PTR: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const cty::c_char, __end_PTR: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn system(__string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn a64l(__input: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn l64a(__input: cty::c_long) -> *mut cty::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: cty::c_long) -> *mut cty::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void),
        >,
        __arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _Exit(__status: cty::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _reallocf_r(arg1: *mut _reent, arg2: *mut cty::c_void, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const cty::c_char,
        __value: *const cty::c_char,
        __overwrite: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const cty::c_char,
        __value: *const cty::c_char,
        __overwrite: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __itoa(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn __utoa(arg1: cty::c_uint, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn itoa(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn utoa(arg1: cty::c_uint, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut cty::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort);
}
extern "C" {
    pub fn lrand48() -> cty::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> cty::c_long;
}
extern "C" {
    pub fn mrand48() -> cty::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> cty::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn _seed48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: cty::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: cty::c_long);
}
extern "C" {
    pub fn initstate(arg1: cty::c_uint, arg2: *mut cty::c_char, arg3: usize) -> *mut cty::c_char;
}
extern "C" {
    pub fn random() -> cty::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn srandom(arg1: cty::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: cty::c_longlong, __denom: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn posix_memalign(arg1: *mut *mut cty::c_void, arg2: usize, arg3: usize) -> cty::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: cty::c_int,
        arg4: cty::c_int,
        arg5: *mut cty::c_int,
        arg6: *mut cty::c_int,
        arg7: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut cty::c_void);
}
extern "C" {
    pub fn _realloc_r(arg1: *mut _reent, arg2: *mut cty::c_void, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut cty::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
        arg4: *const cty::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut cty::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut cty::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *const cty::c_void,
                arg3: *const cty::c_void,
            ) -> cty::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const cty::c_char, arg2: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(arg1: cty::c_uint, arg2: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: cty::c_int);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_NONE: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(0);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_SEND_REQUEST: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(1);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_SEND_RESPONSE: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(2);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_CHANGE_HCI_CON_PARAMETERS: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(3);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_DENY: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(4);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_REPLY: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(5);
}
impl le_con_parameter_update_state_t {
    pub const CON_PARAMETER_UPDATE_NEGATIVE_REPLY: le_con_parameter_update_state_t =
        le_con_parameter_update_state_t(6);
}
impl ::core::ops::BitOr<le_con_parameter_update_state_t> for le_con_parameter_update_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_con_parameter_update_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_con_parameter_update_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_con_parameter_update_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_con_parameter_update_state_t> for le_con_parameter_update_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_con_parameter_update_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_con_parameter_update_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_con_parameter_update_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " LE connection parameter update state"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_con_parameter_update_state_t(pub cty::c_uint);
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_NONE: hci_authentication_flags_t = hci_authentication_flags_t(0);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_HANDLE_LINK_KEY_REQUEST: hci_authentication_flags_t =
        hci_authentication_flags_t(1);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_DENY_PIN_CODE_REQUEST: hci_authentication_flags_t =
        hci_authentication_flags_t(2);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_RECV_IO_CAPABILITIES_REQUEST: hci_authentication_flags_t =
        hci_authentication_flags_t(4);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_RECV_IO_CAPABILITIES_RESPONSE: hci_authentication_flags_t =
        hci_authentication_flags_t(8);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SEND_IO_CAPABILITIES_REPLY: hci_authentication_flags_t =
        hci_authentication_flags_t(16);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SEND_IO_CAPABILITIES_NEGATIVE_REPLY: hci_authentication_flags_t =
        hci_authentication_flags_t(32);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SEND_USER_CONFIRM_REPLY: hci_authentication_flags_t =
        hci_authentication_flags_t(64);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SEND_USER_CONFIRM_NEGATIVE_REPLY: hci_authentication_flags_t =
        hci_authentication_flags_t(128);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SEND_USER_PASSKEY_REPLY: hci_authentication_flags_t =
        hci_authentication_flags_t(256);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SEND_REMOTE_OOB_DATA_REPLY: hci_authentication_flags_t =
        hci_authentication_flags_t(512);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_LEGACY_PAIRING_ACTIVE: hci_authentication_flags_t =
        hci_authentication_flags_t(1024);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_SSP_PAIRING_ACTIVE: hci_authentication_flags_t =
        hci_authentication_flags_t(2048);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_PAIRING_ACTIVE_MASK: hci_authentication_flags_t =
        hci_authentication_flags_t(3072);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_CONNECTION_AUTHENTICATED: hci_authentication_flags_t =
        hci_authentication_flags_t(4096);
}
impl hci_authentication_flags_t {
    pub const AUTH_FLAG_CONNECTION_ENCRYPTED: hci_authentication_flags_t =
        hci_authentication_flags_t(8192);
}
impl ::core::ops::BitOr<hci_authentication_flags_t> for hci_authentication_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_authentication_flags_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_authentication_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_authentication_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_authentication_flags_t> for hci_authentication_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_authentication_flags_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_authentication_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_authentication_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_authentication_flags_t(pub cty::c_uint);
impl CONNECTION_STATE {
    pub const SEND_CREATE_CONNECTION: CONNECTION_STATE = CONNECTION_STATE(0);
}
impl CONNECTION_STATE {
    pub const SENT_CREATE_CONNECTION: CONNECTION_STATE = CONNECTION_STATE(1);
}
impl CONNECTION_STATE {
    pub const RECEIVED_CONNECTION_REQUEST: CONNECTION_STATE = CONNECTION_STATE(2);
}
impl CONNECTION_STATE {
    pub const ACCEPTED_CONNECTION_REQUEST: CONNECTION_STATE = CONNECTION_STATE(3);
}
impl CONNECTION_STATE {
    pub const OPEN: CONNECTION_STATE = CONNECTION_STATE(4);
}
impl CONNECTION_STATE {
    pub const SEND_DISCONNECT: CONNECTION_STATE = CONNECTION_STATE(5);
}
impl CONNECTION_STATE {
    pub const SENT_DISCONNECT: CONNECTION_STATE = CONNECTION_STATE(6);
}
impl CONNECTION_STATE {
    pub const RECEIVED_DISCONNECTION_COMPLETE: CONNECTION_STATE = CONNECTION_STATE(7);
}
impl ::core::ops::BitOr<CONNECTION_STATE> for CONNECTION_STATE {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        CONNECTION_STATE(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for CONNECTION_STATE {
    #[inline]
    fn bitor_assign(&mut self, rhs: CONNECTION_STATE) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<CONNECTION_STATE> for CONNECTION_STATE {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        CONNECTION_STATE(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for CONNECTION_STATE {
    #[inline]
    fn bitand_assign(&mut self, rhs: CONNECTION_STATE) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " Connection State"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CONNECTION_STATE(pub cty::c_uint);
pub const BONDING_REMOTE_FEATURES_QUERY_ACTIVE: _bindgen_ty_1 = _bindgen_ty_1(1);
pub const BONDING_REQUEST_REMOTE_FEATURES_PAGE_0: _bindgen_ty_1 = _bindgen_ty_1(2);
pub const BONDING_REQUEST_REMOTE_FEATURES_PAGE_1: _bindgen_ty_1 = _bindgen_ty_1(4);
pub const BONDING_REQUEST_REMOTE_FEATURES_PAGE_2: _bindgen_ty_1 = _bindgen_ty_1(8);
pub const BONDING_RECEIVED_REMOTE_FEATURES: _bindgen_ty_1 = _bindgen_ty_1(16);
pub const BONDING_REMOTE_SUPPORTS_SSP_CONTROLLER: _bindgen_ty_1 = _bindgen_ty_1(32);
pub const BONDING_REMOTE_SUPPORTS_SSP_HOST: _bindgen_ty_1 = _bindgen_ty_1(64);
pub const BONDING_REMOTE_SUPPORTS_SC_CONTROLLER: _bindgen_ty_1 = _bindgen_ty_1(128);
pub const BONDING_REMOTE_SUPPORTS_SC_HOST: _bindgen_ty_1 = _bindgen_ty_1(256);
pub const BONDING_DISCONNECT_SECURITY_BLOCK: _bindgen_ty_1 = _bindgen_ty_1(512);
pub const BONDING_DISCONNECT_DEDICATED_DONE: _bindgen_ty_1 = _bindgen_ty_1(1024);
pub const BONDING_SEND_AUTHENTICATE_REQUEST: _bindgen_ty_1 = _bindgen_ty_1(2048);
pub const BONDING_SENT_AUTHENTICATE_REQUEST: _bindgen_ty_1 = _bindgen_ty_1(4096);
pub const BONDING_SEND_ENCRYPTION_REQUEST: _bindgen_ty_1 = _bindgen_ty_1(8192);
pub const BONDING_SEND_READ_ENCRYPTION_KEY_SIZE: _bindgen_ty_1 = _bindgen_ty_1(16384);
pub const BONDING_DEDICATED: _bindgen_ty_1 = _bindgen_ty_1(32768);
pub const BONDING_EMIT_COMPLETE_ON_DISCONNECT: _bindgen_ty_1 = _bindgen_ty_1(65536);
impl ::core::ops::BitOr<_bindgen_ty_1> for _bindgen_ty_1 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_1(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_1 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_1) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_1> for _bindgen_ty_1 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_1(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_1 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_1) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_1(pub cty::c_uint);
impl BLUETOOTH_STATE {
    pub const BLUETOOTH_OFF: BLUETOOTH_STATE = BLUETOOTH_STATE(1);
}
impl BLUETOOTH_STATE {
    pub const BLUETOOTH_ON: BLUETOOTH_STATE = BLUETOOTH_STATE(2);
}
impl BLUETOOTH_STATE {
    pub const BLUETOOTH_ACTIVE: BLUETOOTH_STATE = BLUETOOTH_STATE(3);
}
impl ::core::ops::BitOr<BLUETOOTH_STATE> for BLUETOOTH_STATE {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        BLUETOOTH_STATE(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for BLUETOOTH_STATE {
    #[inline]
    fn bitor_assign(&mut self, rhs: BLUETOOTH_STATE) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<BLUETOOTH_STATE> for BLUETOOTH_STATE {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        BLUETOOTH_STATE(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for BLUETOOTH_STATE {
    #[inline]
    fn bitand_assign(&mut self, rhs: BLUETOOTH_STATE) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BLUETOOTH_STATE(pub cty::c_uint);
impl le_connecting_state_t {
    pub const LE_CONNECTING_IDLE: le_connecting_state_t = le_connecting_state_t(0);
}
impl le_connecting_state_t {
    pub const LE_CONNECTING_CANCEL: le_connecting_state_t = le_connecting_state_t(1);
}
impl le_connecting_state_t {
    pub const LE_CONNECTING_DIRECT: le_connecting_state_t = le_connecting_state_t(2);
}
impl le_connecting_state_t {
    pub const LE_CONNECTING_WHITELIST: le_connecting_state_t = le_connecting_state_t(3);
}
impl ::core::ops::BitOr<le_connecting_state_t> for le_connecting_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_connecting_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_connecting_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_connecting_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_connecting_state_t> for le_connecting_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_connecting_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_connecting_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_connecting_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_connecting_state_t(pub cty::c_uint);
impl security_manager_state_t {
    pub const SM_GENERAL_IDLE: security_manager_state_t = security_manager_state_t(0);
}
impl security_manager_state_t {
    pub const SM_GENERAL_SEND_PAIRING_FAILED: security_manager_state_t =
        security_manager_state_t(1);
}
impl security_manager_state_t {
    pub const SM_GENERAL_TIMEOUT: security_manager_state_t = security_manager_state_t(2);
}
impl security_manager_state_t {
    pub const SM_GENERAL_REENCRYPTION_FAILED: security_manager_state_t =
        security_manager_state_t(3);
}
impl security_manager_state_t {
    pub const SM_PH1_W4_USER_RESPONSE: security_manager_state_t = security_manager_state_t(4);
}
impl security_manager_state_t {
    pub const SM_PH2_GET_RANDOM_TK: security_manager_state_t = security_manager_state_t(5);
}
impl security_manager_state_t {
    pub const SM_PH2_W4_RANDOM_TK: security_manager_state_t = security_manager_state_t(6);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_GET_RANDOM_A: security_manager_state_t = security_manager_state_t(7);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_W4_RANDOM_A: security_manager_state_t = security_manager_state_t(8);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_GET_RANDOM_B: security_manager_state_t = security_manager_state_t(9);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_W4_RANDOM_B: security_manager_state_t = security_manager_state_t(10);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_GET_ENC_A: security_manager_state_t = security_manager_state_t(11);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_W4_ENC_A: security_manager_state_t = security_manager_state_t(12);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_GET_ENC_C: security_manager_state_t = security_manager_state_t(13);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_W4_ENC_C: security_manager_state_t = security_manager_state_t(14);
}
impl security_manager_state_t {
    pub const SM_PH2_C1_SEND_PAIRING_CONFIRM: security_manager_state_t =
        security_manager_state_t(15);
}
impl security_manager_state_t {
    pub const SM_PH2_SEND_PAIRING_RANDOM: security_manager_state_t = security_manager_state_t(16);
}
impl security_manager_state_t {
    pub const SM_PH2_CALC_STK: security_manager_state_t = security_manager_state_t(17);
}
impl security_manager_state_t {
    pub const SM_PH2_W4_STK: security_manager_state_t = security_manager_state_t(18);
}
impl security_manager_state_t {
    pub const SM_PH2_W4_CONNECTION_ENCRYPTED: security_manager_state_t =
        security_manager_state_t(19);
}
impl security_manager_state_t {
    pub const SM_PH3_Y_GET_ENC: security_manager_state_t = security_manager_state_t(20);
}
impl security_manager_state_t {
    pub const SM_PH3_Y_W4_ENC: security_manager_state_t = security_manager_state_t(21);
}
impl security_manager_state_t {
    pub const SM_PH3_LTK_GET_ENC: security_manager_state_t = security_manager_state_t(22);
}
impl security_manager_state_t {
    pub const SM_PH3_DISTRIBUTE_KEYS: security_manager_state_t = security_manager_state_t(23);
}
impl security_manager_state_t {
    pub const SM_PH3_RECEIVE_KEYS: security_manager_state_t = security_manager_state_t(24);
}
impl security_manager_state_t {
    pub const SM_PH4_W4_CONNECTION_ENCRYPTED: security_manager_state_t =
        security_manager_state_t(25);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_IDLE: security_manager_state_t = security_manager_state_t(26);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_SEND_SECURITY_REQUEST: security_manager_state_t =
        security_manager_state_t(27);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH0_RECEIVED_LTK_REQUEST: security_manager_state_t =
        security_manager_state_t(28);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH0_RECEIVED_LTK_W4_IRK: security_manager_state_t =
        security_manager_state_t(29);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH0_SEND_LTK_REQUESTED_NEGATIVE_REPLY: security_manager_state_t =
        security_manager_state_t(30);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH1_W4_PAIRING_REQUEST: security_manager_state_t =
        security_manager_state_t(31);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED: security_manager_state_t =
        security_manager_state_t(32);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH1_PAIRING_REQUEST_RECEIVED_W4_IRK: security_manager_state_t =
        security_manager_state_t(33);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH1_SEND_PAIRING_RESPONSE: security_manager_state_t =
        security_manager_state_t(34);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH1_W4_PAIRING_CONFIRM: security_manager_state_t =
        security_manager_state_t(35);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH2_W4_PAIRING_RANDOM: security_manager_state_t =
        security_manager_state_t(36);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH2_W4_LTK_REQUEST: security_manager_state_t =
        security_manager_state_t(37);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH2_SEND_LTK_REPLY: security_manager_state_t =
        security_manager_state_t(38);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH4_Y_W4_ENC: security_manager_state_t = security_manager_state_t(39);
}
impl security_manager_state_t {
    pub const SM_RESPONDER_PH4_SEND_LTK_REPLY: security_manager_state_t =
        security_manager_state_t(40);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_CONNECTED: security_manager_state_t = security_manager_state_t(41);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_PH1_W2_SEND_PAIRING_REQUEST: security_manager_state_t =
        security_manager_state_t(42);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_PH1_W4_PAIRING_RESPONSE: security_manager_state_t =
        security_manager_state_t(43);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_PH2_W4_PAIRING_CONFIRM: security_manager_state_t =
        security_manager_state_t(44);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_PH2_W4_PAIRING_RANDOM: security_manager_state_t =
        security_manager_state_t(45);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_PH3_SEND_START_ENCRYPTION: security_manager_state_t =
        security_manager_state_t(46);
}
impl security_manager_state_t {
    pub const SM_INITIATOR_PH4_HAS_LTK: security_manager_state_t = security_manager_state_t(47);
}
impl security_manager_state_t {
    pub const SM_SC_RECEIVED_LTK_REQUEST: security_manager_state_t = security_manager_state_t(48);
}
impl security_manager_state_t {
    pub const SM_SC_SEND_PUBLIC_KEY_COMMAND: security_manager_state_t =
        security_manager_state_t(49);
}
impl security_manager_state_t {
    pub const SM_SC_W4_PUBLIC_KEY_COMMAND: security_manager_state_t = security_manager_state_t(50);
}
impl security_manager_state_t {
    pub const SM_SC_W4_LOCAL_NONCE: security_manager_state_t = security_manager_state_t(51);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CMAC_FOR_CONFIRMATION: security_manager_state_t =
        security_manager_state_t(52);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CMAC_FOR_CONFIRMATION: security_manager_state_t =
        security_manager_state_t(53);
}
impl security_manager_state_t {
    pub const SM_SC_SEND_CONFIRMATION: security_manager_state_t = security_manager_state_t(54);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CMAC_FOR_CHECK_CONFIRMATION: security_manager_state_t =
        security_manager_state_t(55);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CMAC_FOR_CHECK_CONFIRMATION: security_manager_state_t =
        security_manager_state_t(56);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CONFIRMATION: security_manager_state_t = security_manager_state_t(57);
}
impl security_manager_state_t {
    pub const SM_SC_SEND_PAIRING_RANDOM: security_manager_state_t = security_manager_state_t(58);
}
impl security_manager_state_t {
    pub const SM_SC_W4_PAIRING_RANDOM: security_manager_state_t = security_manager_state_t(59);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_G2: security_manager_state_t = security_manager_state_t(60);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_G2: security_manager_state_t = security_manager_state_t(61);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_DHKEY: security_manager_state_t = security_manager_state_t(62);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_F5_SALT: security_manager_state_t = security_manager_state_t(63);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_F5_SALT: security_manager_state_t = security_manager_state_t(64);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_F5_MACKEY: security_manager_state_t = security_manager_state_t(65);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_F5_MACKEY: security_manager_state_t = security_manager_state_t(66);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_F5_LTK: security_manager_state_t = security_manager_state_t(67);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_F5_LTK: security_manager_state_t = security_manager_state_t(68);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_F6_FOR_DHKEY_CHECK: security_manager_state_t =
        security_manager_state_t(69);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_F6_FOR_DHKEY_CHECK: security_manager_state_t =
        security_manager_state_t(70);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK: security_manager_state_t =
        security_manager_state_t(71);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_F6_TO_VERIFY_DHKEY_CHECK: security_manager_state_t =
        security_manager_state_t(72);
}
impl security_manager_state_t {
    pub const SM_SC_W4_USER_RESPONSE: security_manager_state_t = security_manager_state_t(73);
}
impl security_manager_state_t {
    pub const SM_SC_SEND_DHKEY_CHECK_COMMAND: security_manager_state_t =
        security_manager_state_t(74);
}
impl security_manager_state_t {
    pub const SM_SC_W4_DHKEY_CHECK_COMMAND: security_manager_state_t = security_manager_state_t(75);
}
impl security_manager_state_t {
    pub const SM_SC_W4_LTK_REQUEST_SC: security_manager_state_t = security_manager_state_t(76);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_ILK_USING_H6: security_manager_state_t =
        security_manager_state_t(77);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_ILK_USING_H7: security_manager_state_t =
        security_manager_state_t(78);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_ILK: security_manager_state_t = security_manager_state_t(79);
}
impl security_manager_state_t {
    pub const SM_SC_W2_CALCULATE_BR_EDR_LINK_KEY: security_manager_state_t =
        security_manager_state_t(80);
}
impl security_manager_state_t {
    pub const SM_SC_W4_CALCULATE_BR_EDR_LINK_KEY: security_manager_state_t =
        security_manager_state_t(81);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_W4_ENCRYPTION_COMPLETE: security_manager_state_t =
        security_manager_state_t(82);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_INITIATOR_SEND_PAIRING_REQUEST: security_manager_state_t =
        security_manager_state_t(83);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_INITIATOR_W4_PAIRING_RESPONSE: security_manager_state_t =
        security_manager_state_t(84);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_RESPONDER_W4_PAIRING_REQUEST: security_manager_state_t =
        security_manager_state_t(85);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_RESPONDER_PAIRING_REQUEST_RECEIVED: security_manager_state_t =
        security_manager_state_t(86);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_DISTRIBUTE_KEYS: security_manager_state_t = security_manager_state_t(87);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_RECEIVE_KEYS: security_manager_state_t = security_manager_state_t(88);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_W2_CALCULATE_ILK_USING_H6: security_manager_state_t =
        security_manager_state_t(89);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_W2_CALCULATE_ILK_USING_H7: security_manager_state_t =
        security_manager_state_t(90);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_W4_CALCULATE_ILK: security_manager_state_t = security_manager_state_t(91);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_W2_CALCULATE_LE_LTK: security_manager_state_t =
        security_manager_state_t(92);
}
impl security_manager_state_t {
    pub const SM_BR_EDR_W4_CALCULATE_LE_LTK: security_manager_state_t =
        security_manager_state_t(93);
}
impl ::core::ops::BitOr<security_manager_state_t> for security_manager_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        security_manager_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for security_manager_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: security_manager_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<security_manager_state_t> for security_manager_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        security_manager_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for security_manager_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: security_manager_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct security_manager_state_t(pub cty::c_uint);
impl irk_lookup_state_t {
    pub const IRK_LOOKUP_IDLE: irk_lookup_state_t = irk_lookup_state_t(0);
}
impl irk_lookup_state_t {
    pub const IRK_LOOKUP_W4_READY: irk_lookup_state_t = irk_lookup_state_t(1);
}
impl irk_lookup_state_t {
    pub const IRK_LOOKUP_STARTED: irk_lookup_state_t = irk_lookup_state_t(2);
}
impl irk_lookup_state_t {
    pub const IRK_LOOKUP_SUCCEEDED: irk_lookup_state_t = irk_lookup_state_t(3);
}
impl irk_lookup_state_t {
    pub const IRK_LOOKUP_FAILED: irk_lookup_state_t = irk_lookup_state_t(4);
}
impl ::core::ops::BitOr<irk_lookup_state_t> for irk_lookup_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        irk_lookup_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for irk_lookup_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: irk_lookup_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<irk_lookup_state_t> for irk_lookup_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        irk_lookup_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for irk_lookup_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: irk_lookup_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct irk_lookup_state_t(pub cty::c_uint);
pub type sm_pairing_packet_t = [u8; 7usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sm_connection {
    pub sm_handle: hci_con_handle_t,
    pub sm_cid: u16,
    pub sm_role: u8,
    pub sm_security_request_received: u8,
    pub sm_pairing_requested: u8,
    pub sm_peer_addr_type: u8,
    pub sm_peer_address: bd_addr_t,
    pub sm_own_addr_type: u8,
    pub sm_own_address: bd_addr_t,
    pub sm_engine_state: security_manager_state_t,
    pub sm_irk_lookup_state: irk_lookup_state_t,
    pub sm_pairing_failed_reason: u8,
    pub sm_connection_encrypted: u8,
    pub sm_connection_authenticated: u8,
    pub sm_connection_sc: u8,
    pub sm_actual_encryption_key_size: u8,
    pub sm_m_preq: sm_pairing_packet_t,
    pub sm_connection_authorization_state: authorization_state_t,
    pub sm_local_ediv: u16,
    pub sm_local_rand: [u8; 8usize],
    pub sm_le_db_index: cty::c_int,
    pub sm_pairing_active: bool,
    pub sm_reencryption_active: bool,
}
pub type sm_connection_t = sm_connection;
impl att_server_state_t {
    pub const ATT_SERVER_IDLE: att_server_state_t = att_server_state_t(0);
}
impl att_server_state_t {
    pub const ATT_SERVER_REQUEST_RECEIVED: att_server_state_t = att_server_state_t(1);
}
impl att_server_state_t {
    pub const ATT_SERVER_W4_SIGNED_WRITE_VALIDATION: att_server_state_t = att_server_state_t(2);
}
impl att_server_state_t {
    pub const ATT_SERVER_REQUEST_RECEIVED_AND_VALIDATED: att_server_state_t = att_server_state_t(3);
}
impl att_server_state_t {
    pub const ATT_SERVER_RESPONSE_PENDING: att_server_state_t = att_server_state_t(4);
}
impl ::core::ops::BitOr<att_server_state_t> for att_server_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        att_server_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for att_server_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: att_server_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<att_server_state_t> for att_server_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        att_server_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for att_server_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: att_server_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct att_server_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct att_server_t {
    pub state: att_server_state_t,
    pub peer_addr_type: u8,
    pub peer_address: bd_addr_t,
    pub ir_le_device_db_index: cty::c_int,
    pub ir_lookup_active: u8,
    pub pairing_active: u8,
    pub value_indication_handle: u16,
    pub value_indication_timer: btstack_timer_source_t,
    pub notification_requests: btstack_linked_list_t,
    pub indication_requests: btstack_linked_list_t,
    pub request_size: u16,
    pub request_buffer: [u8; 259usize],
}
impl l2cap_information_state_t {
    pub const L2CAP_INFORMATION_STATE_IDLE: l2cap_information_state_t =
        l2cap_information_state_t(0);
}
impl l2cap_information_state_t {
    pub const L2CAP_INFORMATION_STATE_W2_SEND_EXTENDED_FEATURE_REQUEST: l2cap_information_state_t =
        l2cap_information_state_t(1);
}
impl l2cap_information_state_t {
    pub const L2CAP_INFORMATION_STATE_W4_EXTENDED_FEATURE_RESPONSE: l2cap_information_state_t =
        l2cap_information_state_t(2);
}
impl l2cap_information_state_t {
    pub const L2CAP_INFORMATION_STATE_W2_SEND_FIXED_CHANNELS_REQUEST: l2cap_information_state_t =
        l2cap_information_state_t(3);
}
impl l2cap_information_state_t {
    pub const L2CAP_INFORMATION_STATE_W4_FIXED_CHANNELS_RESPONSE: l2cap_information_state_t =
        l2cap_information_state_t(4);
}
impl l2cap_information_state_t {
    pub const L2CAP_INFORMATION_STATE_DONE: l2cap_information_state_t =
        l2cap_information_state_t(5);
}
impl ::core::ops::BitOr<l2cap_information_state_t> for l2cap_information_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        l2cap_information_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for l2cap_information_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: l2cap_information_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<l2cap_information_state_t> for l2cap_information_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        l2cap_information_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for l2cap_information_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: l2cap_information_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct l2cap_information_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_state_t {
    pub information_state: l2cap_information_state_t,
    pub extended_feature_mask: u16,
    pub fixed_channels_supported: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_connection_t {
    pub item: btstack_linked_item_t,
    pub address: bd_addr_t,
    pub con_handle: hci_con_handle_t,
    pub address_type: bd_addr_type_t,
    pub role: u8,
    pub state: CONNECTION_STATE,
    pub bonding_flags: u32,
    pub bonding_status: u8,
    pub encryption_key_size: u8,
    pub requested_security_level: gap_security_level_t,
    pub link_key: link_key_t,
    pub link_key_type: link_key_type_t,
    pub remote_supported_features: [u8; 1usize],
    pub authentication_flags: u16,
    pub gap_connection_tasks: u16,
    pub timeout: btstack_timer_source_t,
    pub timestamp: u32,
    pub acl_recombination_buffer: [u8; 269usize],
    pub acl_recombination_pos: u16,
    pub acl_recombination_length: u16,
    pub num_packets_sent: u8,
    pub num_packets_completed: u8,
    pub le_con_parameter_update_state: le_con_parameter_update_state_t,
    pub le_con_param_update_identifier: u8,
    pub le_conn_interval_min: u16,
    pub le_conn_interval_max: u16,
    pub le_conn_latency: u16,
    pub le_supervision_timeout: u16,
    pub le_connection_interval: u16,
    pub le_phy_update_all_phys: u8,
    pub le_phy_update_tx_phys: u8,
    pub le_phy_update_rx_phys: u8,
    pub le_phy_update_phy_options: i8,
    pub sm_connection: sm_connection_t,
    pub att_connection: att_connection_t,
    pub att_server: att_server_t,
    pub l2cap_state: l2cap_state_t,
}
impl hci_init_state {
    pub const HCI_INIT_SEND_RESET: hci_init_state = hci_init_state(0);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SEND_RESET: hci_init_state = hci_init_state(1);
}
impl hci_init_state {
    pub const HCI_INIT_SEND_READ_LOCAL_VERSION_INFORMATION: hci_init_state = hci_init_state(2);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SEND_READ_LOCAL_VERSION_INFORMATION: hci_init_state = hci_init_state(3);
}
impl hci_init_state {
    pub const HCI_INIT_SEND_READ_LOCAL_NAME: hci_init_state = hci_init_state(4);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SEND_READ_LOCAL_NAME: hci_init_state = hci_init_state(5);
}
impl hci_init_state {
    pub const HCI_INIT_SEND_BAUD_CHANGE: hci_init_state = hci_init_state(6);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SEND_BAUD_CHANGE: hci_init_state = hci_init_state(7);
}
impl hci_init_state {
    pub const HCI_INIT_CUSTOM_INIT: hci_init_state = hci_init_state(8);
}
impl hci_init_state {
    pub const HCI_INIT_W4_CUSTOM_INIT: hci_init_state = hci_init_state(9);
}
impl hci_init_state {
    pub const HCI_INIT_SEND_RESET_CSR_WARM_BOOT: hci_init_state = hci_init_state(10);
}
impl hci_init_state {
    pub const HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT: hci_init_state = hci_init_state(11);
}
impl hci_init_state {
    pub const HCI_INIT_W4_CUSTOM_INIT_CSR_WARM_BOOT_LINK_RESET: hci_init_state = hci_init_state(12);
}
impl hci_init_state {
    pub const HCI_INIT_W4_CUSTOM_INIT_BCM_DELAY: hci_init_state = hci_init_state(13);
}
impl hci_init_state {
    pub const HCI_INIT_READ_LOCAL_SUPPORTED_COMMANDS: hci_init_state = hci_init_state(14);
}
impl hci_init_state {
    pub const HCI_INIT_W4_READ_LOCAL_SUPPORTED_COMMANDS: hci_init_state = hci_init_state(15);
}
impl hci_init_state {
    pub const HCI_INIT_SEND_BAUD_CHANGE_BCM: hci_init_state = hci_init_state(16);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SEND_BAUD_CHANGE_BCM: hci_init_state = hci_init_state(17);
}
impl hci_init_state {
    pub const HCI_INIT_SET_BD_ADDR: hci_init_state = hci_init_state(18);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SET_BD_ADDR: hci_init_state = hci_init_state(19);
}
impl hci_init_state {
    pub const HCI_INIT_SEND_RESET_ST_WARM_BOOT: hci_init_state = hci_init_state(20);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SEND_RESET_ST_WARM_BOOT: hci_init_state = hci_init_state(21);
}
impl hci_init_state {
    pub const HCI_INIT_READ_BD_ADDR: hci_init_state = hci_init_state(22);
}
impl hci_init_state {
    pub const HCI_INIT_W4_READ_BD_ADDR: hci_init_state = hci_init_state(23);
}
impl hci_init_state {
    pub const HCI_INIT_READ_BUFFER_SIZE: hci_init_state = hci_init_state(24);
}
impl hci_init_state {
    pub const HCI_INIT_W4_READ_BUFFER_SIZE: hci_init_state = hci_init_state(25);
}
impl hci_init_state {
    pub const HCI_INIT_READ_LOCAL_SUPPORTED_FEATURES: hci_init_state = hci_init_state(26);
}
impl hci_init_state {
    pub const HCI_INIT_W4_READ_LOCAL_SUPPORTED_FEATURES: hci_init_state = hci_init_state(27);
}
impl hci_init_state {
    pub const HCI_INIT_HOST_BUFFER_SIZE: hci_init_state = hci_init_state(28);
}
impl hci_init_state {
    pub const HCI_INIT_W4_HOST_BUFFER_SIZE: hci_init_state = hci_init_state(29);
}
impl hci_init_state {
    pub const HCI_INIT_SET_CONTROLLER_TO_HOST_FLOW_CONTROL: hci_init_state = hci_init_state(30);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SET_CONTROLLER_TO_HOST_FLOW_CONTROL: hci_init_state = hci_init_state(31);
}
impl hci_init_state {
    pub const HCI_INIT_SET_EVENT_MASK: hci_init_state = hci_init_state(32);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SET_EVENT_MASK: hci_init_state = hci_init_state(33);
}
impl hci_init_state {
    pub const HCI_INIT_SET_EVENT_MASK_2: hci_init_state = hci_init_state(34);
}
impl hci_init_state {
    pub const HCI_INIT_W4_SET_EVENT_MASK_2: hci_init_state = hci_init_state(35);
}
impl hci_init_state {
    pub const HCI_INIT_LE_READ_BUFFER_SIZE: hci_init_state = hci_init_state(36);
}
impl hci_init_state {
    pub const HCI_INIT_W4_LE_READ_BUFFER_SIZE: hci_init_state = hci_init_state(37);
}
impl hci_init_state {
    pub const HCI_INIT_WRITE_LE_HOST_SUPPORTED: hci_init_state = hci_init_state(38);
}
impl hci_init_state {
    pub const HCI_INIT_W4_WRITE_LE_HOST_SUPPORTED: hci_init_state = hci_init_state(39);
}
impl hci_init_state {
    pub const HCI_INIT_LE_SET_EVENT_MASK: hci_init_state = hci_init_state(40);
}
impl hci_init_state {
    pub const HCI_INIT_W4_LE_SET_EVENT_MASK: hci_init_state = hci_init_state(41);
}
impl hci_init_state {
    pub const HCI_INIT_DONE: hci_init_state = hci_init_state(42);
}
impl hci_init_state {
    pub const HCI_FALLING_ASLEEP_DISCONNECT: hci_init_state = hci_init_state(43);
}
impl hci_init_state {
    pub const HCI_FALLING_ASLEEP_W4_WRITE_SCAN_ENABLE: hci_init_state = hci_init_state(44);
}
impl hci_init_state {
    pub const HCI_FALLING_ASLEEP_COMPLETE: hci_init_state = hci_init_state(45);
}
impl hci_init_state {
    pub const HCI_INIT_AFTER_SLEEP: hci_init_state = hci_init_state(46);
}
impl hci_init_state {
    pub const HCI_HALTING_CLASSIC_STOP: hci_init_state = hci_init_state(47);
}
impl hci_init_state {
    pub const HCI_HALTING_LE_ADV_STOP: hci_init_state = hci_init_state(48);
}
impl hci_init_state {
    pub const HCI_HALTING_LE_SCAN_STOP: hci_init_state = hci_init_state(49);
}
impl hci_init_state {
    pub const HCI_HALTING_DISCONNECT_ALL: hci_init_state = hci_init_state(50);
}
impl hci_init_state {
    pub const HCI_HALTING_W4_CLOSE_TIMER: hci_init_state = hci_init_state(51);
}
impl hci_init_state {
    pub const HCI_HALTING_CLOSE: hci_init_state = hci_init_state(52);
}
impl hci_init_state {
    pub const HCI_HALTING_CLOSE_DISCARDING_CONNECTIONS: hci_init_state = hci_init_state(53);
}
impl ::core::ops::BitOr<hci_init_state> for hci_init_state {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hci_init_state(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hci_init_state {
    #[inline]
    fn bitor_assign(&mut self, rhs: hci_init_state) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hci_init_state> for hci_init_state {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hci_init_state(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hci_init_state {
    #[inline]
    fn bitand_assign(&mut self, rhs: hci_init_state) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " HCI Inititizlization State Machine"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hci_init_state(pub cty::c_uint);
#[doc = " HCI Inititizlization State Machine"]
pub use self::hci_init_state as hci_substate_t;
pub const LE_ADVERTISEMENT_TASKS_SET_ADV_DATA: _bindgen_ty_2 = _bindgen_ty_2(1);
pub const LE_ADVERTISEMENT_TASKS_SET_SCAN_DATA: _bindgen_ty_2 = _bindgen_ty_2(2);
pub const LE_ADVERTISEMENT_TASKS_SET_PARAMS: _bindgen_ty_2 = _bindgen_ty_2(4);
pub const LE_ADVERTISEMENT_TASKS_SET_ADDRESS: _bindgen_ty_2 = _bindgen_ty_2(8);
pub const LE_ADVERTISEMENT_TASKS_SET_PERIODIC_PARAMS: _bindgen_ty_2 = _bindgen_ty_2(16);
pub const LE_ADVERTISEMENT_TASKS_SET_PERIODIC_DATA: _bindgen_ty_2 = _bindgen_ty_2(32);
pub const LE_ADVERTISEMENT_TASKS_REMOVE_SET: _bindgen_ty_2 = _bindgen_ty_2(64);
impl ::core::ops::BitOr<_bindgen_ty_2> for _bindgen_ty_2 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_2(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_2 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_2) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_2> for _bindgen_ty_2 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_2(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_2 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_2) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_2(pub cty::c_uint);
pub const LE_ADVERTISEMENT_STATE_PARAMS_SET: _bindgen_ty_3 = _bindgen_ty_3(1);
pub const LE_ADVERTISEMENT_STATE_ACTIVE: _bindgen_ty_3 = _bindgen_ty_3(2);
pub const LE_ADVERTISEMENT_STATE_ENABLED: _bindgen_ty_3 = _bindgen_ty_3(4);
pub const LE_ADVERTISEMENT_STATE_PERIODIC_ACTIVE: _bindgen_ty_3 = _bindgen_ty_3(8);
pub const LE_ADVERTISEMENT_STATE_PERIODIC_ENABLED: _bindgen_ty_3 = _bindgen_ty_3(16);
impl ::core::ops::BitOr<_bindgen_ty_3> for _bindgen_ty_3 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_3(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_3 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_3) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_3> for _bindgen_ty_3 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_3(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_3 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_3) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_3(pub cty::c_uint);
pub const LE_WHITELIST_ON_CONTROLLER: _bindgen_ty_4 = _bindgen_ty_4(1);
pub const LE_WHITELIST_ADD_TO_CONTROLLER: _bindgen_ty_4 = _bindgen_ty_4(2);
pub const LE_WHITELIST_REMOVE_FROM_CONTROLLER: _bindgen_ty_4 = _bindgen_ty_4(4);
impl ::core::ops::BitOr<_bindgen_ty_4> for _bindgen_ty_4 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_4(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_4 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_4) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_4> for _bindgen_ty_4 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_4(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_4 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_4) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_4(pub cty::c_uint);
pub const LE_PERIODIC_ADVERTISER_LIST_ENTRY_ON_CONTROLLER: _bindgen_ty_5 = _bindgen_ty_5(1);
pub const LE_PERIODIC_ADVERTISER_LIST_ENTRY_ADD_TO_CONTROLLER: _bindgen_ty_5 = _bindgen_ty_5(2);
pub const LE_PERIODIC_ADVERTISER_LIST_ENTRY_REMOVE_FROM_CONTROLLER: _bindgen_ty_5 =
    _bindgen_ty_5(4);
impl ::core::ops::BitOr<_bindgen_ty_5> for _bindgen_ty_5 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_5(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_5 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_5) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_5> for _bindgen_ty_5 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_5(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_5 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_5) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_5(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct whitelist_entry_t {
    pub item: btstack_linked_item_t,
    pub address: bd_addr_t,
    pub address_type: bd_addr_type_t,
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct periodic_advertiser_list_entry_t {
    pub item: btstack_linked_item_t,
    pub address: bd_addr_t,
    pub address_type: bd_addr_type_t,
    pub sid: u8,
    pub state: u8,
}
impl le_resolving_list_state_t {
    pub const LE_RESOLVING_LIST_SEND_ENABLE_ADDRESS_RESOLUTION: le_resolving_list_state_t =
        le_resolving_list_state_t(0);
}
impl le_resolving_list_state_t {
    pub const LE_RESOLVING_LIST_READ_SIZE: le_resolving_list_state_t = le_resolving_list_state_t(1);
}
impl le_resolving_list_state_t {
    pub const LE_RESOLVING_LIST_SEND_CLEAR: le_resolving_list_state_t =
        le_resolving_list_state_t(2);
}
impl le_resolving_list_state_t {
    pub const LE_RESOLVING_LIST_UPDATES_ENTRIES: le_resolving_list_state_t =
        le_resolving_list_state_t(3);
}
impl le_resolving_list_state_t {
    pub const LE_RESOLVING_LIST_DONE: le_resolving_list_state_t = le_resolving_list_state_t(4);
}
impl ::core::ops::BitOr<le_resolving_list_state_t> for le_resolving_list_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_resolving_list_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_resolving_list_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_resolving_list_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_resolving_list_state_t> for le_resolving_list_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_resolving_list_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_resolving_list_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_resolving_list_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_resolving_list_state_t(pub cty::c_uint);
#[doc = " main data structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hci_stack_t {
    pub hci_transport: *const hci_transport_t,
    pub config: *const cty::c_void,
    pub chipset: *const btstack_chipset_t,
    pub control: *const btstack_control_t,
    pub connections: btstack_linked_list_t,
    pub acl_packet_handler: btstack_packet_handler_t,
    pub sco_packet_handler: btstack_packet_handler_t,
    pub event_handlers: btstack_linked_list_t,
    pub hardware_error_callback: ::core::option::Option<unsafe extern "C" fn(error: u8)>,
    pub local_name: *const cty::c_char,
    pub eir_data: *const u8,
    pub class_of_device: u32,
    pub local_bd_addr: bd_addr_t,
    pub default_link_policy_settings: u16,
    pub allow_role_switch: u8,
    pub ssp_enable: u8,
    pub ssp_io_capability: u8,
    pub ssp_authentication_requirement: u8,
    pub ssp_auto_accept: u8,
    pub secure_connections_enable: bool,
    pub secure_connections_active: bool,
    pub inquiry_mode: inquiry_mode_t,
    pub hci_packet_buffer: *mut u8,
    pub hci_packet_buffer_data: [u8; 267usize],
    pub hci_packet_buffer_reserved: bool,
    pub acl_fragmentation_pos: u16,
    pub acl_fragmentation_total_size: u16,
    pub acl_fragmentation_tx_active: u8,
    pub num_cmd_packets: u8,
    pub acl_packets_total_num: u8,
    pub acl_data_packet_length: u16,
    pub sco_packets_total_num: u8,
    pub sco_data_packet_length: u8,
    pub synchronous_flow_control_enabled: u8,
    pub le_acl_packets_total_num: u8,
    pub le_data_packets_length: u16,
    pub le_iso_packets_total_num: u8,
    pub le_iso_packets_length: u16,
    pub sco_waiting_for_can_send_now: u8,
    pub sco_can_send_now: bool,
    pub local_supported_features: [u8; 8usize],
    pub local_supported_commands: u32,
    pub manufacturer: u16,
    pub packet_types: u16,
    pub state: HCI_STATE,
    pub substate: hci_substate_t,
    pub timeout: btstack_timer_source_t,
    pub chipset_result: btstack_chipset_result_t,
    pub last_cmd_opcode: u16,
    pub cmds_ready: u8,
    pub new_scan_enable_value: u8,
    pub discoverable: u8,
    pub connectable: u8,
    pub bondable: u8,
    pub inquiry_state: u8,
    pub inquiry_max_period_length: u16,
    pub inquiry_min_period_length: u16,
    pub remote_name_addr: bd_addr_t,
    pub remote_name_clock_offset: u16,
    pub remote_name_page_scan_repetition_mode: u8,
    pub remote_name_state: u8,
    pub gap_pairing_addr: bd_addr_t,
    pub gap_pairing_state: u8,
    pub gap_pairing_pin_len: u8,
    pub gap_pairing_input: hci_stack_t__bindgen_ty_1,
    pub sco_voice_setting: u16,
    pub sco_voice_setting_active: u16,
    pub loopback_mode: u8,
    pub decline_reason: u8,
    pub decline_addr: bd_addr_t,
    pub host_completed_packets: u8,
    pub le_own_addr_type: u8,
    pub le_random_address: bd_addr_t,
    pub le_random_address_set: u8,
    pub le_whitelist_capacity: u8,
    pub le_whitelist: btstack_linked_list_t,
    pub le_connection_parameter_range: le_connection_parameter_range_t,
    pub le_advertisements_todo: u8,
    pub le_advertisements_data: *mut u8,
    pub le_advertisements_data_len: u8,
    pub le_scan_response_data: *mut u8,
    pub le_scan_response_data_len: u8,
    pub le_advertisements_interval_min: u16,
    pub le_advertisements_interval_max: u16,
    pub le_advertisements_type: u8,
    pub le_advertisements_direct_address_type: u8,
    pub le_advertisements_channel_map: u8,
    pub le_advertisements_filter_policy: u8,
    pub le_advertisements_direct_address: bd_addr_t,
    pub le_advertisements_own_addr_type: u8,
    pub le_advertisements_own_address: bd_addr_t,
    pub le_advertisements_state: u8,
    pub le_advertisements_enabled_for_current_roles: bool,
    pub le_max_number_peripheral_connections: u8,
    pub custom_bd_addr: bd_addr_t,
    pub custom_bd_addr_set: u8,
    pub outgoing_addr: bd_addr_t,
    pub outgoing_addr_type: bd_addr_type_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hci_stack_t__bindgen_ty_1 {
    pub gap_pairing_pin: *const u8,
    pub gap_pairing_passkey: u32,
}
extern "C" {
    #[doc = " @brief Set up HCI. Needs to be called before any other function."]
    pub fn hci_init(transport: *const hci_transport_t, config: *const cty::c_void);
}
extern "C" {
    #[doc = " @brief Configure Bluetooth chipset driver. Has to be called before power on, or right after receiving the local version information."]
    pub fn hci_set_chipset(chipset_driver: *const btstack_chipset_t);
}
extern "C" {
    #[doc = " @brief Configure Bluetooth hardware control. Has to be called before power on.\n @[aram hardware_control implementation"]
    pub fn hci_set_control(hardware_control: *const btstack_control_t);
}
extern "C" {
    #[doc = " @brief Set callback for Bluetooth Hardware Error"]
    pub fn hci_set_hardware_error_callback(
        fn_: ::core::option::Option<unsafe extern "C" fn(error: u8)>,
    );
}
extern "C" {
    #[doc = " @brief Set Public BD ADDR - passed on to Bluetooth chipset during init if supported in bt_control_h"]
    pub fn hci_set_bd_addr(addr: *mut u8);
}
extern "C" {
    #[doc = " @brief Configure Voice Setting for use with SCO data in HSP/HFP"]
    pub fn hci_set_sco_voice_setting(voice_setting: u16);
}
extern "C" {
    #[doc = " @brief Get SCO Voice Setting\n @return current voice setting"]
    pub fn hci_get_sco_voice_setting() -> u16;
}
extern "C" {
    #[doc = " @brief Set number of ISO packets to buffer for BIS/CIS\n @param num_packets (default = 1)"]
    pub fn hci_set_num_iso_packets_to_queue(num_packets: u8);
}
extern "C" {
    #[doc = " @brief Set inquiry mode: standard, with RSSI, with RSSI + Extended Inquiry Results. Has to be called before power on.\n @param inquriy_mode see bluetooth_defines.h"]
    pub fn hci_set_inquiry_mode(inquriy_mode: inquiry_mode_t);
}
extern "C" {
    #[doc = " @brief Requests the change of BTstack power mode.\n @param power_mode\n @return 0 if success, otherwise error"]
    pub fn hci_power_control(power_mode: HCI_POWER_MODE) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Shutdown HCI"]
    pub fn hci_close();
}
extern "C" {
    #[doc = " @brief Add event packet handler."]
    pub fn hci_add_event_handler(callback_handler: *mut btstack_packet_callback_registration_t);
}
extern "C" {
    #[doc = " @brief Remove event packet handler."]
    pub fn hci_remove_event_handler(callback_handler: *mut btstack_packet_callback_registration_t);
}
extern "C" {
    #[doc = " @brief Registers a packet handler for ACL data. Used by L2CAP"]
    pub fn hci_register_acl_packet_handler(handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief Registers a packet handler for SCO data. Used for HSP and HFP profiles."]
    pub fn hci_register_sco_packet_handler(handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief Registers a packet handler for ISO data. Used for LE Audio profiles"]
    pub fn hci_register_iso_packet_handler(handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief Check if CMD packet can be sent to controller\n @return true if command can be sent"]
    pub fn hci_can_send_command_packet_now() -> bool;
}
extern "C" {
    #[doc = " @brief Creates and sends HCI command packets based on a template and a list of parameters. Will return error if outgoing data buffer is occupied.\n @return status"]
    pub fn hci_send_cmd(cmd: *const hci_cmd_t, ...) -> u8;
}
extern "C" {
    #[doc = " @brief Get SCO packet length for current SCO Voice setting\n  @note  Using SCO packets of the exact length is required for USB transfer\n  @return Length of SCO packets in bytes (not audio frames) incl. 3 byte header"]
    pub fn hci_get_sco_packet_length() -> u16;
}
extern "C" {
    #[doc = " @brief Request emission of HCI_EVENT_SCO_CAN_SEND_NOW as soon as possible\n @note HCI_EVENT_SCO_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it"]
    pub fn hci_request_sco_can_send_now_event();
}
extern "C" {
    #[doc = " @brief Check HCI packet buffer and if SCO packet can be sent to controller\n @return true if sco packet can be sent"]
    pub fn hci_can_send_sco_packet_now() -> bool;
}
extern "C" {
    #[doc = " @brief Check if SCO packet can be sent to controller\n @return true if sco packet can be sent"]
    pub fn hci_can_send_prepared_sco_packet_now() -> bool;
}
extern "C" {
    #[doc = " @brief Send SCO packet prepared in HCI packet buffer"]
    pub fn hci_send_sco_packet_buffer(size: cty::c_int) -> u8;
}
extern "C" {
    #[doc = " @brief Request emission of HCI_EVENT_BIS_CAN_SEND_NOW for all BIS as soon as possible\n @param big_handle\n @note HCI_EVENT_ISO_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it"]
    pub fn hci_request_bis_can_send_now_events(big_handle: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Request emission of HCI_EVENT_CIS_CAN_SEND_NOW for CIS as soon as possible\n @param cis_con_handle\n @note HCI_EVENT_CIS_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it"]
    pub fn hci_request_cis_can_send_now_events(cis_con_handle: hci_con_handle_t) -> u8;
}
extern "C" {
    #[doc = " @brief Send ISO packet prepared in HCI packet buffer"]
    pub fn hci_send_iso_packet_buffer(size: u16) -> u8;
}
extern "C" {
    #[doc = " Reserves outgoing packet buffer.\n @return true on success"]
    pub fn hci_reserve_packet_buffer() -> bool;
}
extern "C" {
    #[doc = " Get pointer for outgoing packet buffer"]
    pub fn hci_get_outgoing_packet_buffer() -> *mut u8;
}
extern "C" {
    #[doc = " Release outgoing packet buffer\\\n @note only called instead of hci_send_preparared"]
    pub fn hci_release_packet_buffer();
}
extern "C" {
    #[doc = " @brief Sets the master/slave policy\n @param policy (0: attempt to become master, 1: let connecting device decide)"]
    pub fn hci_set_master_slave_policy(policy: u8);
}
extern "C" {
    #[doc = " va_list version of hci_send_cmd, call hci_send_cmd_packet\n @return status"]
    pub fn hci_send_cmd_va_arg(cmd: *const hci_cmd_t, argptr: va_list) -> u8;
}
extern "C" {
    #[doc = " Get connection iterator. Only used by l2cap.c and sm.c"]
    pub fn hci_connections_get_iterator(it: *mut btstack_linked_list_iterator_t);
}
extern "C" {
    #[doc = " Get internal hci_connection_t for given handle. Used by L2CAP, SM, daemon"]
    pub fn hci_connection_for_handle(con_handle: hci_con_handle_t) -> *mut hci_connection_t;
}
extern "C" {
    #[doc = " Get internal hci_connection_t for given Bluetooth addres. Called by L2CAP"]
    pub fn hci_connection_for_bd_addr_and_type(
        addr: *mut u8,
        addr_type: bd_addr_type_t,
    ) -> *mut hci_connection_t;
}
extern "C" {
    #[doc = " Check if outgoing packet buffer is reserved. Used for internal checks in l2cap.c\n @return true if packet buffer is reserved"]
    pub fn hci_is_packet_buffer_reserved() -> bool;
}
extern "C" {
    #[doc = " Check hci packet buffer is free and a classic acl packet can be sent to controller\n @return true if ACL Classic packet can be sent now"]
    pub fn hci_can_send_acl_classic_packet_now() -> bool;
}
extern "C" {
    #[doc = " Check hci packet buffer is free and an LE acl packet can be sent to controller\n @return true if ACL LE packet can be sent now"]
    pub fn hci_can_send_acl_le_packet_now() -> bool;
}
extern "C" {
    #[doc = " Check hci packet buffer is free and an acl packet for the given handle can be sent to controller\n @return true if ACL packet for con_handle can be sent now"]
    pub fn hci_can_send_acl_packet_now(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " Check if acl packet for the given handle can be sent to controller\n @return true if ACL packet for con_handle can be sent now"]
    pub fn hci_can_send_prepared_acl_packet_now(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " Send acl packet prepared in hci packet buffer\n @return status"]
    pub fn hci_send_acl_packet_buffer(size: cty::c_int) -> u8;
}
extern "C" {
    #[doc = " Check if authentication is active. It delays automatic disconnect while no L2CAP connection\n Called by l2cap."]
    pub fn hci_authentication_active_for_handle(handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " Get maximal ACL Classic data packet length based on used buffer size. Called by L2CAP"]
    pub fn hci_max_acl_data_packet_length() -> u16;
}
extern "C" {
    #[doc = " Get supported packet types. Called by L2CAP"]
    pub fn hci_usable_acl_packet_types() -> u16;
}
extern "C" {
    #[doc = " Check if ACL packets marked as non flushable can be sent. Called by L2CAP"]
    pub fn hci_non_flushable_packet_boundary_flag_supported() -> bool;
}
extern "C" {
    #[doc = " Return current automatic flush timeout setting"]
    pub fn hci_automatic_flush_timeout() -> u16;
}
extern "C" {
    #[doc = " Check if remote supported features query has completed"]
    pub fn hci_remote_features_available(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " Trigger remote supported features query"]
    pub fn hci_remote_features_query(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " Check if extended SCO Link is supported"]
    pub fn hci_extended_sco_link_supported() -> bool;
}
extern "C" {
    #[doc = " Check if SSP is supported on both sides. Called by L2CAP"]
    pub fn gap_ssp_supported_on_both_sides(handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " Disconn because of security block. Called by L2CAP"]
    pub fn hci_disconnect_security_block(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " Query if remote side supports eSCO"]
    pub fn hci_remote_esco_supported(con_handle: hci_con_handle_t) -> bool;
}
extern "C" {
    #[doc = " Emit current HCI state. Called by daemon"]
    pub fn hci_emit_state();
}
extern "C" {
    #[doc = " Send complete CMD packet. Called by daemon and hci_send_cmd_va_arg\n @return status"]
    pub fn hci_send_cmd_packet(packet: *mut u8, size: cty::c_int) -> u8;
}
extern "C" {
    #[doc = " Disconnect all HCI connections. Called by daemon"]
    pub fn hci_disconnect_all();
}
extern "C" {
    #[doc = " Get number of free acl slots for packets of given handle. Called by daemon"]
    pub fn hci_number_free_acl_slots_for_handle(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Set Advertisement Parameters\n @param adv_int_min\n @param adv_int_max\n @param adv_type\n @param direct_address_type\n @param direct_address\n @param channel_map\n @param filter_policy\n\n @note internal use. use gap_advertisements_set_params from gap.h instead."]
    pub fn hci_le_advertisements_set_params(
        adv_int_min: u16,
        adv_int_max: u16,
        adv_type: u8,
        direct_address_typ: u8,
        direct_address: *mut u8,
        channel_map: u8,
        filter_policy: u8,
    );
}
extern "C" {
    #[doc = " @note internal use. use gap_random_address_set_mode from gap.h instead."]
    pub fn hci_le_set_own_address_type(own_address_type: u8);
}
extern "C" {
    #[doc = " @naote internal use. use gap_random_address_set from gap.h instead"]
    pub fn hci_le_random_address_set(random_address: *mut u8);
}
extern "C" {
    #[doc = " @note internal use by sm"]
    pub fn hci_load_le_device_db_entry_into_resolving_list(le_device_db_index: u16);
}
extern "C" {
    #[doc = " @note internal use by sm"]
    pub fn hci_remove_le_device_db_entry_from_resolving_list(le_device_db_index: u16);
}
extern "C" {
    #[doc = " @note internal use"]
    pub fn hci_number_free_acl_slots_for_connection_type(address_type: bd_addr_type_t) -> u16;
}
extern "C" {
    #[doc = " @brief Clear Periodic Advertiser List\n @return status"]
    pub fn gap_periodic_advertiser_list_clear() -> u8;
}
extern "C" {
    #[doc = " @brief Add entry to Periodic Advertiser List\n @param address_type\n @param address\n @param advertising_sid\n @return"]
    pub fn gap_periodic_advertiser_list_add(
        address_type: bd_addr_type_t,
        address: *mut u8,
        advertising_sid: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Remove entry from Periodic Advertising List\n @param address_type\n @param address\n @param advertising_sid\n @return"]
    pub fn gap_periodic_advertiser_list_remove(
        address_type: bd_addr_type_t,
        address: *mut u8,
        advertising_sid: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Synchronize with a periodic advertising train from an advertiser and begin receiving periodic advertising packets.\n @param options\n @param advertising_sid\n @param advertiser_address_type\n @param advertiser_address\n @param skip\n @param sync_timeout\n @param sync_cte_type\n @return"]
    pub fn gap_periodic_advertising_create_sync(
        options: u8,
        advertising_sid: u8,
        advertiser_address_type: bd_addr_type_t,
        advertiser_address: *mut u8,
        skip: u16,
        sync_timeout: u16,
        sync_cte_type: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Cancel sync periodic advertising train while it is pending.\n @return status"]
    pub fn gap_periodic_advertising_create_sync_cancel() -> u8;
}
extern "C" {
    #[doc = " @biref Stop reception of the periodic advertising train\n @param sync_handle\n @return status"]
    pub fn gap_periodic_advertising_terminate_sync(sync_handle: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Get Manufactured\n @return manufacturer id"]
    pub fn hci_get_manufacturer() -> u16;
}
extern "C" {
    #[doc = " Disable automatic L2CAP disconnect if no L2CAP connection is established"]
    pub fn hci_disable_l2cap_timeout_check();
}
extern "C" {
    #[doc = "  Get Classic Allow Role Switch param"]
    pub fn hci_get_allow_role_switch() -> u8;
}
extern "C" {
    #[doc = " Get state"]
    pub fn hci_get_state() -> HCI_STATE;
}
extern "C" {
    #[doc = " @brief De-Init HCI"]
    pub fn hci_deinit();
}
extern "C" {
    pub fn hci_setup_test_connections_fuzz();
}
extern "C" {
    pub fn hci_free_connections_fuzz();
}
extern "C" {
    pub fn hci_simulate_working_fuzz();
}
impl gatt_client_state_t {
    pub const P_READY: gatt_client_state_t = gatt_client_state_t(0);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_SERVICE_QUERY: gatt_client_state_t = gatt_client_state_t(1);
}
impl gatt_client_state_t {
    pub const P_W4_SERVICE_QUERY_RESULT: gatt_client_state_t = gatt_client_state_t(2);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_SERVICE_WITH_UUID_QUERY: gatt_client_state_t = gatt_client_state_t(3);
}
impl gatt_client_state_t {
    pub const P_W4_SERVICE_WITH_UUID_RESULT: gatt_client_state_t = gatt_client_state_t(4);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_ALL_CHARACTERISTICS_OF_SERVICE_QUERY: gatt_client_state_t =
        gatt_client_state_t(5);
}
impl gatt_client_state_t {
    pub const P_W4_ALL_CHARACTERISTICS_OF_SERVICE_QUERY_RESULT: gatt_client_state_t =
        gatt_client_state_t(6);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_CHARACTERISTIC_WITH_UUID_QUERY: gatt_client_state_t =
        gatt_client_state_t(7);
}
impl gatt_client_state_t {
    pub const P_W4_CHARACTERISTIC_WITH_UUID_QUERY_RESULT: gatt_client_state_t =
        gatt_client_state_t(8);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_ALL_CHARACTERISTIC_DESCRIPTORS_QUERY: gatt_client_state_t =
        gatt_client_state_t(9);
}
impl gatt_client_state_t {
    pub const P_W4_ALL_CHARACTERISTIC_DESCRIPTORS_QUERY_RESULT: gatt_client_state_t =
        gatt_client_state_t(10);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_INCLUDED_SERVICE_QUERY: gatt_client_state_t = gatt_client_state_t(11);
}
impl gatt_client_state_t {
    pub const P_W4_INCLUDED_SERVICE_QUERY_RESULT: gatt_client_state_t = gatt_client_state_t(12);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_INCLUDED_SERVICE_WITH_UUID_QUERY: gatt_client_state_t =
        gatt_client_state_t(13);
}
impl gatt_client_state_t {
    pub const P_W4_INCLUDED_SERVICE_UUID_WITH_QUERY_RESULT: gatt_client_state_t =
        gatt_client_state_t(14);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_CHARACTERISTIC_VALUE_QUERY: gatt_client_state_t =
        gatt_client_state_t(15);
}
impl gatt_client_state_t {
    pub const P_W4_READ_CHARACTERISTIC_VALUE_RESULT: gatt_client_state_t = gatt_client_state_t(16);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_BLOB_QUERY: gatt_client_state_t = gatt_client_state_t(17);
}
impl gatt_client_state_t {
    pub const P_W4_READ_BLOB_RESULT: gatt_client_state_t = gatt_client_state_t(18);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_BY_TYPE_REQUEST: gatt_client_state_t = gatt_client_state_t(19);
}
impl gatt_client_state_t {
    pub const P_W4_READ_BY_TYPE_RESPONSE: gatt_client_state_t = gatt_client_state_t(20);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_MULTIPLE_REQUEST: gatt_client_state_t = gatt_client_state_t(21);
}
impl gatt_client_state_t {
    pub const P_W4_READ_MULTIPLE_RESPONSE: gatt_client_state_t = gatt_client_state_t(22);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_WRITE_CHARACTERISTIC_VALUE: gatt_client_state_t = gatt_client_state_t(23);
}
impl gatt_client_state_t {
    pub const P_W4_WRITE_CHARACTERISTIC_VALUE_RESULT: gatt_client_state_t = gatt_client_state_t(24);
}
impl gatt_client_state_t {
    pub const P_W2_PREPARE_WRITE: gatt_client_state_t = gatt_client_state_t(25);
}
impl gatt_client_state_t {
    pub const P_W4_PREPARE_WRITE_RESULT: gatt_client_state_t = gatt_client_state_t(26);
}
impl gatt_client_state_t {
    pub const P_W2_PREPARE_RELIABLE_WRITE: gatt_client_state_t = gatt_client_state_t(27);
}
impl gatt_client_state_t {
    pub const P_W4_PREPARE_RELIABLE_WRITE_RESULT: gatt_client_state_t = gatt_client_state_t(28);
}
impl gatt_client_state_t {
    pub const P_W2_EXECUTE_PREPARED_WRITE: gatt_client_state_t = gatt_client_state_t(29);
}
impl gatt_client_state_t {
    pub const P_W4_EXECUTE_PREPARED_WRITE_RESULT: gatt_client_state_t = gatt_client_state_t(30);
}
impl gatt_client_state_t {
    pub const P_W2_CANCEL_PREPARED_WRITE: gatt_client_state_t = gatt_client_state_t(31);
}
impl gatt_client_state_t {
    pub const P_W4_CANCEL_PREPARED_WRITE_RESULT: gatt_client_state_t = gatt_client_state_t(32);
}
impl gatt_client_state_t {
    pub const P_W2_CANCEL_PREPARED_WRITE_DATA_MISMATCH: gatt_client_state_t =
        gatt_client_state_t(33);
}
impl gatt_client_state_t {
    pub const P_W4_CANCEL_PREPARED_WRITE_DATA_MISMATCH_RESULT: gatt_client_state_t =
        gatt_client_state_t(34);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_CLIENT_CHARACTERISTIC_CONFIGURATION_QUERY: gatt_client_state_t =
        gatt_client_state_t(35);
}
impl gatt_client_state_t {
    pub const P_W4_READ_CLIENT_CHARACTERISTIC_CONFIGURATION_QUERY_RESULT: gatt_client_state_t =
        gatt_client_state_t(36);
}
impl gatt_client_state_t {
    pub const P_W2_WRITE_CLIENT_CHARACTERISTIC_CONFIGURATION: gatt_client_state_t =
        gatt_client_state_t(37);
}
impl gatt_client_state_t {
    pub const P_W4_CLIENT_CHARACTERISTIC_CONFIGURATION_RESULT: gatt_client_state_t =
        gatt_client_state_t(38);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_CHARACTERISTIC_DESCRIPTOR_QUERY: gatt_client_state_t =
        gatt_client_state_t(39);
}
impl gatt_client_state_t {
    pub const P_W4_READ_CHARACTERISTIC_DESCRIPTOR_RESULT: gatt_client_state_t =
        gatt_client_state_t(40);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_READ_BLOB_CHARACTERISTIC_DESCRIPTOR_QUERY: gatt_client_state_t =
        gatt_client_state_t(41);
}
impl gatt_client_state_t {
    pub const P_W4_READ_BLOB_CHARACTERISTIC_DESCRIPTOR_RESULT: gatt_client_state_t =
        gatt_client_state_t(42);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_WRITE_CHARACTERISTIC_DESCRIPTOR: gatt_client_state_t =
        gatt_client_state_t(43);
}
impl gatt_client_state_t {
    pub const P_W4_WRITE_CHARACTERISTIC_DESCRIPTOR_RESULT: gatt_client_state_t =
        gatt_client_state_t(44);
}
impl gatt_client_state_t {
    pub const P_W2_PREPARE_WRITE_CHARACTERISTIC_DESCRIPTOR: gatt_client_state_t =
        gatt_client_state_t(45);
}
impl gatt_client_state_t {
    pub const P_W4_PREPARE_WRITE_CHARACTERISTIC_DESCRIPTOR_RESULT: gatt_client_state_t =
        gatt_client_state_t(46);
}
impl gatt_client_state_t {
    pub const P_W2_EXECUTE_PREPARED_WRITE_CHARACTERISTIC_DESCRIPTOR: gatt_client_state_t =
        gatt_client_state_t(47);
}
impl gatt_client_state_t {
    pub const P_W4_EXECUTE_PREPARED_WRITE_CHARACTERISTIC_DESCRIPTOR_RESULT: gatt_client_state_t =
        gatt_client_state_t(48);
}
impl gatt_client_state_t {
    pub const P_W2_PREPARE_WRITE_SINGLE: gatt_client_state_t = gatt_client_state_t(49);
}
impl gatt_client_state_t {
    pub const P_W4_PREPARE_WRITE_SINGLE_RESULT: gatt_client_state_t = gatt_client_state_t(50);
}
impl gatt_client_state_t {
    pub const P_W4_IDENTITY_RESOLVING: gatt_client_state_t = gatt_client_state_t(51);
}
impl gatt_client_state_t {
    pub const P_W4_CMAC_READY: gatt_client_state_t = gatt_client_state_t(52);
}
impl gatt_client_state_t {
    pub const P_W4_CMAC_RESULT: gatt_client_state_t = gatt_client_state_t(53);
}
impl gatt_client_state_t {
    pub const P_W2_SEND_SIGNED_WRITE: gatt_client_state_t = gatt_client_state_t(54);
}
impl gatt_client_state_t {
    pub const P_W4_SEND_SINGED_WRITE_DONE: gatt_client_state_t = gatt_client_state_t(55);
}
impl ::core::ops::BitOr<gatt_client_state_t> for gatt_client_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gatt_client_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gatt_client_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gatt_client_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gatt_client_state_t> for gatt_client_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gatt_client_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gatt_client_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gatt_client_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gatt_client_state_t(pub cty::c_uint);
impl gatt_client_mtu_t {
    pub const SEND_MTU_EXCHANGE: gatt_client_mtu_t = gatt_client_mtu_t(0);
}
impl gatt_client_mtu_t {
    pub const SENT_MTU_EXCHANGE: gatt_client_mtu_t = gatt_client_mtu_t(1);
}
impl gatt_client_mtu_t {
    pub const MTU_EXCHANGED: gatt_client_mtu_t = gatt_client_mtu_t(2);
}
impl gatt_client_mtu_t {
    pub const MTU_AUTO_EXCHANGE_DISABLED: gatt_client_mtu_t = gatt_client_mtu_t(3);
}
impl ::core::ops::BitOr<gatt_client_mtu_t> for gatt_client_mtu_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gatt_client_mtu_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gatt_client_mtu_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gatt_client_mtu_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gatt_client_mtu_t> for gatt_client_mtu_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gatt_client_mtu_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gatt_client_mtu_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gatt_client_mtu_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gatt_client_mtu_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gatt_client {
    pub item: btstack_linked_item_t,
    pub gatt_client_state: gatt_client_state_t,
    pub callback: btstack_packet_handler_t,
    pub write_without_response_callback: btstack_packet_handler_t,
    pub write_without_response_requests: btstack_linked_list_t,
    pub query_requests: btstack_linked_list_t,
    pub con_handle: hci_con_handle_t,
    pub mtu: u16,
    pub mtu_state: gatt_client_mtu_t,
    pub uuid16: u16,
    pub uuid128: [u8; 16usize],
    pub start_group_handle: u16,
    pub end_group_handle: u16,
    pub query_start_handle: u16,
    pub query_end_handle: u16,
    pub characteristic_properties: u8,
    pub characteristic_start_handle: u16,
    pub attribute_handle: u16,
    pub attribute_offset: u16,
    pub attribute_length: u16,
    pub attribute_value: *mut u8,
    pub read_multiple_handle_count: u16,
    pub read_multiple_handles: *mut u16,
    pub client_characteristic_configuration_handle: u16,
    pub client_characteristic_configuration_value: [u8; 2usize],
    pub filter_with_uuid: u8,
    pub send_confirmation: u8,
    pub le_device_index: cty::c_int,
    pub cmac: [u8; 8usize],
    pub gc_timeout: btstack_timer_source_t,
    pub security_counter: u8,
    pub wait_for_authentication_complete: u8,
    pub pending_error_code: u8,
    pub reencryption_active: bool,
    pub reencryption_result: u8,
    pub security_level: gap_security_level_t,
}
pub type gatt_client_t = gatt_client;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gatt_client_notification {
    pub item: btstack_linked_item_t,
    pub callback: btstack_packet_handler_t,
    pub con_handle: hci_con_handle_t,
    pub attribute_handle: u16,
}
pub type gatt_client_notification_t = gatt_client_notification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gatt_client_service_t {
    pub start_group_handle: u16,
    pub end_group_handle: u16,
    pub uuid16: u16,
    pub uuid128: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gatt_client_characteristic_t {
    pub start_handle: u16,
    pub value_handle: u16,
    pub end_handle: u16,
    pub properties: u16,
    pub uuid16: u16,
    pub uuid128: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gatt_client_characteristic_descriptor_t {
    pub handle: u16,
    pub uuid16: u16,
    pub uuid128: [u8; 16usize],
}
extern "C" {
    #[doc = " @brief Set up GATT client."]
    pub fn gatt_client_init();
}
extern "C" {
    #[doc = " @brief Set minimum required security level for GATT Client\n @note  The Bluetooth specification makes the GATT Server responsible to check for security.\n        This allows an attacker to spoof an existing device with a GATT Servers, but skip the authentication part.\n        If your application is exchanging sensitive data with a remote device, you would need to manually check\n        the security level before sending/receive such data.\n        With level > 0, the GATT Client triggers authentication for all GATT Requests and defers any exchange\n        until the required security level is established.\n        gatt_client_request_can_write_without_response_event does not trigger authentication\n        gatt_client_request_to_write_without_response does not trigger authentication\n  @pram level, default LEVEL_0 (no encryption required)"]
    pub fn gatt_client_set_required_security_level(level: gap_security_level_t);
}
extern "C" {
    #[doc = " @brief MTU is available after the first query has completed. If status is equal to ERROR_CODE_SUCCESS, it returns the real value,\n otherwise the default value ATT_DEFAULT_MTU (see bluetooth.h).\n @param  con_handle\n @param  mtu\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if MTU is not exchanged and MTU auto-exchange is disabled\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_get_mtu(con_handle: hci_con_handle_t, mtu: *mut u16) -> u8;
}
extern "C" {
    #[doc = " @brief Sets whether a MTU Exchange Request shall be automatically send before the\n first attribute read request is send. Default is enabled.\n @param enabled"]
    pub fn gatt_client_mtu_enable_auto_negotiation(enabled: u8);
}
extern "C" {
    #[doc = " @brief Sends a MTU Exchange Request, this allows for the client to exchange MTU\n when gatt_client_mtu_enable_auto_negotiation is disabled.\n @param  callback\n @param  con_handle"]
    pub fn gatt_client_send_mtu_negotiation(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
    );
}
extern "C" {
    #[doc = " @brief Returns 1 if the GATT client is ready to receive a query. It is used with daemon.\n @param  con_handle\n @return is_ready_status     0 - if no GATT client for con_handle is found, or is not ready, otherwise 1"]
    pub fn gatt_client_is_ready(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Discovers all primary services.\n For each found service a GATT_EVENT_SERVICE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_primary_services(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Discovers all secondary services.\n For each found service a GATT_EVENT_SERVICE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_secondary_services(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Discovers a specific primary service given its UUID. This service may exist multiple times.\n For each found service a GATT_EVENT_SERVICE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param callback\n @param con_handle\n @param uuid16\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_primary_services_by_uuid16(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        uuid16: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Discovers a specific primary service given its UUID. This service may exist multiple times.\n For each found service a GATT_EVENT_SERVICE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  uuid128\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_primary_services_by_uuid128(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        uuid128: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Finds included services within the specified service.\n For each found included service a GATT_EVENT_INCLUDED_SERVICE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n Information about included service type (primary/secondary) can be retrieved either by sending\n an ATT find information request for the returned start group handle\n (returning the handle and the UUID for primary or secondary service) or by comparing the service\n to the list of all primary services.\n @param  callback\n @param  con_handle\n @param  service\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_find_included_services_for_service(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        service: *mut gatt_client_service_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Discovers all characteristics within the specified service.\n For each found characteristic a GATT_EVENT_CHARACTERISTIC_QUERY_RESULT event will be emited.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  service\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_characteristics_for_service(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        service: *mut gatt_client_service_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief The following four functions are used to discover all characteristics within\n the specified service or handle range, and return those that match the given UUID.\n\n For each found characteristic a GATT_EVENT_CHARACTERISTIC_QUERY_RESULT event will emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  start_handle\n @param  end_handle\n @param  uuid16\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_characteristics_for_handle_range_by_uuid16(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        start_handle: u16,
        end_handle: u16,
        uuid16: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief The following four functions are used to discover all characteristics within the\n specified service or handle range, and return those that match the given UUID.\n For each found characteristic a GATT_EVENT_CHARACTERISTIC_QUERY_RESULT event will emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  start_handle\n @param  end_handle\n @param  uuid128\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_characteristics_for_handle_range_by_uuid128(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        start_handle: u16,
        end_handle: u16,
        uuid128: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief The following four functions are used to discover all characteristics within the\n specified service or handle range, and return those that match the given UUID.\n For each found characteristic a GATT_EVENT_CHARACTERISTIC_QUERY_RESULT event will emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  service\n @param  uuid16\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_characteristics_for_service_by_uuid16(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        service: *mut gatt_client_service_t,
        uuid16: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief The following four functions are used to discover all characteristics within the\n specified service or handle range, and return those that match the given UUID.\n For each found characteristic a GATT_EVENT_CHARACTERISTIC_QUERY_RESULT event will emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  service\n @param  uuid128\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_characteristics_for_service_by_uuid128(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        service: *mut gatt_client_service_t,
        uuid128: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Discovers attribute handle and UUID of a characteristic descriptor within the specified characteristic.\n For each found descriptor a GATT_EVENT_ALL_CHARACTERISTIC_DESCRIPTORS_QUERY_RESULT event will be emitted.\n\n The GATT_EVENT_QUERY_COMPLETE event marks the end of discovery.\n @param  callback\n @param  con_handle\n @param  characteristic\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_discover_characteristic_descriptors(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        characteristic: *mut gatt_client_characteristic_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the characteristic value using the characteristic's value handle.\n If the characteristic value is found a GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  characteristic\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_value_of_characteristic(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        characteristic: *mut gatt_client_characteristic_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the characteristic value using the characteristic's value handle.\n If the characteristic value is found a GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  value_handle\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_value_of_characteristic_using_value_handle(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the characteric value of all characteristics with the uuid.\n For each characteristic value found a GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  start_handle\n @param  end_handle\n @param  uuid16\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_value_of_characteristics_by_uuid16(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        start_handle: u16,
        end_handle: u16,
        uuid16: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the characteric value of all characteristics with the uuid.\n For each characteristic value found a GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  start_handle\n @param  end_handle\n @param  uuid128\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_value_of_characteristics_by_uuid128(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        start_handle: u16,
        end_handle: u16,
        uuid128: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the long characteristic value using the characteristic's value handle.\n The value will be returned in several blobs.\n For each blob, a GATT_EVENT_LONG_CHARACTERISTIC_VALUE_QUERY_RESULT event with updated value offset will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  characteristic\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_long_value_of_characteristic(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        characteristic: *mut gatt_client_characteristic_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the long characteristic value using the characteristic's value handle.\n The value will be returned in several blobs.\n For each blob, a GATT_EVENT_LONG_CHARACTERISTIC_VALUE_QUERY_RESULT event with updated value offset will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  value_handle\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_long_value_of_characteristic_using_value_handle(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the long characteristic value using the characteristic's value handle.\n The value will be returned in several blobs.\n For each blob, a GATT_EVENT_LONG_CHARACTERISTIC_VALUE_QUERY_RESULT event with updated value offset will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  value_handle\n @param  offset\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_read_long_value_of_characteristic_using_value_handle_with_offset(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
        offset: u16,
    ) -> u8;
}
extern "C" {
    pub fn gatt_client_read_multiple_characteristic_values(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        num_value_handles: cty::c_int,
        value_handles: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic value using the characteristic's value handle without\n an acknowledgment that the write was successfully performed.\n @param  con_handle\n @param  value_handle\n @param  value_length\n @param  value is copied on success and does not need to be retained\n @return status BTSTACK_MEMORY_ALLOC_FAILED, if no GATT client for con_handle is found\n                GATT_CLIENT_IN_WRONG_STATE , if GATT client is not ready\n                BTSTACK_ACL_BUFFERS_FULL   , if L2CAP cannot send, there are no free ACL slots\n                ERROR_CODE_SUCCESS         , if query is successfully registered"]
    pub fn gatt_client_write_value_of_characteristic_without_response(
        con_handle: hci_con_handle_t,
        value_handle: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the authenticated characteristic value using the characteristic's value handle\n without an acknowledgment that the write was successfully performed.\n @note GATT_EVENT_QUERY_COMPLETE is emitted with ATT_ERROR_SUCCESS for success,\n or ATT_ERROR_BONDING_INFORMATION_MISSING if there is no bonding information stored.\n @param  callback\n @param  con_handle\n @param  value_handle\n @param  message_len\n @param  message is not copied, make sure memory is accessible until write is done\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_signed_write_without_response(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
        message_len: u16,
        message: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic value using the characteristic's value handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed, if the event's att_status field is set to\n ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  value_handle\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_value_of_characteristic(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic value using the characteristic's value handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  value_handle\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_long_value_of_characteristic(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic value using the characteristic's value handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  value_handle\n @param  offset of value\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_long_value_of_characteristic_with_offset(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
        offset: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes of the long characteristic value using the characteristic's value handle.\n It uses server response to validate that the write was correctly received.\n The GATT_EVENT_QUERY_COMPLETE EVENT marks the end of write.\n The write is successfully performed, if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  value_handle\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_reliable_write_long_value_of_characteristic(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        value_handle: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the characteristic descriptor using its handle.\n If the characteristic descriptor is found, a GATT_EVENT_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  descriptor\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_read_characteristic_descriptor(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor: *mut gatt_client_characteristic_descriptor_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the characteristic descriptor using its handle.\n If the characteristic descriptor is found, a GATT_EVENT_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  descriptor\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_read_characteristic_descriptor_using_descriptor_handle(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor_handle: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the long characteristic descriptor using its handle. It will be returned in several blobs.\n For each blob, a GATT_EVENT_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  descriptor\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_read_long_characteristic_descriptor(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor: *mut gatt_client_characteristic_descriptor_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the long characteristic descriptor using its handle. It will be returned in several blobs.\n For each blob, a GATT_EVENT_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  descriptor_handle\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_read_long_characteristic_descriptor_using_descriptor_handle(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor_handle: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Reads the long characteristic descriptor using its handle. It will be returned in several blobs.\n For each blob, a GATT_EVENT_CHARACTERISTIC_DESCRIPTOR_QUERY_RESULT event will be emitted.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of read.\n @param  callback\n @param  con_handle\n @param  descriptor_handle\n @param  offset\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_read_long_characteristic_descriptor_using_descriptor_handle_with_offset(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor_handle: u16,
        offset: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic descriptor using its handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  descriptor\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_characteristic_descriptor(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor: *mut gatt_client_characteristic_descriptor_t,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic descriptor using its handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  descriptor_handle\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_characteristic_descriptor_using_descriptor_handle(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor_handle: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic descriptor using its handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  descriptor\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_long_characteristic_descriptor(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor: *mut gatt_client_characteristic_descriptor_t,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic descriptor using its handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  descriptor_handle\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_long_characteristic_descriptor_using_descriptor_handle(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor_handle: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the characteristic descriptor using its handle.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  descriptor_handle\n @param  offset of value\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_long_characteristic_descriptor_using_descriptor_handle_with_offset(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        descriptor_handle: u16,
        offset: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Writes the client characteristic configuration of the specified characteristic.\n It is used to subscribe for notifications or indications of the characteristic value.\n For notifications or indications specify: GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION\n resp. GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_INDICATION as configuration value.\n The GATT_EVENT_QUERY_COMPLETE event marks the end of write.\n The write is successfully performed if the event's att_status field is set to ATT_ERROR_SUCCESS (see bluetooth.h for ATT_ERROR codes).\n @param  callback\n @param  con_handle\n @param  characteristic\n @param  configuration                                                    GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION, GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_INDICATION\n @return status ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER                  if no HCI connection for con_handle is found\n                BTSTACK_MEMORY_ALLOC_FAILED                               if no GATT client for con_handle could be allocated\n                GATT_CLIENT_IN_WRONG_STATE                                if GATT client is not ready\n                GATT_CLIENT_CHARACTERISTIC_NOTIFICATION_NOT_SUPPORTED     if configuring notification, but characteristic has no notification property set\n                GATT_CLIENT_CHARACTERISTIC_INDICATION_NOT_SUPPORTED       if configuring indication, but characteristic has no indication property set\n                ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE         if configuration is invalid\n                ERROR_CODE_SUCCESS                                        if query is successfully registered"]
    pub fn gatt_client_write_client_characteristic_configuration(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        characteristic: *mut gatt_client_characteristic_t,
        configuration: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Register for notifications and indications of a characteristic enabled by\n the gatt_client_write_client_characteristic_configuration function.\n @param notification struct used to store registration\n @param callback\n @param con_handle or GATT_CLIENT_ANY_CONNECTION to receive updates from all connected devices\n @param characteristic or NULL to receive updates for all characteristics"]
    pub fn gatt_client_listen_for_characteristic_value_updates(
        notification: *mut gatt_client_notification_t,
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        characteristic: *mut gatt_client_characteristic_t,
    );
}
extern "C" {
    #[doc = " @brief Stop listening to characteristic value updates registered with\n the gatt_client_listen_for_characteristic_value_updates function.\n @param notification struct used in gatt_client_listen_for_characteristic_value_updates"]
    pub fn gatt_client_stop_listening_for_characteristic_value_updates(
        notification: *mut gatt_client_notification_t,
    );
}
extern "C" {
    #[doc = " @brief Transactional write. It can be called as many times as it is needed to write the characteristics within the same transaction.\n Call the gatt_client_execute_write function to commit the transaction.\n @param  callback\n @param  con_handle\n @param  attribute_handle\n @param  offset of value\n @param  value_length\n @param  value is not copied, make sure memory is accessible until write is done, i.e. GATT_EVENT_QUERY_COMPLETE is received"]
    pub fn gatt_client_prepare_write(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        attribute_handle: u16,
        offset: u16,
        value_length: u16,
        value: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Commit transactional write. GATT_EVENT_QUERY_COMPLETE is received.\n @param  callback\n @param  con_handle\n @return status"]
    pub fn gatt_client_execute_write(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Abort transactional write. GATT_EVENT_QUERY_COMPLETE is received.\n @param  callback\n @param  con_handle\n @return status"]
    pub fn gatt_client_cancel_write(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Request callback when regular gatt query can be sent\n @note callback might happen during call to this function\n @param callback_registration to point to callback function and context information\n @param con_handle\n @return ERROR_CODE_SUCCESS if ok, ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if handle unknown, and ERROR_CODE_COMMAND_DISALLOWED if callback already registered"]
    pub fn gatt_client_request_to_send_gatt_query(
        callback_registration: *mut btstack_context_callback_registration_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Request callback when writing characteristic value without response is possible\n @note callback might happen during call to this function\n @param callback_registration to point to callback function and context information\n @param con_handle\n @return ERROR_CODE_SUCCESS if ok, ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if handle unknown, and ERROR_CODE_COMMAND_DISALLOWED if callback already registered"]
    pub fn gatt_client_request_to_write_without_response(
        callback_registration: *mut btstack_context_callback_registration_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Requests GATT_EVENT_CAN_WRITE_WITHOUT_RESPONSE that guarantees\n a single successful gatt_client_write_value_of_characteristic_without_response call.\n @deprecated please use gatt_client_request_to_write_without_response instead\n @param  callback\n @param  con_handle\n @return status"]
    pub fn gatt_client_request_can_write_without_response_event(
        callback: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    pub fn gatt_client_deserialize_service(
        packet: *const u8,
        offset: cty::c_int,
        service: *mut gatt_client_service_t,
    );
}
extern "C" {
    pub fn gatt_client_deserialize_characteristic(
        packet: *const u8,
        offset: cty::c_int,
        characteristic: *mut gatt_client_characteristic_t,
    );
}
extern "C" {
    pub fn gatt_client_deserialize_characteristic_descriptor(
        packet: *const u8,
        offset: cty::c_int,
        descriptor: *mut gatt_client_characteristic_descriptor_t,
    );
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_HANDSHAKE: hid_message_type_t = hid_message_type_t(0);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_HID_CONTROL: hid_message_type_t = hid_message_type_t(1);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_RESERVED_2: hid_message_type_t = hid_message_type_t(2);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_RESERVED_3: hid_message_type_t = hid_message_type_t(3);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_GET_REPORT: hid_message_type_t = hid_message_type_t(4);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_SET_REPORT: hid_message_type_t = hid_message_type_t(5);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_GET_PROTOCOL: hid_message_type_t = hid_message_type_t(6);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_SET_PROTOCOL: hid_message_type_t = hid_message_type_t(7);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_GET_IDLE_DEPRECATED: hid_message_type_t = hid_message_type_t(8);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_SET_IDLE_DEPRECATED: hid_message_type_t = hid_message_type_t(9);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_DATA: hid_message_type_t = hid_message_type_t(10);
}
impl hid_message_type_t {
    pub const HID_MESSAGE_TYPE_DATC_DEPRECATED: hid_message_type_t = hid_message_type_t(11);
}
impl ::core::ops::BitOr<hid_message_type_t> for hid_message_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_message_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_message_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_message_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_message_type_t> for hid_message_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_message_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_message_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_message_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_message_type_t(pub cty::c_uint);
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_SUCCESSFUL: hid_handshake_param_type_t =
        hid_handshake_param_type_t(0);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_NOT_READY: hid_handshake_param_type_t =
        hid_handshake_param_type_t(1);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_ERR_INVALID_REPORT_ID: hid_handshake_param_type_t =
        hid_handshake_param_type_t(2);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_ERR_UNSUPPORTED_REQUEST: hid_handshake_param_type_t =
        hid_handshake_param_type_t(3);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_ERR_INVALID_PARAMETER: hid_handshake_param_type_t =
        hid_handshake_param_type_t(4);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_ERR_UNKNOWN: hid_handshake_param_type_t =
        hid_handshake_param_type_t(14);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_ERR_FATAL: hid_handshake_param_type_t =
        hid_handshake_param_type_t(15);
}
impl hid_handshake_param_type_t {
    pub const HID_HANDSHAKE_PARAM_TYPE_ERR_DISCONNECT: hid_handshake_param_type_t =
        hid_handshake_param_type_t(16);
}
impl ::core::ops::BitOr<hid_handshake_param_type_t> for hid_handshake_param_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_handshake_param_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_handshake_param_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_handshake_param_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_handshake_param_type_t> for hid_handshake_param_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_handshake_param_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_handshake_param_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_handshake_param_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_handshake_param_type_t(pub cty::c_uint);
impl hid_control_param_t {
    pub const HID_CONTROL_PARAM_NOP_DEPRECATED: hid_control_param_t = hid_control_param_t(0);
}
impl hid_control_param_t {
    pub const HID_CONTROL_PARAM_HARD_RESET_DEPRECATED: hid_control_param_t = hid_control_param_t(1);
}
impl hid_control_param_t {
    pub const HID_CONTROL_PARAM_SOFT_RESET_DEPRECATED: hid_control_param_t = hid_control_param_t(2);
}
impl hid_control_param_t {
    pub const HID_CONTROL_PARAM_SUSPEND: hid_control_param_t = hid_control_param_t(3);
}
impl hid_control_param_t {
    pub const HID_CONTROL_PARAM_EXIT_SUSPEND: hid_control_param_t = hid_control_param_t(4);
}
impl hid_control_param_t {
    pub const HID_CONTROL_PARAM_VIRTUAL_CABLE_UNPLUG: hid_control_param_t = hid_control_param_t(5);
}
impl ::core::ops::BitOr<hid_control_param_t> for hid_control_param_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_control_param_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_control_param_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_control_param_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_control_param_t> for hid_control_param_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_control_param_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_control_param_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_control_param_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_control_param_t(pub cty::c_uint);
impl hid_protocol_mode_t {
    pub const HID_PROTOCOL_MODE_BOOT: hid_protocol_mode_t = hid_protocol_mode_t(0);
}
impl hid_protocol_mode_t {
    pub const HID_PROTOCOL_MODE_REPORT: hid_protocol_mode_t = hid_protocol_mode_t(1);
}
impl hid_protocol_mode_t {
    pub const HID_PROTOCOL_MODE_REPORT_WITH_FALLBACK_TO_BOOT: hid_protocol_mode_t =
        hid_protocol_mode_t(2);
}
impl ::core::ops::BitOr<hid_protocol_mode_t> for hid_protocol_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_protocol_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_protocol_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_protocol_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_protocol_mode_t> for hid_protocol_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_protocol_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_protocol_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_protocol_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_protocol_mode_t(pub cty::c_uint);
impl hid_report_type_t {
    pub const HID_REPORT_TYPE_RESERVED: hid_report_type_t = hid_report_type_t(0);
}
impl hid_report_type_t {
    pub const HID_REPORT_TYPE_INPUT: hid_report_type_t = hid_report_type_t(1);
}
impl hid_report_type_t {
    pub const HID_REPORT_TYPE_OUTPUT: hid_report_type_t = hid_report_type_t(2);
}
impl hid_report_type_t {
    pub const HID_REPORT_TYPE_FEATURE: hid_report_type_t = hid_report_type_t(3);
}
impl ::core::ops::BitOr<hid_report_type_t> for hid_report_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_report_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_report_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_report_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_report_type_t> for hid_report_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_report_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_report_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_report_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_report_type_t(pub cty::c_uint);
impl hid_report_id_status_t {
    pub const HID_REPORT_ID_UNDECLARED: hid_report_id_status_t = hid_report_id_status_t(0);
}
impl hid_report_id_status_t {
    pub const HID_REPORT_ID_VALID: hid_report_id_status_t = hid_report_id_status_t(1);
}
impl hid_report_id_status_t {
    pub const HID_REPORT_ID_INVALID: hid_report_id_status_t = hid_report_id_status_t(2);
}
impl ::core::ops::BitOr<hid_report_id_status_t> for hid_report_id_status_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_report_id_status_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_report_id_status_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_report_id_status_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_report_id_status_t> for hid_report_id_status_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_report_id_status_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_report_id_status_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_report_id_status_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_report_id_status_t(pub cty::c_uint);
extern "C" {
    pub fn btstack_hid_get_boot_descriptor_data() -> *const u8;
}
extern "C" {
    pub fn btstack_hid_get_boot_descriptor_len() -> u16;
}
impl TagType {
    pub const Main: TagType = TagType(0);
}
impl TagType {
    pub const Global: TagType = TagType(1);
}
impl TagType {
    pub const Local: TagType = TagType(2);
}
impl TagType {
    pub const Reserved: TagType = TagType(3);
}
impl ::core::ops::BitOr<TagType> for TagType {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        TagType(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for TagType {
    #[inline]
    fn bitor_assign(&mut self, rhs: TagType) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<TagType> for TagType {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        TagType(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for TagType {
    #[inline]
    fn bitand_assign(&mut self, rhs: TagType) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TagType(pub cty::c_uint);
impl MainItemTag {
    pub const Input: MainItemTag = MainItemTag(8);
}
impl MainItemTag {
    pub const Output: MainItemTag = MainItemTag(9);
}
impl MainItemTag {
    pub const Coll: MainItemTag = MainItemTag(10);
}
impl MainItemTag {
    pub const Feature: MainItemTag = MainItemTag(11);
}
impl MainItemTag {
    pub const EndColl: MainItemTag = MainItemTag(12);
}
impl ::core::ops::BitOr<MainItemTag> for MainItemTag {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        MainItemTag(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for MainItemTag {
    #[inline]
    fn bitor_assign(&mut self, rhs: MainItemTag) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<MainItemTag> for MainItemTag {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        MainItemTag(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for MainItemTag {
    #[inline]
    fn bitand_assign(&mut self, rhs: MainItemTag) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MainItemTag(pub cty::c_uint);
impl GlobalItemTag {
    pub const UsagePage: GlobalItemTag = GlobalItemTag(0);
}
impl GlobalItemTag {
    pub const LogicalMinimum: GlobalItemTag = GlobalItemTag(1);
}
impl GlobalItemTag {
    pub const LogicalMaximum: GlobalItemTag = GlobalItemTag(2);
}
impl GlobalItemTag {
    pub const PhysicalMinimum: GlobalItemTag = GlobalItemTag(3);
}
impl GlobalItemTag {
    pub const PhysicalMaximum: GlobalItemTag = GlobalItemTag(4);
}
impl GlobalItemTag {
    pub const UnitExponent: GlobalItemTag = GlobalItemTag(5);
}
impl GlobalItemTag {
    pub const Unit: GlobalItemTag = GlobalItemTag(6);
}
impl GlobalItemTag {
    pub const ReportSize: GlobalItemTag = GlobalItemTag(7);
}
impl GlobalItemTag {
    pub const ReportID: GlobalItemTag = GlobalItemTag(8);
}
impl GlobalItemTag {
    pub const ReportCount: GlobalItemTag = GlobalItemTag(9);
}
impl GlobalItemTag {
    pub const Push: GlobalItemTag = GlobalItemTag(10);
}
impl GlobalItemTag {
    pub const Pop: GlobalItemTag = GlobalItemTag(11);
}
impl ::core::ops::BitOr<GlobalItemTag> for GlobalItemTag {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        GlobalItemTag(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for GlobalItemTag {
    #[inline]
    fn bitor_assign(&mut self, rhs: GlobalItemTag) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<GlobalItemTag> for GlobalItemTag {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        GlobalItemTag(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for GlobalItemTag {
    #[inline]
    fn bitand_assign(&mut self, rhs: GlobalItemTag) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GlobalItemTag(pub cty::c_uint);
impl LocalItemTag {
    pub const Usage: LocalItemTag = LocalItemTag(0);
}
impl LocalItemTag {
    pub const UsageMinimum: LocalItemTag = LocalItemTag(1);
}
impl LocalItemTag {
    pub const UsageMaximum: LocalItemTag = LocalItemTag(2);
}
impl LocalItemTag {
    pub const DesignatorIndex: LocalItemTag = LocalItemTag(3);
}
impl LocalItemTag {
    pub const DesignatorMinimum: LocalItemTag = LocalItemTag(4);
}
impl LocalItemTag {
    pub const DesignatorMaximum: LocalItemTag = LocalItemTag(5);
}
impl LocalItemTag {
    pub const StringIndex: LocalItemTag = LocalItemTag(6);
}
impl LocalItemTag {
    pub const StringMinimum: LocalItemTag = LocalItemTag(7);
}
impl LocalItemTag {
    pub const StringMaximum: LocalItemTag = LocalItemTag(8);
}
impl LocalItemTag {
    pub const Delimiter: LocalItemTag = LocalItemTag(9);
}
impl ::core::ops::BitOr<LocalItemTag> for LocalItemTag {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        LocalItemTag(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for LocalItemTag {
    #[inline]
    fn bitor_assign(&mut self, rhs: LocalItemTag) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<LocalItemTag> for LocalItemTag {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        LocalItemTag(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for LocalItemTag {
    #[inline]
    fn bitand_assign(&mut self, rhs: LocalItemTag) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LocalItemTag(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hid_descriptor_item_t {
    pub item_value: i32,
    pub item_size: u16,
    pub item_type: u8,
    pub item_tag: u8,
    pub data_size: u8,
}
impl btstack_hid_parser_state_t {
    pub const BTSTACK_HID_PARSER_SCAN_FOR_REPORT_ITEM: btstack_hid_parser_state_t =
        btstack_hid_parser_state_t(0);
}
impl btstack_hid_parser_state_t {
    pub const BTSTACK_HID_PARSER_USAGES_AVAILABLE: btstack_hid_parser_state_t =
        btstack_hid_parser_state_t(1);
}
impl btstack_hid_parser_state_t {
    pub const BTSTACK_HID_PARSER_COMPLETE: btstack_hid_parser_state_t =
        btstack_hid_parser_state_t(2);
}
impl ::core::ops::BitOr<btstack_hid_parser_state_t> for btstack_hid_parser_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        btstack_hid_parser_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for btstack_hid_parser_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: btstack_hid_parser_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<btstack_hid_parser_state_t> for btstack_hid_parser_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        btstack_hid_parser_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for btstack_hid_parser_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: btstack_hid_parser_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct btstack_hid_parser_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_hid_parser_t {
    pub descriptor: *const u8,
    pub descriptor_len: u16,
    pub report_type: hid_report_type_t,
    pub report: *const u8,
    pub report_len: u16,
    pub state: btstack_hid_parser_state_t,
    pub descriptor_item: hid_descriptor_item_t,
    pub descriptor_pos: u16,
    pub report_pos_in_bit: u16,
    pub usage_pos: u16,
    pub usage_page: u16,
    pub usage_minimum: u32,
    pub usage_maximum: u32,
    pub available_usages: u16,
    pub required_usages: u8,
    pub active_record: u8,
    pub have_usage_min: u8,
    pub have_usage_max: u8,
    pub global_logical_minimum: i32,
    pub global_logical_maximum: i32,
    pub global_usage_page: u16,
    pub global_report_size: u8,
    pub global_report_count: u8,
    pub global_report_id: u8,
}
extern "C" {
    #[doc = " @brief Initialize HID Parser.\n @param parser state\n @param hid_descriptor\n @param hid_descriptor_len\n @param hid_report_type\n @param hid_report\n @param hid_report_len"]
    pub fn btstack_hid_parser_init(
        parser: *mut btstack_hid_parser_t,
        hid_descriptor: *const u8,
        hid_descriptor_len: u16,
        hid_report_type: hid_report_type_t,
        hid_report: *const u8,
        hid_report_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Checks if more fields are available\n @param parser"]
    pub fn btstack_hid_parser_has_more(parser: *mut btstack_hid_parser_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get next field\n @param parser\n @param usage_page\n @param usage\n @param value provided in HID report"]
    pub fn btstack_hid_parser_get_field(
        parser: *mut btstack_hid_parser_t,
        usage_page: *mut u16,
        usage: *mut u16,
        value: *mut i32,
    );
}
extern "C" {
    #[doc = " @brief Parses descriptor item\n @param item\n @param hid_descriptor\n @param hid_descriptor_len"]
    pub fn btstack_hid_parse_descriptor_item(
        item: *mut hid_descriptor_item_t,
        hid_descriptor: *const u8,
        hid_descriptor_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Parses descriptor and returns report size for given report ID and report type\n @param report_id\n @param report_type\n @param hid_descriptor_len\n @param hid_descriptor"]
    pub fn btstack_hid_get_report_size_for_id(
        report_id: cty::c_int,
        report_type: hid_report_type_t,
        hid_descriptor_len: u16,
        hid_descriptor: *const u8,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Parses descriptor and returns report size for given report ID and report type\n @param report_id\n @param hid_descriptor_len\n @param hid_descriptor"]
    pub fn btstack_hid_id_valid(
        report_id: cty::c_int,
        hid_descriptor_len: u16,
        hid_descriptor: *const u8,
    ) -> hid_report_id_status_t;
}
extern "C" {
    #[doc = " @brief Parses descriptor and returns 1 if report ID found\n @param hid_descriptor_len\n @param hid_descriptor"]
    pub fn btstack_hid_report_id_declared(
        hid_descriptor_len: u16,
        hid_descriptor: *const u8,
    ) -> cty::c_int;
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const COMMAND_REJECT: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(1);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const CONNECTION_REQUEST: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(2);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const CONNECTION_RESPONSE: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(3);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const CONFIGURE_REQUEST: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(4);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const CONFIGURE_RESPONSE: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(5);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const DISCONNECTION_REQUEST: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(6);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const DISCONNECTION_RESPONSE: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(7);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const ECHO_REQUEST: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(8);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const ECHO_RESPONSE: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(9);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const INFORMATION_REQUEST: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(10);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const INFORMATION_RESPONSE: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(11);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const CONNECTION_PARAMETER_UPDATE_REQUEST: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(18);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const CONNECTION_PARAMETER_UPDATE_RESPONSE: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(19);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const LE_CREDIT_BASED_CONNECTION_REQUEST: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(20);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const LE_CREDIT_BASED_CONNECTION_RESPONSE: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(21);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const L2CAP_FLOW_CONTROL_CREDIT_INDICATION: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(22);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const L2CAP_CREDIT_BASED_CONNECTION_REQUEST: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(23);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const L2CAP_CREDIT_BASED_CONNECTION_RESPONSE: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(24);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const L2CAP_CREDIT_BASED_RECONFIGURE_REQUEST: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(25);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const L2CAP_CREDIT_BASED_RECONFIGURE_RESPONSE: L2CAP_SIGNALING_COMMANDS =
        L2CAP_SIGNALING_COMMANDS(26);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const SM_PAIRING_FAILED: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(30);
}
impl L2CAP_SIGNALING_COMMANDS {
    pub const COMMAND_REJECT_LE: L2CAP_SIGNALING_COMMANDS = L2CAP_SIGNALING_COMMANDS(31);
}
impl ::core::ops::BitOr<L2CAP_SIGNALING_COMMANDS> for L2CAP_SIGNALING_COMMANDS {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        L2CAP_SIGNALING_COMMANDS(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for L2CAP_SIGNALING_COMMANDS {
    #[inline]
    fn bitor_assign(&mut self, rhs: L2CAP_SIGNALING_COMMANDS) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<L2CAP_SIGNALING_COMMANDS> for L2CAP_SIGNALING_COMMANDS {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        L2CAP_SIGNALING_COMMANDS(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for L2CAP_SIGNALING_COMMANDS {
    #[inline]
    fn bitand_assign(&mut self, rhs: L2CAP_SIGNALING_COMMANDS) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct L2CAP_SIGNALING_COMMANDS(pub cty::c_uint);
impl l2cap_channel_mode_t {
    pub const L2CAP_CHANNEL_MODE_BASIC: l2cap_channel_mode_t = l2cap_channel_mode_t(0);
}
impl l2cap_channel_mode_t {
    pub const L2CAP_CHANNEL_MODE_RETRANSMISSION: l2cap_channel_mode_t = l2cap_channel_mode_t(1);
}
impl l2cap_channel_mode_t {
    pub const L2CAP_CHANNEL_MODE_FLOW_CONTROL: l2cap_channel_mode_t = l2cap_channel_mode_t(2);
}
impl l2cap_channel_mode_t {
    pub const L2CAP_CHANNEL_MODE_ENHANCED_RETRANSMISSION: l2cap_channel_mode_t =
        l2cap_channel_mode_t(3);
}
impl l2cap_channel_mode_t {
    pub const L2CAP_CHANNEL_MODE_STREAMING_MODE: l2cap_channel_mode_t = l2cap_channel_mode_t(4);
}
impl ::core::ops::BitOr<l2cap_channel_mode_t> for l2cap_channel_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        l2cap_channel_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for l2cap_channel_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: l2cap_channel_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<l2cap_channel_mode_t> for l2cap_channel_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        l2cap_channel_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for l2cap_channel_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: l2cap_channel_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct l2cap_channel_mode_t(pub cty::c_uint);
extern "C" {
    #[doc = " @brief Create L2CAP signaling packet based on template and va_args\n @param acl_buffer to create packet\n @param handle\n @param pb_flags\n @param cid\n @param cmd\n @param identifier\n @param argptr\n @return"]
    pub fn l2cap_create_signaling_packet(
        acl_buffer: *mut u8,
        handle: hci_con_handle_t,
        pb_flags: u8,
        cid: u16,
        cmd: L2CAP_SIGNALING_COMMANDS,
        identifier: u8,
        argptr: va_list,
    ) -> u16;
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_CLOSED: L2CAP_STATE = L2CAP_STATE(1);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_CREATE_CONNECTION: L2CAP_STATE = L2CAP_STATE(2);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_CONNECTION_COMPLETE: L2CAP_STATE = L2CAP_STATE(3);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_REMOTE_SUPPORTED_FEATURES: L2CAP_STATE = L2CAP_STATE(4);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_INCOMING_SECURITY_LEVEL_UPDATE: L2CAP_STATE = L2CAP_STATE(5);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_OUTGOING_SECURITY_LEVEL_UPDATE: L2CAP_STATE = L2CAP_STATE(6);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_INCOMING_EXTENDED_FEATURES: L2CAP_STATE = L2CAP_STATE(7);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_OUTGOING_EXTENDED_FEATURES: L2CAP_STATE = L2CAP_STATE(8);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_CLIENT_ACCEPT_OR_REJECT: L2CAP_STATE = L2CAP_STATE(9);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_CONNECT_RSP: L2CAP_STATE = L2CAP_STATE(10);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_CONFIG: L2CAP_STATE = L2CAP_STATE(11);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_OPEN: L2CAP_STATE = L2CAP_STATE(12);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_DISCONNECT: L2CAP_STATE = L2CAP_STATE(13);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_CONNECTION_REQUEST: L2CAP_STATE = L2CAP_STATE(14);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_INSUFFICIENT_SECURITY: L2CAP_STATE =
        L2CAP_STATE(15);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_DECLINE: L2CAP_STATE = L2CAP_STATE(16);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_CONNECTION_RESPONSE_ACCEPT: L2CAP_STATE = L2CAP_STATE(17);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_DISCONNECT_REQUEST: L2CAP_STATE = L2CAP_STATE(18);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_DISCONNECT_RESPONSE: L2CAP_STATE = L2CAP_STATE(19);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_LE_CONNECTION_REQUEST: L2CAP_STATE = L2CAP_STATE(20);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_LE_CONNECTION_RESPONSE_DECLINE: L2CAP_STATE = L2CAP_STATE(21);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_LE_CONNECTION_RESPONSE_ACCEPT: L2CAP_STATE = L2CAP_STATE(22);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_LE_CONNECTION_RESPONSE: L2CAP_STATE = L2CAP_STATE(23);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_EMIT_OPEN_FAILED_AND_DISCARD: L2CAP_STATE = L2CAP_STATE(24);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_ENHANCED_CONNECTION_REQUEST: L2CAP_STATE = L2CAP_STATE(25);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_ENHANCED_CONNECTION_RESPONSE: L2CAP_STATE = L2CAP_STATE(26);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_ENHANCED_CONNECTION_RESPONSE: L2CAP_STATE = L2CAP_STATE(27);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WILL_SEND_EHNANCED_RENEGOTIATION_REQUEST: L2CAP_STATE = L2CAP_STATE(28);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_WAIT_ENHANCED_RENEGOTIATION_RESPONSE: L2CAP_STATE = L2CAP_STATE(29);
}
impl L2CAP_STATE {
    pub const L2CAP_STATE_INVALID: L2CAP_STATE = L2CAP_STATE(30);
}
impl ::core::ops::BitOr<L2CAP_STATE> for L2CAP_STATE {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        L2CAP_STATE(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for L2CAP_STATE {
    #[inline]
    fn bitor_assign(&mut self, rhs: L2CAP_STATE) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<L2CAP_STATE> for L2CAP_STATE {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        L2CAP_STATE(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for L2CAP_STATE {
    #[inline]
    fn bitand_assign(&mut self, rhs: L2CAP_STATE) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct L2CAP_STATE(pub cty::c_uint);
impl l2cap_channel_type_t {
    pub const L2CAP_CHANNEL_TYPE_CLASSIC: l2cap_channel_type_t = l2cap_channel_type_t(0);
}
impl l2cap_channel_type_t {
    pub const L2CAP_CHANNEL_TYPE_CONNECTIONLESS: l2cap_channel_type_t = l2cap_channel_type_t(1);
}
impl l2cap_channel_type_t {
    pub const L2CAP_CHANNEL_TYPE_CHANNEL_CBM: l2cap_channel_type_t = l2cap_channel_type_t(2);
}
impl l2cap_channel_type_t {
    pub const L2CAP_CHANNEL_TYPE_FIXED_LE: l2cap_channel_type_t = l2cap_channel_type_t(3);
}
impl l2cap_channel_type_t {
    pub const L2CAP_CHANNEL_TYPE_FIXED_CLASSIC: l2cap_channel_type_t = l2cap_channel_type_t(4);
}
impl l2cap_channel_type_t {
    pub const L2CAP_CHANNEL_TYPE_CHANNEL_ECBM: l2cap_channel_type_t = l2cap_channel_type_t(5);
}
impl ::core::ops::BitOr<l2cap_channel_type_t> for l2cap_channel_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        l2cap_channel_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for l2cap_channel_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: l2cap_channel_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<l2cap_channel_type_t> for l2cap_channel_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        l2cap_channel_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for l2cap_channel_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: l2cap_channel_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct l2cap_channel_type_t(pub cty::c_uint);
impl l2cap_segmentation_and_reassembly_t {
    pub const L2CAP_SEGMENTATION_AND_REASSEMBLY_UNSEGMENTED_L2CAP_SDU:
        l2cap_segmentation_and_reassembly_t = l2cap_segmentation_and_reassembly_t(0);
}
impl l2cap_segmentation_and_reassembly_t {
    pub const L2CAP_SEGMENTATION_AND_REASSEMBLY_START_OF_L2CAP_SDU:
        l2cap_segmentation_and_reassembly_t = l2cap_segmentation_and_reassembly_t(1);
}
impl l2cap_segmentation_and_reassembly_t {
    pub const L2CAP_SEGMENTATION_AND_REASSEMBLY_END_OF_L2CAP_SDU:
        l2cap_segmentation_and_reassembly_t = l2cap_segmentation_and_reassembly_t(2);
}
impl l2cap_segmentation_and_reassembly_t {
    pub const L2CAP_SEGMENTATION_AND_REASSEMBLY_CONTINUATION_OF_L2CAP_SDU:
        l2cap_segmentation_and_reassembly_t = l2cap_segmentation_and_reassembly_t(3);
}
impl ::core::ops::BitOr<l2cap_segmentation_and_reassembly_t>
    for l2cap_segmentation_and_reassembly_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        l2cap_segmentation_and_reassembly_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for l2cap_segmentation_and_reassembly_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: l2cap_segmentation_and_reassembly_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<l2cap_segmentation_and_reassembly_t>
    for l2cap_segmentation_and_reassembly_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        l2cap_segmentation_and_reassembly_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for l2cap_segmentation_and_reassembly_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: l2cap_segmentation_and_reassembly_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct l2cap_segmentation_and_reassembly_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_ertm_rx_packet_state_t {
    pub sar: l2cap_segmentation_and_reassembly_t,
    pub len: u16,
    pub valid: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_ertm_tx_packet_state_t {
    pub sar: l2cap_segmentation_and_reassembly_t,
    pub len: u16,
    pub tx_seq: u8,
    pub retry_count: u8,
    pub retransmission_requested: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_ertm_config_t {
    pub ertm_mandatory: u8,
    pub max_transmit: u8,
    pub retransmission_timeout_ms: u16,
    pub monitor_timeout_ms: u16,
    pub local_mtu: u16,
    pub num_tx_buffers: u8,
    pub num_rx_buffers: u8,
    pub fcs_option: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_fixed_channel {
    pub item: btstack_linked_item_t,
    pub channel_type: l2cap_channel_type_t,
    pub local_cid: u16,
    pub packet_handler: btstack_packet_handler_t,
    pub waiting_for_can_send_now: u8,
}
pub type l2cap_fixed_channel_t = l2cap_fixed_channel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_channel_t {
    pub item: btstack_linked_item_t,
    pub channel_type: l2cap_channel_type_t,
    pub local_cid: u16,
    pub packet_handler: btstack_packet_handler_t,
    pub waiting_for_can_send_now: u8,
    pub rtx: btstack_timer_source_t,
    pub state: L2CAP_STATE,
    pub state_var: u16,
    pub con_handle: hci_con_handle_t,
    pub address: bd_addr_t,
    pub address_type: bd_addr_type_t,
    pub remote_sig_id: u8,
    pub local_sig_id: u8,
    pub remote_cid: u16,
    pub local_mtu: u16,
    pub remote_mtu: u16,
    pub flush_timeout: u16,
    pub psm: u16,
    pub required_security_level: gap_security_level_t,
    pub reason: u16,
    pub unknown_option: u8,
    pub receive_sdu_buffer: *mut u8,
    pub receive_sdu_len: u16,
    pub receive_sdu_pos: u16,
    pub send_sdu_buffer: *const u8,
    pub send_sdu_len: u16,
    pub send_sdu_pos: u16,
    pub remote_mps: u16,
    pub credits_outgoing: u16,
    pub new_credits_incoming: u16,
    pub credits_incoming: u16,
    pub automatic_credits: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_service_t {
    pub item: btstack_linked_item_t,
    pub psm: u16,
    pub mtu: u16,
    pub packet_handler: btstack_packet_handler_t,
    pub required_security_level: gap_security_level_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l2cap_signaling_response {
    pub handle: hci_con_handle_t,
    pub sig_id: u8,
    pub code: u8,
    pub cid: u16,
    pub data: u16,
}
pub type l2cap_signaling_response_t = l2cap_signaling_response;
extern "C" {
    pub fn l2cap_register_fixed_channel(packet_handler: btstack_packet_handler_t, channel_id: u16);
}
extern "C" {
    pub fn l2cap_can_send_fixed_channel_packet_now(
        con_handle: hci_con_handle_t,
        channel_id: u16,
    ) -> bool;
}
extern "C" {
    pub fn l2cap_request_can_send_fix_channel_now_event(
        con_handle: hci_con_handle_t,
        channel_id: u16,
    );
}
extern "C" {
    pub fn l2cap_send_connectionless(
        con_handle: hci_con_handle_t,
        cid: u16,
        data: *mut u8,
        len: u16,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_send_prepared_connectionless(
        con_handle: hci_con_handle_t,
        cid: u16,
        len: u16,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_send_echo_request(
        con_handle: hci_con_handle_t,
        data: *mut u8,
        len: u16,
    ) -> cty::c_int;
}
extern "C" {
    pub fn l2cap_require_security_level_2_for_outgoing_sdp();
}
extern "C" {
    pub fn l2cap_can_send_prepared_packet_now(local_cid: u16) -> bool;
}
extern "C" {
    #[doc = " @brief Set up L2CAP and register L2CAP with HCI layer."]
    pub fn l2cap_init();
}
extern "C" {
    #[doc = " @brief Add event packet handler for LE Connection Parameter Update events"]
    pub fn l2cap_add_event_handler(callback_handler: *mut btstack_packet_callback_registration_t);
}
extern "C" {
    #[doc = " @brief Remove event packet handler."]
    pub fn l2cap_remove_event_handler(
        callback_handler: *mut btstack_packet_callback_registration_t,
    );
}
extern "C" {
    #[doc = " @brief Get max MTU for Classic connections based on btstack configuration"]
    pub fn l2cap_max_mtu() -> u16;
}
extern "C" {
    #[doc = " @brief Get max MTU for LE connections based on btstack configuration"]
    pub fn l2cap_max_le_mtu() -> u16;
}
extern "C" {
    #[doc = " @brief Set the max MTU for LE connections, if not set l2cap_max_mtu() will be used."]
    pub fn l2cap_set_max_le_mtu(max_mtu: u16);
}
extern "C" {
    #[doc = " @brief Creates L2CAP channel to the PSM of a remote device with baseband address. A new baseband connection will be initiated if necessary.\n @param packet_handler\n @param address\n @param psm\n @param mtu\n @param local_cid\n @return status"]
    pub fn l2cap_create_channel(
        packet_handler: btstack_packet_handler_t,
        address: *mut u8,
        psm: u16,
        mtu: u16,
        out_local_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Disconnects L2CAP channel with given identifier.\n @param local_cid\n @return status ERROR_CODE_SUCCESS if successful or L2CAP_LOCAL_CID_DOES_NOT_EXIST"]
    pub fn l2cap_disconnect(local_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Queries the maximal transfer unit (MTU) for L2CAP channel with given identifier."]
    pub fn l2cap_get_remote_mtu_for_local_cid(local_cid: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Sends L2CAP data packet to the channel with given identifier.\n @note For channel in credit-based flow control mode, data needs to stay valid until .. event\n @param local_cid\n @param data to send\n @param len of data\n @return status"]
    pub fn l2cap_send(local_cid: u16, data: *const u8, len: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Registers L2CAP service with given PSM and MTU, and assigns a packet handler.\n @param packet_handler\n @param psm\n @param mtu\n @param security_level\n @return status ERROR_CODE_SUCCESS if successful, otherwise L2CAP_SERVICE_ALREADY_REGISTERED or BTSTACK_MEMORY_ALLOC_FAILED"]
    pub fn l2cap_register_service(
        packet_handler: btstack_packet_handler_t,
        psm: u16,
        mtu: u16,
        security_level: gap_security_level_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Unregisters L2CAP service with given PSM."]
    pub fn l2cap_unregister_service(psm: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Accepts incoming L2CAP connection."]
    pub fn l2cap_accept_connection(local_cid: u16);
}
extern "C" {
    #[doc = " @brief Deny incoming L2CAP connection."]
    pub fn l2cap_decline_connection(local_cid: u16);
}
extern "C" {
    #[doc = " @brief Check if outgoing buffer is available and that there's space on the Bluetooth module\n @return true if packet can be sent"]
    pub fn l2cap_can_send_packet_now(local_cid: u16) -> bool;
}
extern "C" {
    #[doc = " @brief Request emission of L2CAP_EVENT_CAN_SEND_NOW as soon as possible\n @note L2CAP_EVENT_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it\n @param local_cid\n @return status"]
    pub fn l2cap_request_can_send_now_event(local_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Reserve outgoing buffer\n @note Only for L2CAP Basic Mode Channels\n @return true on success"]
    pub fn l2cap_reserve_packet_buffer() -> bool;
}
extern "C" {
    #[doc = " @brief Get outgoing buffer and prepare data.\n @note Only for L2CAP Basic Mode Channels"]
    pub fn l2cap_get_outgoing_buffer() -> *mut u8;
}
extern "C" {
    #[doc = " @brief Send L2CAP packet prepared in outgoing buffer to channel\n @note Only for L2CAP Basic Mode Channels"]
    pub fn l2cap_send_prepared(local_cid: u16, len: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Release outgoing buffer (only needed if l2cap_send_prepared is not called)\n @note Only for L2CAP Basic Mode Channels"]
    pub fn l2cap_release_packet_buffer();
}
extern "C" {
    #[doc = " @brief Creates L2CAP channel to the PSM of a remote device with baseband address using Enhanced Retransmission Mode.\n        A new baseband connection will be initiated if necessary.\n @param packet_handler\n @param address\n @param psm\n @param ertm_config\n @param buffer to store reassembled rx packet, out-of-order packets and unacknowledged outgoing packets with their tretransmission timers\n @param size of buffer\n @param local_cid\n @return status"]
    pub fn l2cap_ertm_create_channel(
        packet_handler: btstack_packet_handler_t,
        address: *mut u8,
        psm: u16,
        ertm_contig: *mut l2cap_ertm_config_t,
        buffer: *mut u8,
        size: u32,
        out_local_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Accepts incoming L2CAP connection for Enhanced Retransmission Mode\n @param local_cid\n @param ertm_config\n @param buffer to store reassembled rx packet, out-of-order packets and unacknowledged outgoing packets with their tretransmission timers\n @param size of buffer\n @return status"]
    pub fn l2cap_ertm_accept_connection(
        local_cid: u16,
        ertm_contig: *mut l2cap_ertm_config_t,
        buffer: *mut u8,
        size: u32,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Deny incoming incoming L2CAP connection for Enhanced Retransmission Mode\n @param local_cid\n @return status"]
    pub fn l2cap_ertm_decline_connection(local_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief ERTM Set channel as busy.\n @note Can be cleared by l2cap_ertm_set_ready\n @param local_cid\n @return status"]
    pub fn l2cap_ertm_set_busy(local_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief ERTM Set channel as ready\n @note Used after l2cap_ertm_set_busy\n @param local_cid\n @return status"]
    pub fn l2cap_ertm_set_ready(local_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Register L2CAP service in LE Credit-Based Flow-Control Mode\n @note MTU and initial credits are specified in l2cap_cbm_accept_connection(..) call\n @param packet_handler\n @param psm\n @param security_level"]
    pub fn l2cap_cbm_register_service(
        packet_handler: btstack_packet_handler_t,
        psm: u16,
        security_level: gap_security_level_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Unregister L2CAP service in LE Credit-Based Flow-Control Mode\n @param psm"]
    pub fn l2cap_cbm_unregister_service(psm: u16) -> u8;
}
extern "C" {
    pub fn l2cap_cbm_accept_connection(
        local_cid: u16,
        receive_sdu_buffer: *mut u8,
        mtu: u16,
        initial_credits: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Deecline connection in LE Credit-Based Flow-Control Mode\n @param local_cid             L2CAP Channel Identifier\n @param result                result, see L2CAP_CBM_CONNECTION_RESULT_SUCCESS in bluetooth.h"]
    pub fn l2cap_cbm_decline_connection(local_cid: u16, result: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Create outgoing channel in LE Credit-Based Flow-Control Mode\n @param packet_handler        Packet handler for this connection\n @param con_handle            HCI Connection Handle, LE transport\n @param psm                   Service PSM to connect to\n @param receive_buffer        buffer used for reassembly of L2CAP LE Information Frames into service data unit (SDU) with given MTU\n @param receive_buffer_size   buffer size equals MTU\n @param initial_credits       Number of initial credits provided to peer or L2CAP_LE_AUTOMATIC_CREDITS to enable automatic credits\n @param security_level        Minimum required security level\n @param out_local_cid         L2CAP LE Channel Identifier is stored here"]
    pub fn l2cap_cbm_create_channel(
        packet_handler: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        psm: u16,
        receive_sdu_buffer: *mut u8,
        mtu: u16,
        initial_credits: u16,
        security_level: gap_security_level_t,
        out_local_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Provide credits for channel in LE Credit-Based Flow-Control Mode\n @param local_cid             L2CAP Channel Identifier\n @param credits               Number additional credits for peer"]
    pub fn l2cap_cbm_provide_credits(local_cid: u16, credits: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Register L2CAP service in Enhanced Credit-Based Flow-Control Mode\n @note MTU and initial credits are specified in l2cap_enhanced_accept_connection(..) call\n @param packet_handler\n @param psm\n @param min_remote_mtu\n @param security_level\n @return status"]
    pub fn l2cap_ecbm_register_service(
        packet_handler: btstack_packet_handler_t,
        psm: u16,
        min_remote_mtu: u16,
        security_level: gap_security_level_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Unregister L2CAP service in Enhanced Credit-Based Flow-Control Mode\n @param psm\n @return status"]
    pub fn l2cap_ecbm_unregister_service(psm: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Set Minimal MPS for channel in Enhanced Credit-Based Flow-Control Mode\n @param mps_min"]
    pub fn l2cap_ecbm_mps_set_min(mps_min: u16);
}
extern "C" {
    #[doc = " @brief Set Minimal MPS for channel in Enhanced Credit-Based Flow-Control Mode\n @param mps_max"]
    pub fn l2cap_ecbm_mps_set_max(mps_max: u16);
}
extern "C" {
    #[doc = " @brief Create outgoing channel in Enhanced Credit-Based Flow-Control Mode\n @note receive_buffer points to an array of receive buffers with num_channels elements\n @note out_local_cid points to an array where CID is stored with num_channel elements\n @param packet_handler        Packet handler for this connection\n @param con_handle            HCI Connection Handle\n @param security_level        Minimum required security level\n @param psm                   Service PSM to connect to\n @param num_channels          number of channels to create\n @param initial_credits       Number of initial credits provided to peer per channel or L2CAP_LE_AUTOMATIC_CREDITS to enable automatic credits\n @param receive_buffer_size   buffer size equals MTU\n @param receive_buffers       Array of buffers used for reassembly of L2CAP Information Frames into service data unit (SDU) with given MTU\n @param out_local_cids        Array of L2CAP Channel Identifiers is stored here on success\n @return status"]
    pub fn l2cap_ecbm_create_channels(
        packet_handler: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        security_level: gap_security_level_t,
        psm: u16,
        num_channels: u8,
        initial_credits: u16,
        receive_buffer_size: u16,
        receive_buffers: *mut *mut u8,
        out_local_cids: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief  Accept incoming connection Enhanced Credit-Based Flow-Control Mode\n @param local_cid            from L2CAP_EVENT_INCOMING_DATA_CONNECTION\n @param num_channels\n @param initial_credits      Number of initial credits provided to peer per channel or L2CAP_LE_AUTOMATIC_CREDITS to enable automatic credits\n @param receive_buffer_size\n @param receive_buffers      Array of buffers used for reassembly of L2CAP Information Frames into service data unit (SDU) with given MTU\n @param out_local_cids       Array of L2CAP Channel Identifiers is stored here on success\n @return status"]
    pub fn l2cap_ecbm_accept_channels(
        local_cid: u16,
        num_channels: u8,
        initial_credits: u16,
        receive_buffer_size: u16,
        receive_buffers: *mut *mut u8,
        out_local_cids: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Decline connection in Enhanced Credit-Based Flow-Control Mode\n @param local_cid           from L2CAP_EVENT_INCOMING_DATA_CONNECTION\n @param result              See L2CAP_ECBM_CONNECTION_RESULT_ALL_SUCCESS in bluetooth.h\n @return status"]
    pub fn l2cap_ecbm_decline_channels(local_cid: u16, result: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Provide credits for channel in Enhanced Credit-Based Flow-Control Mode\n @param local_cid             L2CAP Channel Identifier\n @param credits               Number additional credits for peer\n @return status"]
    pub fn l2cap_ecbm_provide_credits(local_cid: u16, credits: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Request emission of L2CAP_EVENT_ECBM_CAN_SEND_NOW as soon as possible\n @note L2CAP_EVENT_ECBM_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it\n @param local_cid             L2CAP Channel Identifier\n @return status"]
    pub fn l2cap_ecbm_request_can_send_now_event(local_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Reconfigure MPS/MTU of local channels\n @param num_cids\n @param local_cids            array of local_cids to reconfigure\n @param receive_buffer_size   buffer size equals MTU\n @param receive_buffers       Array of buffers used for reassembly of L2CAP Information Frames into service data unit (SDU) with given MTU\n @return status"]
    pub fn l2cap_ecbm_reconfigure_channels(
        num_cids: u8,
        local_cids: *mut u16,
        receive_buffer_size: i16,
        receive_buffers: *mut *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief De-Init L2CAP"]
    pub fn l2cap_deinit();
}
extern "C" {
    pub fn l2cap_create_ertm_channel(
        packet_handler: btstack_packet_handler_t,
        address: *mut u8,
        psm: u16,
        ertm_contig: *mut l2cap_ertm_config_t,
        buffer: *mut u8,
        size: u32,
        out_local_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_accept_ertm_connection(
        local_cid: u16,
        ertm_contig: *mut l2cap_ertm_config_t,
        buffer: *mut u8,
        size: u32,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_le_register_service(
        packet_handler: btstack_packet_handler_t,
        psm: u16,
        security_level: gap_security_level_t,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_le_unregister_service(psm: u16) -> u8;
}
extern "C" {
    pub fn l2cap_le_accept_connection(
        local_cid: u16,
        receive_sdu_buffer: *mut u8,
        mtu: u16,
        initial_credits: u16,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_le_decline_connection(local_cid: u16) -> u8;
}
extern "C" {
    pub fn l2cap_le_create_channel(
        packet_handler: btstack_packet_handler_t,
        con_handle: hci_con_handle_t,
        psm: u16,
        receive_sdu_buffer: *mut u8,
        mtu: u16,
        initial_credits: u16,
        security_level: gap_security_level_t,
        out_local_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    pub fn l2cap_le_provide_credits(local_cid: u16, credits: u16) -> u8;
}
extern "C" {
    pub fn l2cap_le_can_send_now(local_cid: u16) -> bool;
}
extern "C" {
    pub fn l2cap_le_request_can_send_now_event(local_cid: u16) -> u8;
}
extern "C" {
    pub fn l2cap_le_send_data(local_cid: u16, data: *const u8, size: u16) -> u8;
}
extern "C" {
    pub fn l2cap_le_disconnect(local_cid: u16) -> u8;
}
extern "C" {
    pub fn l2cap_cbm_can_send_now(local_cid: u16) -> bool;
}
extern "C" {
    pub fn l2cap_cbm_request_can_send_now_event(local_cid: u16) -> u8;
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_IDLE: battery_service_client_state_t =
        battery_service_client_state_t(0);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_W2_QUERY_SERVICE: battery_service_client_state_t =
        battery_service_client_state_t(1);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_W4_SERVICE_RESULT: battery_service_client_state_t =
        battery_service_client_state_t(2);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_W2_QUERY_CHARACTERISTICS:
        battery_service_client_state_t = battery_service_client_state_t(3);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_W4_CHARACTERISTIC_RESULT:
        battery_service_client_state_t = battery_service_client_state_t(4);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_W2_REGISTER_NOTIFICATION:
        battery_service_client_state_t = battery_service_client_state_t(5);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_W4_NOTIFICATION_REGISTERED:
        battery_service_client_state_t = battery_service_client_state_t(6);
}
impl battery_service_client_state_t {
    pub const BATTERY_SERVICE_CLIENT_STATE_CONNECTED: battery_service_client_state_t =
        battery_service_client_state_t(7);
}
impl ::core::ops::BitOr<battery_service_client_state_t> for battery_service_client_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        battery_service_client_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for battery_service_client_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: battery_service_client_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<battery_service_client_state_t> for battery_service_client_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        battery_service_client_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for battery_service_client_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: battery_service_client_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct battery_service_client_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct battery_service_t {
    pub start_handle: u16,
    pub end_handle: u16,
    pub properties: u16,
    pub value_handle: u16,
    pub notification_listener: gatt_client_notification_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct battery_service_client_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub cid: u16,
    pub state: battery_service_client_state_t,
    pub client_handler: btstack_packet_handler_t,
    pub poll_interval_ms: u32,
    pub num_instances: u8,
    pub services: [battery_service_t; 3usize],
    pub service_index: u8,
    pub poll_bitmap: u8,
    pub need_poll_bitmap: u8,
    pub polled_service_index: u8,
    pub poll_timer: btstack_timer_source_t,
}
extern "C" {
    #[doc = " @brief Initialize Battery Service."]
    pub fn battery_service_client_init();
}
extern "C" {
    #[doc = " @brief Connect to Battery Services of remote device. The client will try to register for notifications.\n If notifications are not supported by remote Battery Service, the client will poll battery level\n If poll_interval_ms is 0, polling is disabled, and only notifications will be received.\n In either case, the battery level is received via GATTSERVICE_SUBEVENT_BATTERY_SERVICE_LEVEL event.\n The battery level is reported as percentage, i.e. 100 = full and it is valid if the ATTT status is equal to ATT_ERROR_SUCCESS,\n see ATT errors (see bluetooth.h) for other values.\n\n For manual polling, see battery_service_client_read_battery_level below.\n\n Event GATTSERVICE_SUBEVENT_BATTERY_SERVICE_CONNECTED is emitted with status ERROR_CODE_SUCCESS on success, otherwise\n GATT_CLIENT_IN_WRONG_STATE, ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no battery service is found, or ATT errors (see bluetooth.h).\n This event event also returns number of battery instances found on remote server, as well as poll bitmap that indicates which indexes\n of services require polling, i.e. they do not support notification on battery level change,\n\n @param con_handle\n @param packet_handler\n @param poll_interval_ms or 0 to disable polling\n @param battery_service_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_COMMAND_DISALLOWED if there is already a client associated with con_handle, or BTSTACK_MEMORY_ALLOC_FAILED"]
    pub fn battery_service_client_connect(
        con_handle: hci_con_handle_t,
        packet_handler: btstack_packet_handler_t,
        poll_interval_ms: u32,
        battery_service_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Read battery level for service with given index. Event GATTSERVICE_SUBEVENT_BATTERY_SERVICE_LEVEL is\n received with battery level (unit is in percentage, i.e. 100 = full). The battery level is valid if the ATTT status\n is equal to ATT_ERROR_SUCCESS, see ATT errors (see bluetooth.h) for other values.\n @param battery_service_cid\n @param service_index\n @return status"]
    pub fn battery_service_client_read_battery_level(
        battery_service_cid: u16,
        service_index: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Disconnect from Battery Service.\n @param battery_service_cid\n @return status"]
    pub fn battery_service_client_disconnect(battery_service_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief De-initialize Battery Service."]
    pub fn battery_service_client_deinit();
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_IDLE: hid_service_client_state_t = hid_service_client_state_t(0);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_QUERY_SERVICE: hid_service_client_state_t =
        hid_service_client_state_t(1);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_SERVICE_RESULT: hid_service_client_state_t =
        hid_service_client_state_t(2);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_QUERY_CHARACTERISTIC: hid_service_client_state_t =
        hid_service_client_state_t(3);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_CHARACTERISTIC_RESULT: hid_service_client_state_t =
        hid_service_client_state_t(4);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_SET_PROTOCOL_MODE_WITHOUT_RESPONSE: hid_service_client_state_t =
        hid_service_client_state_t(5);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_READ_REPORT_MAP_HID_DESCRIPTOR: hid_service_client_state_t =
        hid_service_client_state_t(6);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_REPORT_MAP_HID_DESCRIPTOR: hid_service_client_state_t =
        hid_service_client_state_t(7);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_REPORT_MAP_DISCOVER_CHARACTERISTIC_DESCRIPTORS:
        hid_service_client_state_t = hid_service_client_state_t(8);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_REPORT_MAP_CHARACTERISTIC_DESCRIPTORS_RESULT:
        hid_service_client_state_t = hid_service_client_state_t(9);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_REPORT_MAP_READ_EXTERNAL_REPORT_REFERENCE_UUID:
        hid_service_client_state_t = hid_service_client_state_t(10);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_REPORT_MAP_EXTERNAL_REPORT_REFERENCE_UUID:
        hid_service_client_state_t = hid_service_client_state_t(11);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_DISCOVER_EXTERNAL_REPORT_CHARACTERISTIC:
        hid_service_client_state_t = hid_service_client_state_t(12);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_EXTERNAL_REPORT_CHARACTERISTIC_RESULT:
        hid_service_client_state_t = hid_service_client_state_t(13);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_FIND_REPORT: hid_service_client_state_t =
        hid_service_client_state_t(14);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_REPORT_FOUND: hid_service_client_state_t =
        hid_service_client_state_t(15);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_READ_REPORT_ID_AND_TYPE: hid_service_client_state_t =
        hid_service_client_state_t(16);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_REPORT_ID_AND_TYPE: hid_service_client_state_t =
        hid_service_client_state_t(17);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_ENABLE_INPUT_REPORTS: hid_service_client_state_t =
        hid_service_client_state_t(18);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_INPUT_REPORTS_ENABLED: hid_service_client_state_t =
        hid_service_client_state_t(19);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_CONNECTED: hid_service_client_state_t =
        hid_service_client_state_t(20);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W2_SEND_WRITE_REPORT: hid_service_client_state_t =
        hid_service_client_state_t(21);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W4_WRITE_REPORT_DONE: hid_service_client_state_t =
        hid_service_client_state_t(22);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W2_SEND_GET_REPORT: hid_service_client_state_t =
        hid_service_client_state_t(23);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W4_GET_REPORT_RESULT: hid_service_client_state_t =
        hid_service_client_state_t(24);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W2_READ_VALUE_OF_CHARACTERISTIC: hid_service_client_state_t =
        hid_service_client_state_t(25);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W4_VALUE_OF_CHARACTERISTIC_RESULT: hid_service_client_state_t =
        hid_service_client_state_t(26);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_W2_WRITE_VALUE_OF_CHARACTERISTIC_WITHOUT_RESPONSE:
        hid_service_client_state_t = hid_service_client_state_t(27);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W2_CONFIGURE_NOTIFICATIONS: hid_service_client_state_t =
        hid_service_client_state_t(28);
}
impl hid_service_client_state_t {
    pub const HIDS_CLIENT_STATE_W4_NOTIFICATIONS_CONFIGURED: hid_service_client_state_t =
        hid_service_client_state_t(29);
}
impl ::core::ops::BitOr<hid_service_client_state_t> for hid_service_client_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        hid_service_client_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for hid_service_client_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: hid_service_client_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<hid_service_client_state_t> for hid_service_client_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        hid_service_client_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for hid_service_client_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: hid_service_client_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hid_service_client_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hids_client_report_t {
    pub value_handle: u16,
    pub end_handle: u16,
    pub properties: u16,
    pub external_report_reference_uuid: u16,
    pub service_index: u8,
    pub report_id: u8,
    pub report_type: hid_report_type_t,
    pub boot_report: u8,
    pub notification_listener: gatt_client_notification_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hid_service_t {
    pub protocol_mode: hid_protocol_mode_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub report_map_value_handle: u16,
    pub report_map_end_handle: u16,
    pub hid_information_value_handle: u16,
    pub control_point_value_handle: u16,
    pub protocol_mode_value_handle: u16,
    pub hid_descriptor_offset: u16,
    pub hid_descriptor_len: u16,
    pub hid_descriptor_max_len: u16,
    pub hid_descriptor_status: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hids_client_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub cid: u16,
    pub state: hid_service_client_state_t,
    pub client_handler: btstack_packet_handler_t,
    pub num_instances: u8,
    pub services: [hid_service_t; 3usize],
    pub service_index: u8,
    pub required_protocol_mode: hid_protocol_mode_t,
    pub reports: [hids_client_report_t; 15usize],
    pub num_reports: u8,
    pub external_reports: [hids_client_report_t; 15usize],
    pub num_external_reports: u8,
    pub write_without_response_request: btstack_context_callback_registration_t,
    pub report_index: u8,
    pub report_len: u16,
    pub report: *const u8,
    pub handle: u16,
    pub value: u8,
}
extern "C" {
    #[doc = " @brief Initialize HID Service Client. The HID Descriptor storage is shared between all connections.\n\n @param hid_descriptor_storage\n @param hid_descriptor_storage_len"]
    pub fn hids_client_init(hid_descriptor_storage: *mut u8, hid_descriptor_storage_len: u16);
}
extern "C" {
    pub fn hids_client_connect(
        con_handle: hci_con_handle_t,
        packet_handler: btstack_packet_handler_t,
        protocol_mode: hid_protocol_mode_t,
        hids_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Send HID report.\n\n @param hids_cid\n @param report_id\n @param report_type\n @param report\n @param report_len\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state,\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found, or\n ERROR_CODE_PARAMETER_OUT_OF_MANDATORY_RANGE if report length exceeds MTU."]
    pub fn hids_client_send_write_report(
        hids_cid: u16,
        report_id: u8,
        report_type: hid_report_type_t,
        report: *const u8,
        report_len: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Get HID report. Event GATTSERVICE_SUBEVENT_HID_REPORT is emitted.\n\n @param hids_cid\n @param report_id\n @param report_type\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state,\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found, or\n ERROR_CODE_PARAMETER_OUT_OF_MANDATORY_RANGE if report length exceeds MTU."]
    pub fn hids_client_send_get_report(
        hids_cid: u16,
        report_id: u8,
        report_type: hid_report_type_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Get HID Information. Event GATTSERVICE_SUBEVENT_HID_INFORMATION is emitted.\n\n @param hids_cid\n @param service_index\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state, or\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found."]
    pub fn hids_client_get_hid_information(hids_cid: u16, service_index: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Get Protocol Mode. Event GATTSERVICE_SUBEVENT_HID_PROTOCOL_MODE is emitted.\n\n @param hids_cid\n @param service_index\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state, or\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found."]
    pub fn hids_client_get_protocol_mode(hids_cid: u16, service_index: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Set Protocol Mode.\n\n @param hids_cid\n @param service_index\n @param protocol_mode\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state, or\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found."]
    pub fn hids_client_send_set_protocol_mode(
        hids_cid: u16,
        service_index: u8,
        protocol_mode: hid_protocol_mode_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Send Suspend to remote HID service.\n\n @param hids_cid\n @param service_index\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state, or\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found."]
    pub fn hids_client_send_suspend(hids_cid: u16, service_index: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Send Exit Suspend to remote HID service.\n\n @param hids_cid\n @param service_index\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER,\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state, or\n ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no report with given type and ID is found."]
    pub fn hids_client_send_exit_suspend(hids_cid: u16, service_index: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Enable all notifications. Event GATTSERVICE_SUBEVENT_HID_SERVICE_REPORTS_NOTIFICATION reports current configuration.\n\n @param hids_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER, or\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state."]
    pub fn hids_client_enable_notifications(hids_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Disable all notifications. Event GATTSERVICE_SUBEVENT_HID_SERVICE_REPORTS_NOTIFICATION reports current configuration.\n\n @param hids_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER, or\n ERROR_CODE_COMMAND_DISALLOWED if client is in wrong state."]
    pub fn hids_client_disable_notifications(hids_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Disconnect from HID Service.\n\n @param hids_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER"]
    pub fn hids_client_disconnect(hids_cid: u16) -> u8;
}
extern "C" {
    pub fn hids_client_descriptor_storage_get_descriptor_data(
        hids_cid: u16,
        service_index: u8,
    ) -> *const u8;
}
extern "C" {
    pub fn hids_client_descriptor_storage_get_descriptor_len(
        hids_cid: u16,
        service_index: u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief De-initialize HID Service Client.\n"]
    pub fn hids_client_deinit();
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_IDLE: scan_parameters_service_client_state_t =
        scan_parameters_service_client_state_t(0);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_W2_QUERY_SERVICE:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(1);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_W4_SERVICE_RESULT:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(2);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_W2_QUERY_CHARACTERISTIC:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(3);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_W4_CHARACTERISTIC_RESULT:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(4);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_W2_CONFIGURE_NOTIFICATIONS:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(5);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_W4_NOTIFICATIONS_CONFIGURED:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(6);
}
impl scan_parameters_service_client_state_t {
    pub const SCAN_PARAMETERS_SERVICE_CLIENT_STATE_CONNECTED:
        scan_parameters_service_client_state_t = scan_parameters_service_client_state_t(7);
}
impl ::core::ops::BitOr<scan_parameters_service_client_state_t>
    for scan_parameters_service_client_state_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        scan_parameters_service_client_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for scan_parameters_service_client_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: scan_parameters_service_client_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<scan_parameters_service_client_state_t>
    for scan_parameters_service_client_state_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        scan_parameters_service_client_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for scan_parameters_service_client_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: scan_parameters_service_client_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct scan_parameters_service_client_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scan_parameters_service_client_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub cid: u16,
    pub state: scan_parameters_service_client_state_t,
    pub client_handler: btstack_packet_handler_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub scan_interval_window_value_handle: u16,
    pub scan_refresh_value_handle: u16,
    pub scan_refresh_end_handle: u16,
    pub scan_refresh_properties: u16,
    pub scan_interval_window_value_update: bool,
    pub notification_listener: gatt_client_notification_t,
}
extern "C" {
    #[doc = " @brief Initialize Scan Parameters Service."]
    pub fn scan_parameters_service_client_init();
}
extern "C" {
    #[doc = " @brief Set Scan Parameters Service. It will update all connected devices.\n @param scan_interval\n @param scan_window"]
    pub fn scan_parameters_service_client_set(scan_interval: u16, scan_window: u16);
}
extern "C" {
    #[doc = " @brief Connect to Scan Parameters Service of remote device.\n\n The GATTSERVICE_SUBEVENT_SCAN_PARAMETERS_SERVICE_CONNECTED event completes the request.\n Its status is set to ERROR_CODE_SUCCESS if remote service and SCAN_INTERVAL_WINDOW characteristic are found.\n Other status codes of this event:\n - GATT_CLIENT_IN_WRONG_STATE: client in wrong state\n - ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE: service or characteristic not found\n - ATT errors, see bluetooth.h\n\n @param con_handle\n @param packet_handler\n @param scan_parameters_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if client with con_handle not found"]
    pub fn scan_parameters_service_client_connect(
        con_handle: hci_con_handle_t,
        packet_handler: btstack_packet_handler_t,
        scan_parameters_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Enable notifications\n @param scan_parameters_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if client with con_handle is not found"]
    pub fn scan_parameters_service_client_enable_notifications(scan_parameters_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Disconnect from Scan Parameters Service.\n @param scan_parameters_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if client with con_handle is not found"]
    pub fn scan_parameters_service_client_disconnect(scan_parameters_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief De-initialize Scan Parameters Service."]
    pub fn scan_parameters_service_client_deinit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sm_lookup_entry_t {
    pub item: btstack_linked_item_t,
    pub address: bd_addr_t,
    pub address_type: bd_addr_type_t,
}
extern "C" {
    #[doc = " @brief Initializes the Security Manager, connects to L2CAP"]
    pub fn sm_init();
}
extern "C" {
    #[doc = " @brief Set secret ER key for key generation as described in Core V4.0, Vol 3, Part G, 5.2.2\n @note If not set and btstack_tlv is configured, ER key is generated and stored in TLV by SM\n @param er key"]
    pub fn sm_set_er(er: *mut u8);
}
extern "C" {
    #[doc = " @brief Set secret IR key for key generation as described in Core V4.0, Vol 3, Part G, 5.2.2\n @note If not set and btstack_tlv is configured, IR key is generated and stored in TLV by SM\n @param ir key"]
    pub fn sm_set_ir(ir: *mut u8);
}
extern "C" {
    #[doc = " @brief Registers OOB Data Callback. The callback should set the oob_data and return 1 if OOB data is availble\n @param get_oob_data_callback"]
    pub fn sm_register_oob_data_callback(
        get_oob_data_callback: ::core::option::Option<
            unsafe extern "C" fn(address_type: u8, addr: *mut u8, oob_data: *mut u8) -> cty::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @brief Add event packet handler.\n @param callback_handler"]
    pub fn sm_add_event_handler(callback_handler: *mut btstack_packet_callback_registration_t);
}
extern "C" {
    #[doc = " @brief Remove event packet handler.\n @param callback_handler"]
    pub fn sm_remove_event_handler(callback_handler: *mut btstack_packet_callback_registration_t);
}
extern "C" {
    #[doc = " @brief Limit the STK generation methods. Bonding is stopped if the resulting one isn't in the list\n @param OR combination of SM_STK_GENERATION_METHOD_"]
    pub fn sm_set_accepted_stk_generation_methods(accepted_stk_generation_methods: u8);
}
extern "C" {
    #[doc = " @brief Set the accepted encryption key size range. Bonding is stopped if the result isn't within the range\n @param min_size (default 7)\n @param max_size (default 16)"]
    pub fn sm_set_encryption_key_size_range(min_size: u8, max_size: u8);
}
extern "C" {
    #[doc = " @brief Sets the requested authentication requirements, bonding yes/no, MITM yes/no, SC yes/no, keypress yes/no\n @param OR combination of SM_AUTHREQ_ flags"]
    pub fn sm_set_authentication_requirements(auth_req: u8);
}
extern "C" {
    #[doc = " @brief Sets the available IO Capabilities\n @param IO_CAPABILITY_"]
    pub fn sm_set_io_capabilities(io_capability: io_capability_t);
}
extern "C" {
    #[doc = " @brief Enable/disable Secure Connections Mode only\n @param enable secure connections only mode"]
    pub fn sm_set_secure_connections_only_mode(enable: bool);
}
extern "C" {
    #[doc = " @brief Let Peripheral request an encrypted connection right after connecting\n @note Not used normally. Bonding is triggered by access to protected attributes in ATT Server"]
    pub fn sm_set_request_security(enable: cty::c_int);
}
extern "C" {
    #[doc = " @brief Trigger Security Request\n @deprecated please use sm_request_pairing instead"]
    pub fn sm_send_security_request(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Decline bonding triggered by event before\n @param con_handle"]
    pub fn sm_bonding_decline(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Confirm Just Works bonding\n @param con_handle"]
    pub fn sm_just_works_confirm(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Confirm value from SM_EVENT_NUMERIC_COMPARISON_REQUEST for Numeric Comparison bonding\n @param con_handle"]
    pub fn sm_numeric_comparison_confirm(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Reports passkey input by user\n @param con_handle\n @param passkey in [0..999999]"]
    pub fn sm_passkey_input(con_handle: hci_con_handle_t, passkey: u32);
}
extern "C" {
    #[doc = " @brief Send keypress notification for keyboard only devices\n @param con_handle\n @param action see SM_KEYPRESS_* in bluetooth.h"]
    pub fn sm_keypress_notification(con_handle: hci_con_handle_t, action: u8);
}
extern "C" {
    #[doc = " @brief Used by att_server.c and gatt_client.c to request user authentication\n @param con_handle"]
    pub fn sm_request_pairing(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Report user authorization decline.\n @param con_handle"]
    pub fn sm_authorization_decline(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Report user authorization grant.\n @param con_handle"]
    pub fn sm_authorization_grant(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Support for signed writes, used by att_server.\n @return ready"]
    pub fn sm_cmac_ready() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Support for signed writes, used by att_server.\n @note Message is in little endian to allows passing in ATT PDU without flipping.\n @note signing data: [opcode, attribute_handle, message, sign_counter]\n @note calculated hash in done_callback is big endian and has 16 byte.\n @param key\n @param opcde\n @param attribute_handle\n @param message_len\n @param message\n @param sign_counter"]
    pub fn sm_cmac_signed_write_start(
        key: *mut u8,
        opcode: u8,
        attribute_handle: u16,
        message_len: u16,
        message: *const u8,
        sign_counter: u32,
        done_callback: ::core::option::Option<unsafe extern "C" fn(hash: *mut u8)>,
    );
}
extern "C" {
    #[doc = " @brief Match address against bonded devices\n @param address_type\n @param address\n @return 0 if successfully added to lookup queue\n @note Triggers SM_IDENTITY_RESOLVING_* events"]
    pub fn sm_address_resolution_lookup(address_type: u8, address: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get Identity Resolving state\n @param con_handle\n @return irk_lookup_state_t\n @note return IRK_LOOKUP_IDLE if connection does not exist"]
    pub fn sm_identity_resolving_state(con_handle: hci_con_handle_t) -> irk_lookup_state_t;
}
extern "C" {
    #[doc = " @brief Identify device in LE Device DB.\n @param con_handle\n @return index from le_device_db or -1 if not found/identified"]
    pub fn sm_le_device_index(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Use fixec passkey for Legacy and SC instead of generating a random number\n @note Can be used to improve security over Just Works if no keyboard or displary are present and\n       individual random passkey can be printed on the device during production\n @param passkey"]
    pub fn sm_use_fixed_passkey_in_display_role(passkey: u32);
}
extern "C" {
    #[doc = " @brief Allow connection re-encryption in Peripheral (Responder) role for LE Legacy Pairing\n       without entry for Central device stored in LE Device DB\n @note BTstack in Peripheral Role (Responder) supports LE Legacy Pairing without a persistent LE Device DB as\n       the LTK is reconstructed from a local secret IRK and EDIV + Random stored on Central (Initiator) device\n       On the downside, it's not really possible to delete a pairing if this is enabled.\n @param allow encryption using reconstructed LTK without stored entry (Default: 1)"]
    pub fn sm_allow_ltk_reconstruction_without_le_device_db_entry(allow: cty::c_int);
}
extern "C" {
    #[doc = " @brief Generate OOB data for LE Secure Connections\n @note This generates a 128 bit random number ra and then calculates Ca = f4(PKa, PKa, ra, 0)\n       New OOB data should be generated for each pairing. Ra is used for subsequent OOB pairings\n @param callback\n @return status"]
    pub fn sm_generate_sc_oob_data(
        callback: ::core::option::Option<
            unsafe extern "C" fn(confirm_value: *const u8, random_value: *const u8),
        >,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Registers OOB Data Callback for LE Secure Conections. The callback should set all arguments and return 1 if OOB data is availble\n @note the oob_sc_local_random usually is the random_value returend by sm_generate_sc_oob_data\n @param get_oob_data_callback"]
    pub fn sm_register_sc_oob_data_callback(
        get_sc_oob_data_callback: ::core::option::Option<
            unsafe extern "C" fn(
                address_type: u8,
                addr: *mut u8,
                oob_sc_peer_confirm: *mut u8,
                oob_sc_peer_random: *mut u8,
            ) -> cty::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @bbrief Register LTK Callback that allows to provide a custom LTK on re-encryption. The callback returns true if LTK was modified\n @param get_ltk_callback"]
    pub fn sm_register_ltk_callback(
        get_ltk_callback: ::core::option::Option<
            unsafe extern "C" fn(
                con_handle: hci_con_handle_t,
                address_type: u8,
                addr: *mut u8,
                ltk: *mut u8,
            ) -> bool,
        >,
    );
}
extern "C" {
    #[doc = " @brief De-Init SM"]
    pub fn sm_deinit();
}
extern "C" {
    pub fn sm_test_set_irk(irk: *mut u8);
}
extern "C" {
    pub fn sm_test_use_fixed_local_csrk();
}
extern "C" {
    #[doc = " @brief Initializes BTstack memory pools."]
    pub fn btstack_memory_init();
}
extern "C" {
    #[doc = " @brief Deinitialize BTstack memory pools\n @note if HAVE_MALLOC is defined, all previously allocated buffers are free'd"]
    pub fn btstack_memory_deinit();
}
extern "C" {
    pub fn btstack_memory_hci_connection_get() -> *mut hci_connection_t;
}
extern "C" {
    pub fn btstack_memory_hci_connection_free(hci_connection: *mut hci_connection_t);
}
extern "C" {
    pub fn btstack_memory_l2cap_service_get() -> *mut l2cap_service_t;
}
extern "C" {
    pub fn btstack_memory_l2cap_service_free(l2cap_service: *mut l2cap_service_t);
}
extern "C" {
    pub fn btstack_memory_l2cap_channel_get() -> *mut l2cap_channel_t;
}
extern "C" {
    pub fn btstack_memory_l2cap_channel_free(l2cap_channel: *mut l2cap_channel_t);
}
extern "C" {
    pub fn btstack_memory_battery_service_client_get() -> *mut battery_service_client_t;
}
extern "C" {
    pub fn btstack_memory_battery_service_client_free(
        battery_service_client: *mut battery_service_client_t,
    );
}
extern "C" {
    pub fn btstack_memory_gatt_client_get() -> *mut gatt_client_t;
}
extern "C" {
    pub fn btstack_memory_gatt_client_free(gatt_client: *mut gatt_client_t);
}
extern "C" {
    pub fn btstack_memory_hids_client_get() -> *mut hids_client_t;
}
extern "C" {
    pub fn btstack_memory_hids_client_free(hids_client: *mut hids_client_t);
}
extern "C" {
    pub fn btstack_memory_scan_parameters_service_client_get(
    ) -> *mut scan_parameters_service_client_t;
}
extern "C" {
    pub fn btstack_memory_scan_parameters_service_client_free(
        scan_parameters_service_client: *mut scan_parameters_service_client_t,
    );
}
extern "C" {
    pub fn btstack_memory_sm_lookup_entry_get() -> *mut sm_lookup_entry_t;
}
extern "C" {
    pub fn btstack_memory_sm_lookup_entry_free(sm_lookup_entry: *mut sm_lookup_entry_t);
}
extern "C" {
    pub fn btstack_memory_whitelist_entry_get() -> *mut whitelist_entry_t;
}
extern "C" {
    pub fn btstack_memory_whitelist_entry_free(whitelist_entry: *mut whitelist_entry_t);
}
extern "C" {
    pub fn btstack_memory_periodic_advertiser_list_entry_get(
    ) -> *mut periodic_advertiser_list_entry_t;
}
extern "C" {
    pub fn btstack_memory_periodic_advertiser_list_entry_free(
        periodic_advertiser_list_entry: *mut periodic_advertiser_list_entry_t,
    );
}
pub type btstack_memory_pool_t = *mut cty::c_void;
extern "C" {
    pub fn btstack_memory_pool_create(
        pool: *mut btstack_memory_pool_t,
        storage: *mut cty::c_void,
        count: cty::c_int,
        block_size: cty::c_int,
    );
}
extern "C" {
    pub fn btstack_memory_pool_get(pool: *mut btstack_memory_pool_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn btstack_memory_pool_free(pool: *mut btstack_memory_pool_t, block: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Initialize network interface\n @param send_packet_callback"]
    pub fn btstack_network_init(
        send_packet_callback: ::core::option::Option<
            unsafe extern "C" fn(packet: *const u8, size: u16),
        >,
    );
}
extern "C" {
    #[doc = " @brief Bring up network interfacd\n @param network_address\n @return 0 if ok"]
    pub fn btstack_network_up(network_address: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Shut down network interfacd\n @param network_address\n @return 0 if ok"]
    pub fn btstack_network_down() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Receive packet on network interface, e.g., forward packet to TCP/IP stack\n @param packet\n @param size"]
    pub fn btstack_network_process_packet(packet: *const u8, size: u16);
}
extern "C" {
    #[doc = " @brief Notify network interface that packet from send_packet_callback was sent and the next packet can be delivered."]
    pub fn btstack_network_packet_sent();
}
extern "C" {
    #[doc = " @brief Get network name after network was activated\n @note e.g. tapX on Linux, might not be useful on all platforms\n @return network name"]
    pub fn btstack_network_get_name() -> *const cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btstack_ring_buffer {
    pub storage: *mut u8,
    pub size: u32,
    pub last_read_index: u32,
    pub last_written_index: u32,
    pub full: u8,
}
pub type btstack_ring_buffer_t = btstack_ring_buffer;
extern "C" {
    #[doc = " Init ring buffer\n @param ring_buffer object\n @param storage\n @param storage_size in bytes"]
    pub fn btstack_ring_buffer_init(
        ring_buffer: *mut btstack_ring_buffer_t,
        storage: *mut u8,
        storage_size: u32,
    );
}
extern "C" {
    #[doc = " Reset ring buffer to initial state (empty)\n @param ring_buffer object"]
    pub fn btstack_ring_buffer_reset(ring_buffer: *mut btstack_ring_buffer_t);
}
extern "C" {
    #[doc = " Check if ring buffer is empty\n @param ring_buffer object\n @return TRUE if empty"]
    pub fn btstack_ring_buffer_empty(ring_buffer: *mut btstack_ring_buffer_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Get number of bytes available for read\n @param ring_buffer object\n @return number of bytes available for read"]
    pub fn btstack_ring_buffer_bytes_available(ring_buffer: *mut btstack_ring_buffer_t) -> u32;
}
extern "C" {
    #[doc = " Get free space available for write\n @param ring_buffer object\n @return number of bytes available for write"]
    pub fn btstack_ring_buffer_bytes_free(ring_buffer: *mut btstack_ring_buffer_t) -> u32;
}
extern "C" {
    #[doc = " Write bytes into ring buffer\n @param ring_buffer object\n @param data to store\n @param data_length\n @return 0 if ok, ERROR_CODE_MEMORY_CAPACITY_EXCEEDED if not enough space in buffer"]
    pub fn btstack_ring_buffer_write(
        ring_buffer: *mut btstack_ring_buffer_t,
        data: *mut u8,
        data_length: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Read from ring buffer\n @param ring_buffer object\n @param buffer to store read data\n @param length to read\n @param number_of_bytes_read"]
    pub fn btstack_ring_buffer_read(
        ring_buffer: *mut btstack_ring_buffer_t,
        buffer: *mut u8,
        length: u32,
        number_of_bytes_read: *mut u32,
    );
}
extern "C" {
    pub fn btstack_stdin_setup(
        stdin_handler: ::core::option::Option<unsafe extern "C" fn(c: cty::c_char)>,
    );
}
extern "C" {
    pub fn btstack_stdin_reset();
}
extern "C" {
    #[doc = " @brief Init ATT DB storage"]
    pub fn att_db_util_init();
}
extern "C" {
    #[doc = " @brief Add primary service for 16-bit UUID\n @param uuid16\n @return attribute handle for the new service definition"]
    pub fn att_db_util_add_service_uuid16(uuid16: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Add primary service for 128-bit UUID\n @param uuid128\n @return attribute handle for the new service definition"]
    pub fn att_db_util_add_service_uuid128(uuid128: *const u8) -> u16;
}
extern "C" {
    #[doc = " @brief Add secondary service for 16-bit UUID\n @param uuid16\n @return attribute handle for the new service definition"]
    pub fn att_db_util_add_secondary_service_uuid16(uuid16: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Add secondary service for 128-bit UUID\n @param uuid128\n @return attribute handle for the new service definition"]
    pub fn att_db_util_add_secondary_service_uuid128(uuid128: *const u8) -> u16;
}
extern "C" {
    #[doc = " @brief Add included service with 16-bit UUID\n @param start_group_handle\n @param end_group_handle\n @param uuid16\n @return attribute handle for the new service definition"]
    pub fn att_db_util_add_included_service_uuid16(
        start_group_handle: u16,
        end_group_handle: u16,
        uuid16: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Add Characteristic with 16-bit UUID, properties, and data\n @param uuid16\n @param properties        - see ATT_PROPERTY_* in src/bluetooth.h\n @param read_permissions  - see ATT_SECURITY_* in src/bluetooth.h\n @param write_permissions - see ATT_SECURITY_* in src/bluetooth.h\n @param data returned in read operations if ATT_PROPERTY_DYNAMIC is not specified\n @param data_len\n @return attribute handle of the new characteristic value declaration\n @note If properties contains ATT_PROPERTY_NOTIFY or ATT_PROPERTY_INDICATE flags, a Client Configuration Characteristic Descriptor (CCCD)\n       is created as well. The attribute value handle of the CCCD is the attribute value handle plus 1"]
    pub fn att_db_util_add_characteristic_uuid16(
        uuid16: u16,
        properties: u16,
        read_permission: u8,
        write_permission: u8,
        data: *mut u8,
        data_len: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Add Characteristic with 128-bit UUID, properties, and data\n @param uuid128\n @param properties        - see ATT_PROPERTY_* in src/bluetooth.h\n @param read_permissions  - see ATT_SECURITY_* in src/bluetooth.h\n @param write_permissions - see ATT_SECURITY_* in src/bluetooth.h\n @param data returned in read operations if ATT_PROPERTY_DYNAMIC is not specified\n @param data_len\n @return attribute handle of the new characteristic value declaration\n @note If properties contains ATT_PROPERTY_NOTIFY or ATT_PROPERTY_INDICATE flags, a Client Configuration Characteristic Descriptor (CCCD)\n       is created as well. The attribute value handle of the CCCD is the attribute value handle plus 1"]
    pub fn att_db_util_add_characteristic_uuid128(
        uuid128: *const u8,
        properties: u16,
        read_permission: u8,
        write_permission: u8,
        data: *mut u8,
        data_len: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Add descriptor with 16-bit UUID, properties, and data\n @param uuid16\n @param properties        - see ATT_PROPERTY_* in src/bluetooth.h\n @param read_permissions  - see ATT_SECURITY_* in src/bluetooth.h\n @param write_permissions - see ATT_SECURITY_* in src/bluetooth.h\n @param data returned in read operations if ATT_PROPERTY_DYNAMIC is not specified\n @param data_len\n @return attribute handle of the new characteristic descriptor declaration"]
    pub fn att_db_util_add_descriptor_uuid16(
        uuid16: u16,
        properties: u16,
        read_permission: u8,
        write_permission: u8,
        data: *mut u8,
        data_len: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Add descriptor with 128-bit UUID, properties, and data\n @param uuid128\n @param properties        - see ATT_PROPERTY_* in src/bluetooth.h\n @param read_permissions  - see ATT_SECURITY_* in src/bluetooth.h\n @param write_permissions - see ATT_SECURITY_* in src/bluetooth.h\n @param data returned in read operations if ATT_PROPERTY_DYNAMIC is not specified\n @param data_len\n @return attribute handle of the new characteristic descriptor declaration"]
    pub fn att_db_util_add_descriptor_uuid128(
        uuid128: *const u8,
        properties: u16,
        read_permission: u8,
        write_permission: u8,
        data: *mut u8,
        data_len: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Get address of constructed ATT DB"]
    pub fn att_db_util_get_address() -> *mut u8;
}
extern "C" {
    #[doc = " @brief Get size of constructed ATT DB"]
    pub fn att_db_util_get_size() -> u16;
}
extern "C" {
    #[doc = " @brief Get number of bytes that are included in GATT Database Hash"]
    pub fn att_db_util_hash_len() -> u16;
}
extern "C" {
    #[doc = " @brief init generator for GATT Database Hash"]
    pub fn att_db_util_hash_init();
}
extern "C" {
    #[doc = " @brief get next byte from generator for GATT Database Hash"]
    pub fn att_db_util_hash_get_next() -> u8;
}
extern "C" {
    #[doc = " @brief Calculate GATT Database Hash using crypto engine\n @param request\n @param db_hash\n @param callback\n @param callback_arg"]
    pub fn att_db_util_hash_calc(
        request: *mut btstack_crypto_aes128_cmac_t,
        db_hash: *mut u8,
        callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>,
        callback_arg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief reset att dispatchter\n @param packet_hander for ATT client packets"]
    pub fn att_dispatch_register_client(packet_handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief reset att dispatchter\n @param packet_hander for ATT server packets"]
    pub fn att_dispatch_register_server(packet_handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief can send packet for client\n @param con_handle"]
    pub fn att_dispatch_client_can_send_now(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief can send packet for server\n @param con_handle"]
    pub fn att_dispatch_server_can_send_now(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Request emission of L2CAP_EVENT_CAN_SEND_NOW as soon as possible for client\n @note L2CAP_EVENT_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it\n @param con_handle"]
    pub fn att_dispatch_client_request_can_send_now_event(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Request emission of L2CAP_EVENT_CAN_SEND_NOW as soon as possible for server\n @note L2CAP_EVENT_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it\n @param con_handle"]
    pub fn att_dispatch_server_request_can_send_now_event(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Used for propogating a updated MTU from att_server to gatt_client\n @param con_handle\n @param mtu"]
    pub fn att_dispatch_server_mtu_exchanged(con_handle: hci_con_handle_t, new_mtu: u16);
}
extern "C" {
    #[doc = " @brief Used for propogating a updated MTU from gatt_client to att_server\n @param con_handle\n @param mtu"]
    pub fn att_dispatch_client_mtu_exchanged(con_handle: hci_con_handle_t, new_mtu: u16);
}
extern "C" {
    pub fn att_server_init(
        db: *const u8,
        read_callback: att_read_callback_t,
        write_callback: att_write_callback_t,
    );
}
extern "C" {
    pub fn att_server_register_packet_handler(handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief register read/write callbacks for specific handle range\n @param att_service_handler_t"]
    pub fn att_server_register_service_handler(handler: *mut att_service_handler_t);
}
extern "C" {
    #[doc = " @brief Request callback when sending is possible\n @note callback might happend during call to this function\n @param callback_registration to point to callback function and context information\n @param con_handle\n @return 0 if ok, error otherwise"]
    pub fn att_server_register_can_send_now_callback(
        callback_registration: *mut btstack_context_callback_registration_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Return ATT MTU\n @param con_handle\n @return mtu if ok, 0 otherwise"]
    pub fn att_server_get_mtu(con_handle: hci_con_handle_t) -> u16;
}
extern "C" {
    #[doc = " @brief Request callback when sending notifcation is possible\n @note callback might happend during call to this function\n @param callback_registration to point to callback function and context information\n @param con_handle\n @return ERROR_CODE_SUCCESS if ok, ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if handle unknown, and ERROR_CODE_COMMAND_DISALLOWED if callback already registered"]
    pub fn att_server_request_to_send_notification(
        callback_registration: *mut btstack_context_callback_registration_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Request callback when sending indication is possible\n @note callback might happend during call to this function\n @param callback_registration to point to callback function and context information\n @param con_handle\n @return ERROR_CODE_SUCCESS if ok, ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if handle unknown, and ERROR_CODE_COMMAND_DISALLOWED if callback already registered"]
    pub fn att_server_request_to_send_indication(
        callback_registration: *mut btstack_context_callback_registration_t,
        con_handle: hci_con_handle_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief notify client about attribute value change\n @param con_handle\n @param attribute_handle\n @param value\n @param value_len\n @return 0 if ok, error otherwise"]
    pub fn att_server_notify(
        con_handle: hci_con_handle_t,
        attribute_handle: u16,
        value: *const u8,
        value_len: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief indicate value change to client. client is supposed to reply with an indication_response\n @param con_handle\n @param attribute_handle\n @param value\n @param value_len\n @return 0 if ok, error otherwise"]
    pub fn att_server_indicate(
        con_handle: hci_con_handle_t,
        attribute_handle: u16,
        value: *const u8,
        value_len: u16,
    ) -> u8;
}
extern "C" {
    #[doc = " De-Init ATT Server"]
    pub fn att_server_deinit();
}
extern "C" {
    #[doc = " @brief tests if a notification or indication can be send right now\n @param con_handle\n @return 1, if packet can be sent"]
    pub fn att_server_can_send_packet_now(con_handle: hci_con_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Request emission of ATT_EVENT_CAN_SEND_NOW as soon as possible\n @note ATT_EVENT_CAN_SEND_NOW might be emitted during call to this function\n       so packet handler should be ready to handle it\n @param con_handle"]
    pub fn att_server_request_can_send_now_event(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @text The ANCS Client implements Notification Consumer (NC) of the [Apple Notification Center Service\n (ANCS)](developer.apple.com/library/archive/documentation/CoreBluetooth/Reference/AppleNotificationCenterServiceSpecification/Introduction/Introduction.html)."]
    pub fn ancs_client_init();
}
extern "C" {
    pub fn ancs_client_register_callback(callback: btstack_packet_handler_t);
}
extern "C" {
    pub fn ancs_client_attribute_name_for_id(id: cty::c_int) -> *const cty::c_char;
}
extern "C" {
    #[doc = " @brief Init Battery Service Server with ATT DB\n @param battery_value in range 0-100"]
    pub fn battery_service_server_init(battery_value: u8);
}
extern "C" {
    #[doc = " @brief Update battery value\n @note triggers notifications if subscribed\n @param battery_value in range 0-100"]
    pub fn battery_service_server_set_battery_value(battery_value: u8);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ACTIVE_BOND_CLASSIC_AND_LE: bond_management_cmd_t =
        bond_management_cmd_t(1);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ACTIVE_BOND_CLASSIC: bond_management_cmd_t =
        bond_management_cmd_t(2);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ACTIVE_BOND_LE: bond_management_cmd_t =
        bond_management_cmd_t(3);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ALL_BONDS_CLASSIC_AND_LE: bond_management_cmd_t =
        bond_management_cmd_t(4);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ALL_BONDS_CLASSIC: bond_management_cmd_t =
        bond_management_cmd_t(5);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ALL_BONDS_LE: bond_management_cmd_t =
        bond_management_cmd_t(6);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ALL_BUT_ACTIVE_BOND_CLASSIC_AND_LE: bond_management_cmd_t =
        bond_management_cmd_t(7);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ALL_BUT_ACTIVE_BOND_CLASSIC: bond_management_cmd_t =
        bond_management_cmd_t(8);
}
impl bond_management_cmd_t {
    pub const BOND_MANAGEMENT_CMD_DELETE_ALL_BUT_ACTIVE_BOND_LE: bond_management_cmd_t =
        bond_management_cmd_t(9);
}
impl ::core::ops::BitOr<bond_management_cmd_t> for bond_management_cmd_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        bond_management_cmd_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for bond_management_cmd_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: bond_management_cmd_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<bond_management_cmd_t> for bond_management_cmd_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        bond_management_cmd_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for bond_management_cmd_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: bond_management_cmd_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct bond_management_cmd_t(pub cty::c_uint);
extern "C" {
    #[doc = " @brief Init Bond Management Service with ATT DB\n @param supported_features"]
    pub fn bond_management_service_server_init(supported_features: u32);
}
extern "C" {
    #[doc = " @brief Set authorisation string\n @note String is not copied\n @param authorisation_string"]
    pub fn bond_management_service_server_set_authorisation_string(
        authorisation_string: *const cty::c_char,
    );
}
impl cycling_power_pedal_power_balance_reference_t {
    pub const CP_PEDAL_POWER_BALANCE_REFERENCE_UNKNOWN:
        cycling_power_pedal_power_balance_reference_t =
        cycling_power_pedal_power_balance_reference_t(0);
}
impl cycling_power_pedal_power_balance_reference_t {
    pub const CP_PEDAL_POWER_BALANCE_REFERENCE_LEFT: cycling_power_pedal_power_balance_reference_t =
        cycling_power_pedal_power_balance_reference_t(1);
}
impl cycling_power_pedal_power_balance_reference_t {
    pub const CP_PEDAL_POWER_BALANCE_REFERENCE_NOT_SUPPORTED:
        cycling_power_pedal_power_balance_reference_t =
        cycling_power_pedal_power_balance_reference_t(2);
}
impl ::core::ops::BitOr<cycling_power_pedal_power_balance_reference_t>
    for cycling_power_pedal_power_balance_reference_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_pedal_power_balance_reference_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_pedal_power_balance_reference_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_pedal_power_balance_reference_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_pedal_power_balance_reference_t>
    for cycling_power_pedal_power_balance_reference_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_pedal_power_balance_reference_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_pedal_power_balance_reference_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_pedal_power_balance_reference_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_pedal_power_balance_reference_t(pub cty::c_uint);
impl cycling_power_torque_source_t {
    pub const CP_TORQUE_SOURCE_WHEEL: cycling_power_torque_source_t =
        cycling_power_torque_source_t(0);
}
impl cycling_power_torque_source_t {
    pub const CP_TORQUE_SOURCE_CRANK: cycling_power_torque_source_t =
        cycling_power_torque_source_t(1);
}
impl cycling_power_torque_source_t {
    pub const CP_TORQUE_SOURCE_NOT_SUPPORTED: cycling_power_torque_source_t =
        cycling_power_torque_source_t(2);
}
impl ::core::ops::BitOr<cycling_power_torque_source_t> for cycling_power_torque_source_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_torque_source_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_torque_source_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_torque_source_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_torque_source_t> for cycling_power_torque_source_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_torque_source_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_torque_source_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_torque_source_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_torque_source_t(pub cty::c_uint);
impl cycling_power_sensor_measurement_context_t {
    pub const CP_SENSOR_MEASUREMENT_CONTEXT_FORCE: cycling_power_sensor_measurement_context_t =
        cycling_power_sensor_measurement_context_t(0);
}
impl cycling_power_sensor_measurement_context_t {
    pub const CP_SENSOR_MEASUREMENT_CONTEXT_TORQUE: cycling_power_sensor_measurement_context_t =
        cycling_power_sensor_measurement_context_t(1);
}
impl ::core::ops::BitOr<cycling_power_sensor_measurement_context_t>
    for cycling_power_sensor_measurement_context_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_sensor_measurement_context_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_sensor_measurement_context_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_sensor_measurement_context_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_sensor_measurement_context_t>
    for cycling_power_sensor_measurement_context_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_sensor_measurement_context_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_sensor_measurement_context_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_sensor_measurement_context_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_sensor_measurement_context_t(pub cty::c_uint);
impl cycling_power_distributed_system_t {
    pub const CP_DISTRIBUTED_SYSTEM_UNSPECIFIED: cycling_power_distributed_system_t =
        cycling_power_distributed_system_t(0);
}
impl cycling_power_distributed_system_t {
    pub const CP_DISTRIBUTED_SYSTEM_NOT_SUPPORTED: cycling_power_distributed_system_t =
        cycling_power_distributed_system_t(1);
}
impl cycling_power_distributed_system_t {
    pub const CP_DISTRIBUTED_SYSTEM_SUPPORTED: cycling_power_distributed_system_t =
        cycling_power_distributed_system_t(2);
}
impl ::core::ops::BitOr<cycling_power_distributed_system_t> for cycling_power_distributed_system_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_distributed_system_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_distributed_system_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_distributed_system_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_distributed_system_t>
    for cycling_power_distributed_system_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_distributed_system_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_distributed_system_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_distributed_system_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_distributed_system_t(pub cty::c_uint);
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_PEDAL_POWER_BALANCE_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(0);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_PEDAL_POWER_BALANCE_REFERENCE: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(1);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_ACCUMULATED_TORQUE_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(2);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_ACCUMULATED_TORQUE_SOURCE: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(3);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_WHEEL_REVOLUTION_DATA_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(4);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_CRANK_REVOLUTION_DATA_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(5);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_EXTREME_FORCE_MAGNITUDES_PRESENT:
        cycling_power_measurement_flag_t = cycling_power_measurement_flag_t(6);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_EXTREME_TORQUE_MAGNITUDES_PRESENT:
        cycling_power_measurement_flag_t = cycling_power_measurement_flag_t(7);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_EXTREME_ANGLES_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(8);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_TOP_DEAD_SPOT_ANGLE_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(9);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_BOTTOM_DEAD_SPOT_ANGLE_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(10);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_ACCUMULATED_ENERGY_PRESENT: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(11);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_OFFSET_COMPENSATION_INDICATOR: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(12);
}
impl cycling_power_measurement_flag_t {
    pub const CP_MEASUREMENT_FLAG_RESERVED: cycling_power_measurement_flag_t =
        cycling_power_measurement_flag_t(13);
}
impl ::core::ops::BitOr<cycling_power_measurement_flag_t> for cycling_power_measurement_flag_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_measurement_flag_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_measurement_flag_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_measurement_flag_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_measurement_flag_t> for cycling_power_measurement_flag_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_measurement_flag_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_measurement_flag_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_measurement_flag_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_measurement_flag_t(pub cty::c_uint);
impl cycling_power_instantaneous_measurement_direction_t {
    pub const CP_INSTANTANEOUS_MEASUREMENT_DIRECTION_UNKNOWN:
        cycling_power_instantaneous_measurement_direction_t =
        cycling_power_instantaneous_measurement_direction_t(0);
}
impl cycling_power_instantaneous_measurement_direction_t {
    pub const CP_INSTANTANEOUS_MEASUREMENT_DIRECTION_TANGENTIAL_COMPONENT:
        cycling_power_instantaneous_measurement_direction_t =
        cycling_power_instantaneous_measurement_direction_t(1);
}
impl cycling_power_instantaneous_measurement_direction_t {
    pub const CP_INSTANTANEOUS_MEASUREMENT_DIRECTION_RADIAL_COMPONENT:
        cycling_power_instantaneous_measurement_direction_t =
        cycling_power_instantaneous_measurement_direction_t(2);
}
impl cycling_power_instantaneous_measurement_direction_t {
    pub const CP_INSTANTANEOUS_MEASUREMENT_DIRECTION_LATERAL_COMPONENT:
        cycling_power_instantaneous_measurement_direction_t =
        cycling_power_instantaneous_measurement_direction_t(3);
}
impl ::core::ops::BitOr<cycling_power_instantaneous_measurement_direction_t>
    for cycling_power_instantaneous_measurement_direction_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_instantaneous_measurement_direction_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_instantaneous_measurement_direction_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_instantaneous_measurement_direction_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_instantaneous_measurement_direction_t>
    for cycling_power_instantaneous_measurement_direction_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_instantaneous_measurement_direction_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_instantaneous_measurement_direction_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_instantaneous_measurement_direction_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_instantaneous_measurement_direction_t(pub cty::c_uint);
impl cycling_power_vector_flag_t {
    pub const CP_VECTOR_FLAG_CRANK_REVOLUTION_DATA_PRESENT: cycling_power_vector_flag_t =
        cycling_power_vector_flag_t(0);
}
impl cycling_power_vector_flag_t {
    pub const CP_VECTOR_FLAG_FIRST_CRANK_MEASUREMENT_ANGLE_PRESENT: cycling_power_vector_flag_t =
        cycling_power_vector_flag_t(1);
}
impl cycling_power_vector_flag_t {
    pub const CP_VECTOR_FLAG_INSTANTANEOUS_FORCE_MAGNITUDE_ARRAY_PRESENT:
        cycling_power_vector_flag_t = cycling_power_vector_flag_t(2);
}
impl cycling_power_vector_flag_t {
    pub const CP_VECTOR_FLAG_INSTANTANEOUS_TORQUE_MAGNITUDE_ARRAY_PRESENT:
        cycling_power_vector_flag_t = cycling_power_vector_flag_t(3);
}
impl cycling_power_vector_flag_t {
    pub const CP_VECTOR_FLAG_INSTANTANEOUS_MEASUREMENT_DIRECTION: cycling_power_vector_flag_t =
        cycling_power_vector_flag_t(4);
}
impl cycling_power_vector_flag_t {
    pub const CP_VECTOR_FLAG_RESERVED: cycling_power_vector_flag_t = cycling_power_vector_flag_t(6);
}
impl ::core::ops::BitOr<cycling_power_vector_flag_t> for cycling_power_vector_flag_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_vector_flag_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_vector_flag_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_vector_flag_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_vector_flag_t> for cycling_power_vector_flag_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_vector_flag_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_vector_flag_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_vector_flag_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_vector_flag_t(pub cty::c_uint);
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_OTHER: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(0);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_TOP_OF_SHOE: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(1);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_IN_SHOE: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(2);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_HIP: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(3);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_FRONT_WHEEL: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(4);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_LEFT_CRANK: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(5);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_RIGHT_CRANK: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(6);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_LEFT_PEDAL: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(7);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_RIGHT_PEDAL: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(8);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_FRONT_HUB: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(9);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_REAR_DROPOUT: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(10);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_CHAINSTAY: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(11);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_REAR_WHEEL: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(12);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_REAR_HUB: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(13);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_CHEST: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(14);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_SPIDER: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(15);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_CHAIN_RING: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(16);
}
impl cycling_power_sensor_location_t {
    pub const CP_SENSOR_LOCATION_RESERVED: cycling_power_sensor_location_t =
        cycling_power_sensor_location_t(17);
}
impl ::core::ops::BitOr<cycling_power_sensor_location_t> for cycling_power_sensor_location_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_sensor_location_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_sensor_location_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_sensor_location_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_sensor_location_t> for cycling_power_sensor_location_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_sensor_location_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_sensor_location_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_sensor_location_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_sensor_location_t(pub cty::c_uint);
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_PEDAL_POWER_BALANCE_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(0);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_ACCUMULATED_TORQUE_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(1);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_WHEEL_REVOLUTION_DATA_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(2);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_CRANK_REVOLUTION_DATA_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(3);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_EXTREME_MAGNITUDES_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(4);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_EXTREME_ANGLES_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(5);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_TOP_AND_BOTTOM_DEAD_SPOT_ANGLE_SUPPORTED:
        cycling_power_feature_flag_t = cycling_power_feature_flag_t(6);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_ACCUMULATED_ENERGY_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(7);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_OFFSET_COMPENSATION_INDICATOR_SUPPORTED:
        cycling_power_feature_flag_t = cycling_power_feature_flag_t(8);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_OFFSET_COMPENSATION_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(9);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_CYCLING_POWER_MEASUREMENT_CHARACTERISTIC_CONTENT_MASKING_SUPPORTED:
        cycling_power_feature_flag_t = cycling_power_feature_flag_t(10);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_MULTIPLE_SENSOR_LOCATIONS_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(11);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_CRANK_LENGTH_ADJUSTMENT_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(12);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_CHAIN_LENGTH_ADJUSTMENT_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(13);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_CHAIN_WEIGHT_ADJUSTMENT_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(14);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_SPAN_LENGTH_ADJUSTMENT_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(15);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_SENSOR_MEASUREMENT_CONTEXT: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(16);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_INSTANTANEOUS_MEASUREMENT_DIRECTION_SUPPORTED:
        cycling_power_feature_flag_t = cycling_power_feature_flag_t(17);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_FACTORY_CALIBRATION_DATE_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(18);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_ENHANCED_OFFSET_COMPENSATION_SUPPORTED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(19);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_DISTRIBUTED_SYSTEM_SUPPORT: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(20);
}
impl cycling_power_feature_flag_t {
    pub const CP_FEATURE_FLAG_RESERVED: cycling_power_feature_flag_t =
        cycling_power_feature_flag_t(22);
}
impl ::core::ops::BitOr<cycling_power_feature_flag_t> for cycling_power_feature_flag_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_feature_flag_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_feature_flag_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_feature_flag_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_feature_flag_t> for cycling_power_feature_flag_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_feature_flag_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_feature_flag_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_feature_flag_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_feature_flag_t(pub cty::c_uint);
impl cycling_power_calibration_status_t {
    pub const CP_CALIBRATION_STATUS_INCORRECT_CALIBRATION_POSITION:
        cycling_power_calibration_status_t = cycling_power_calibration_status_t(1);
}
impl cycling_power_calibration_status_t {
    pub const CP_CALIBRATION_STATUS_MANUFACTURER_SPECIFIC_ERROR_FOLLOWS:
        cycling_power_calibration_status_t = cycling_power_calibration_status_t(255);
}
impl ::core::ops::BitOr<cycling_power_calibration_status_t> for cycling_power_calibration_status_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_power_calibration_status_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_power_calibration_status_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_power_calibration_status_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_power_calibration_status_t>
    for cycling_power_calibration_status_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_power_calibration_status_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_power_calibration_status_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_power_calibration_status_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_power_calibration_status_t(pub cty::c_uint);
extern "C" {
    #[doc = " @brief Init Server with ATT DB"]
    pub fn cycling_power_service_server_init(
        feature_flags: u32,
        reference: cycling_power_pedal_power_balance_reference_t,
        torque_source: cycling_power_torque_source_t,
        supported_sensor_locations: *mut cycling_power_sensor_location_t,
        num_supported_sensor_locations: u16,
        current_sensor_location: cycling_power_sensor_location_t,
    );
}
extern "C" {
    #[doc = " @brief Push update\n @note triggers notifications if subscribed"]
    pub fn cycling_power_service_server_update_values();
}
extern "C" {
    pub fn cycling_power_server_enhanced_calibration_done(
        measurement_type: cycling_power_sensor_measurement_context_t,
        calibrated_value: u16,
        manufacturer_company_id: u16,
        num_manufacturer_specific_data: u8,
        manufacturer_specific_data: *mut u8,
    );
}
extern "C" {
    pub fn cycling_power_get_measurement_adv(
        adv_interval: u16,
        value: *mut u8,
        max_value_size: u16,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Register callback for the calibration.\n @param callback"]
    pub fn cycling_power_service_server_packet_handler(callback: btstack_packet_handler_t);
}
extern "C" {
    pub fn cycling_power_server_calibration_done(
        measurement_type: cycling_power_sensor_measurement_context_t,
        calibrated_value: u16,
    );
}
extern "C" {
    pub fn cycling_power_service_server_set_factory_calibration_date(
        date: gatt_date_time_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cycling_power_service_server_set_sampling_rate(sampling_rate_hz: u8);
}
extern "C" {
    pub fn cycling_power_service_server_add_torque(torque_m: i16);
}
extern "C" {
    pub fn cycling_power_service_server_add_wheel_revolution(
        wheel_revolution: i32,
        wheel_event_time_s: u16,
    );
}
extern "C" {
    pub fn cycling_power_service_server_add_crank_revolution(
        crank_revolution: u16,
        crank_event_time_s: u16,
    );
}
extern "C" {
    pub fn cycling_power_service_add_energy(energy_kJ: u16);
}
extern "C" {
    pub fn cycling_power_service_server_set_instantaneous_power(instantaneous_power_watt: i16);
}
extern "C" {
    pub fn cycling_power_service_server_set_pedal_power_balance(pedal_power_balance_percentage: u8);
}
extern "C" {
    pub fn cycling_power_service_server_set_force_magnitude(
        min_force_magnitude_newton: i16,
        max_force_magnitude_newton: i16,
    );
}
extern "C" {
    pub fn cycling_power_service_server_set_torque_magnitude(
        min_torque_magnitude_newton: i16,
        max_torque_magnitude_newton: i16,
    );
}
extern "C" {
    pub fn cycling_power_service_server_set_angle(min_angle_deg: u16, max_angle_deg: u16);
}
extern "C" {
    pub fn cycling_power_service_server_set_top_dead_spot_angle(top_dead_spot_angle_deg: u16);
}
extern "C" {
    pub fn cycling_power_service_server_set_bottom_dead_spot_angle(bottom_dead_spot_angle_deg: u16);
}
extern "C" {
    pub fn cycling_power_service_server_set_force_magnitude_values(
        force_magnitude_count: cty::c_int,
        force_magnitude_newton_array: *mut i16,
    );
}
extern "C" {
    pub fn cycling_power_service_server_set_torque_magnitude_values(
        torque_magnitude_count: cty::c_int,
        torque_magnitude_newton_array: *mut i16,
    );
}
extern "C" {
    pub fn cycling_power_service_server_set_instantaneous_measurement_direction(
        direction: cycling_power_instantaneous_measurement_direction_t,
    );
}
extern "C" {
    pub fn cycling_power_service_server_set_first_crank_measurement_angle(
        first_crank_measurement_angle_deg: u16,
    );
}
extern "C" {
    pub fn cycling_power_service_measurement_flags() -> u16;
}
extern "C" {
    pub fn cycling_power_service_vector_flags() -> u8;
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_OTHER: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(0);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_TOP_OF_SHOE: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(1);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_IN_SHOE: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(2);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_HIP: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(3);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_FRONT_WHEEL: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(4);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_LEFT_CRANK: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(5);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_RIGHT_CRANK: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(6);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_LEFT_PEDAL: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(7);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_RIGHT_PEDAL: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(8);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_FRONT_HUB: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(9);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_REAR_DROPOUT:
        cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(10);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_CHAINSTAY: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(11);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_REAR_WHEEL: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(12);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_REAR_HUB: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(13);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_CHEST: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(14);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_SPIDER: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(15);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_CHAIN_RING: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(16);
}
impl cycling_speed_and_cadence_sensor_location_t {
    pub const CSC_SERVICE_SENSOR_LOCATION_RESERVED: cycling_speed_and_cadence_sensor_location_t =
        cycling_speed_and_cadence_sensor_location_t(17);
}
impl ::core::ops::BitOr<cycling_speed_and_cadence_sensor_location_t>
    for cycling_speed_and_cadence_sensor_location_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cycling_speed_and_cadence_sensor_location_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for cycling_speed_and_cadence_sensor_location_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cycling_speed_and_cadence_sensor_location_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<cycling_speed_and_cadence_sensor_location_t>
    for cycling_speed_and_cadence_sensor_location_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cycling_speed_and_cadence_sensor_location_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for cycling_speed_and_cadence_sensor_location_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cycling_speed_and_cadence_sensor_location_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @text The Cycling Speed and Cadence Service allows to query\n device's speed- and cadence-related data for use in sports and\n fitness applications.\n\n To use with your application, add `#import <cycling_speed_and_cadence_service.gatt>`\n to your .gatt file."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cycling_speed_and_cadence_sensor_location_t(pub cty::c_uint);
impl csc_feature_flag_bit_t {
    pub const CSC_FLAG_WHEEL_REVOLUTION_DATA_SUPPORTED: csc_feature_flag_bit_t =
        csc_feature_flag_bit_t(0);
}
impl csc_feature_flag_bit_t {
    pub const CSC_FLAG_CRANK_REVOLUTION_DATA_SUPPORTED: csc_feature_flag_bit_t =
        csc_feature_flag_bit_t(1);
}
impl csc_feature_flag_bit_t {
    pub const CSC_FLAG_MULTIPLE_SENSOR_LOCATIONS_SUPPORTED: csc_feature_flag_bit_t =
        csc_feature_flag_bit_t(2);
}
impl ::core::ops::BitOr<csc_feature_flag_bit_t> for csc_feature_flag_bit_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        csc_feature_flag_bit_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for csc_feature_flag_bit_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: csc_feature_flag_bit_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<csc_feature_flag_bit_t> for csc_feature_flag_bit_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        csc_feature_flag_bit_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for csc_feature_flag_bit_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: csc_feature_flag_bit_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct csc_feature_flag_bit_t(pub cty::c_uint);
impl csc_opcode_t {
    pub const CSC_OPCODE_IDLE: csc_opcode_t = csc_opcode_t(0);
}
impl csc_opcode_t {
    pub const CSC_OPCODE_SET_CUMULATIVE_VALUE: csc_opcode_t = csc_opcode_t(1);
}
impl csc_opcode_t {
    pub const CSC_OPCODE_START_SENSOR_CALIBRATION: csc_opcode_t = csc_opcode_t(2);
}
impl csc_opcode_t {
    pub const CSC_OPCODE_UPDATE_SENSOR_LOCATION: csc_opcode_t = csc_opcode_t(3);
}
impl csc_opcode_t {
    pub const CSC_OPCODE_REQUEST_SUPPORTED_SENSOR_LOCATIONS: csc_opcode_t = csc_opcode_t(4);
}
impl csc_opcode_t {
    pub const CSC_OPCODE_RESPONSE_CODE: csc_opcode_t = csc_opcode_t(16);
}
impl ::core::ops::BitOr<csc_opcode_t> for csc_opcode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        csc_opcode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for csc_opcode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: csc_opcode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<csc_opcode_t> for csc_opcode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        csc_opcode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for csc_opcode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: csc_opcode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct csc_opcode_t(pub cty::c_uint);
extern "C" {
    #[doc = " @brief Init Server with ATT DB"]
    pub fn cycling_speed_and_cadence_service_server_init(
        supported_sensor_locations: u32,
        multiple_sensor_locations_supported: u8,
        wheel_revolution_data_supported: u8,
        crank_revolution_data_supported: u8,
    );
}
extern "C" {
    #[doc = " @brief Update heart rate (unit: beats per minute)\n @note triggers notifications if subscribed"]
    pub fn cycling_speed_and_cadence_service_server_update_values(
        wheel_revolutions: i32,
        last_wheel_event_time: u16,
        crank_revolutions: u16,
        last_crank_event_time: u16,
    );
}
extern "C" {
    #[doc = " @brief Initialize Device Information Service."]
    pub fn device_information_service_client_init();
}
extern "C" {
    #[doc = " @brief Query Device Information Service. The client will query the remote service and emit events:\n\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_MANUFACTURER_NAME\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_MODEL_NUMBER\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_SERIAL_NUMBER\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_HARDWARE_REVISION\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_FIRMWARE_REVISION\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_SOFTWARE_REVISION\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_SYSTEM_ID\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_IEEE_REGULATORY_CERTIFICATION\n - GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_PNP_ID\n\n Event GATTSERVICE_SUBEVENT_DEVICE_INFORMATION_DONE is received when all queries are done, of if service was not found.\n The status field of this event indicated ATT errors (see bluetooth.h).\n\n @param con_handle\n @param packet_handler\n @return status ERROR_CODE_SUCCESS on success, otherwise GATT_CLIENT_IN_WRONG_STATE if query is already in progress"]
    pub fn device_information_service_client_query(
        con_handle: hci_con_handle_t,
        packet_handler: btstack_packet_handler_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief De-initialize Device Information Service."]
    pub fn device_information_service_client_deinit();
}
extern "C" {
    #[doc = " @brief Init Device Information Service Server with ATT DB\n @param battery_value in range 0-100"]
    pub fn device_information_service_server_init();
}
extern "C" {
    #[doc = " @brief Set Manufacturer Name\n @param manufacturer_name"]
    pub fn device_information_service_server_set_manufacturer_name(
        manufacturer_name: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set Model Number\n @param model_number"]
    pub fn device_information_service_server_set_model_number(model_number: *const cty::c_char);
}
extern "C" {
    #[doc = " @brief Set Serial Number\n @param serial_number"]
    pub fn device_information_service_server_set_serial_number(serial_number: *const cty::c_char);
}
extern "C" {
    #[doc = " @brief Set Hardware Revision\n @param hardware_revision"]
    pub fn device_information_service_server_set_hardware_revision(
        hardware_revision: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set Firmware Revision\n @param firmware_revision"]
    pub fn device_information_service_server_set_firmware_revision(
        firmware_revision: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set Software Revision\n @param software_revision"]
    pub fn device_information_service_server_set_software_revision(
        software_revision: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set System ID\n @param manufacturer_identifier uint40\n @param organizationally_unique_identifier uint24"]
    pub fn device_information_service_server_set_system_id(
        manufacturer_identifier: u64,
        organizationally_unique_identifier: u32,
    );
}
extern "C" {
    #[doc = " @brief Set IEEE 11073-20601 regulatory certification data list\n @note: format duint16. duint16 is two uint16 values concatenated together.\n @param value_a\n @param value_b"]
    pub fn device_information_service_server_set_ieee_regulatory_certification(
        value_a: u16,
        value_b: u16,
    );
}
extern "C" {
    #[doc = " @brief Set PnP ID\n @param vendor_source_id\n @param vendor_id\n @param product_id\n @Param product_versoin"]
    pub fn device_information_service_server_set_pnp_id(
        vendor_source_id: u8,
        vendor_id: u16,
        product_id: u16,
        product_version: u16,
    );
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_OTHER:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(0);
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_CHEST:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(1);
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_WRIST:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(2);
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_FINGER:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(3);
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_HAND:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(4);
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_EAR_LOBE:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(5);
}
impl heart_rate_service_body_sensor_location_t {
    pub const HEART_RATE_SERVICE_BODY_SENSOR_LOCATION_FOOT:
        heart_rate_service_body_sensor_location_t = heart_rate_service_body_sensor_location_t(6);
}
impl ::core::ops::BitOr<heart_rate_service_body_sensor_location_t>
    for heart_rate_service_body_sensor_location_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        heart_rate_service_body_sensor_location_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for heart_rate_service_body_sensor_location_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: heart_rate_service_body_sensor_location_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<heart_rate_service_body_sensor_location_t>
    for heart_rate_service_body_sensor_location_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        heart_rate_service_body_sensor_location_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for heart_rate_service_body_sensor_location_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: heart_rate_service_body_sensor_location_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @text The heart rate service server provides heart rate measurements via notifications.\n\n Each notification reports the heart rate measurement in beats per minute, and if enabled,\n the total energy expended in kilo Joules, as well as RR-intervals in 1/1024 seconds resolution.\n\n The Energy Expended field represents the accumulated energy expended\n in kilo Joules since the last time it was reset. If the maximum value of 65535\n kilo Joules is reached, it will remain at this value, until a reset command\n from the client is received.\n\n The RR-Interval represents the time between two consecutive R waves in\n an Electrocardiogram (ECG) waveform. If needed, the RR-Intervals are sent in\n multiple notifications.\n\n To use with your application, add `#import <heart_rate_service.gatt>` to your .gatt file.\n After adding it to your .gatt file, you call *heart_rate_server_init(body_sensor_location, energy_expended_supported)*\n with the intended sensor location, and a flag indicating if energy expanded is supported.\n\n If heart rate measurement changes, you can call\n *heart_rate_service_server_update_heart_rate_values(heart_rate_bpm, service_sensor_contact_status, rr_interval_count, rr_intervals)*.\n This function will trigger sending Notifications if the client enables them.\n\n If energy expanded is supported, you can call *heart_rate_service_add_energy_expended(energy_expended_kJ)*\n with the newly expanded energy. The accumulated energy expended value\n will be emitted with the next heart rate measurement."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct heart_rate_service_body_sensor_location_t(pub cty::c_uint);
impl heart_rate_service_sensor_contact_status_t {
    pub const HEART_RATE_SERVICE_SENSOR_CONTACT_UNKNOWN:
        heart_rate_service_sensor_contact_status_t = heart_rate_service_sensor_contact_status_t(0);
}
impl heart_rate_service_sensor_contact_status_t {
    pub const HEART_RATE_SERVICE_SENSOR_CONTACT_UNSUPPORTED:
        heart_rate_service_sensor_contact_status_t = heart_rate_service_sensor_contact_status_t(1);
}
impl heart_rate_service_sensor_contact_status_t {
    pub const HEART_RATE_SERVICE_SENSOR_CONTACT_NO_CONTACT:
        heart_rate_service_sensor_contact_status_t = heart_rate_service_sensor_contact_status_t(2);
}
impl heart_rate_service_sensor_contact_status_t {
    pub const HEART_RATE_SERVICE_SENSOR_CONTACT_HAVE_CONTACT:
        heart_rate_service_sensor_contact_status_t = heart_rate_service_sensor_contact_status_t(3);
}
impl ::core::ops::BitOr<heart_rate_service_sensor_contact_status_t>
    for heart_rate_service_sensor_contact_status_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        heart_rate_service_sensor_contact_status_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for heart_rate_service_sensor_contact_status_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: heart_rate_service_sensor_contact_status_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<heart_rate_service_sensor_contact_status_t>
    for heart_rate_service_sensor_contact_status_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        heart_rate_service_sensor_contact_status_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for heart_rate_service_sensor_contact_status_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: heart_rate_service_sensor_contact_status_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct heart_rate_service_sensor_contact_status_t(pub cty::c_uint);
extern "C" {
    #[doc = " @brief Init Battery Service Server with ATT DB\n @param body_sensor_location\n @param energy_expended_supported"]
    pub fn heart_rate_service_server_init(
        body_sensor_location: heart_rate_service_body_sensor_location_t,
        energy_expended_supported: cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief Add Energy Expended to the internal accumulator.\n @param energy_expended_kJ   energy expended in kilo Joules since the last update"]
    pub fn heart_rate_service_add_energy_expended(energy_expended_kJ: u16);
}
extern "C" {
    #[doc = " @brief Update heart rate (unit: beats per minute)\n @note triggers notifications if subscribed\n @param heart_rate_bpm \t\tbeats per minute\n @param contact\n @param rr_interval_count\n @param rr_intervals      resolution in 1/1024 seconds"]
    pub fn heart_rate_service_server_update_heart_rate_values(
        heart_rate_bpm: u16,
        contact: heart_rate_service_sensor_contact_status_t,
        rr_interval_count: cty::c_int,
        rr_intervals: *mut u16,
    );
}
extern "C" {
    #[doc = " @brief Set up HIDS Device"]
    pub fn hids_device_init(
        hid_country_code: u8,
        hid_descriptor: *const u8,
        hid_descriptor_size: u16,
    );
}
extern "C" {
    #[doc = " @brief Register callback for the HIDS Device client.\n @param callback"]
    pub fn hids_device_register_packet_handler(callback: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief Request can send now event to send HID Report\n Generates an HIDS_SUBEVENT_CAN_SEND_NOW subevent\n @param hid_cid"]
    pub fn hids_device_request_can_send_now_event(con_handle: hci_con_handle_t);
}
extern "C" {
    #[doc = " @brief Send HID Report: Input"]
    pub fn hids_device_send_input_report(
        con_handle: hci_con_handle_t,
        report: *const u8,
        report_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Send HID Report: Output"]
    pub fn hids_device_send_output_report(
        con_handle: hci_con_handle_t,
        report: *const u8,
        report_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Send HID Report: Feature"]
    pub fn hids_device_send_feature_report(
        con_handle: hci_con_handle_t,
        report: *const u8,
        report_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Send HID Boot Mouse Input Report"]
    pub fn hids_device_send_boot_mouse_input_report(
        con_handle: hci_con_handle_t,
        report: *const u8,
        report_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Send HID Boot Mouse Input Report"]
    pub fn hids_device_send_boot_keyboard_input_report(
        con_handle: hci_con_handle_t,
        report: *const u8,
        report_len: u16,
    );
}
extern "C" {
    #[doc = " @brief Init Scan Parameters Service Server with ATT DB\n @param packet_handler"]
    pub fn scan_parameters_service_server_init(packet_handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief Request scan parameters from Scan Parameters Client."]
    pub fn scan_parameters_service_server_request_scan_parameters();
}
extern "C" {
    #[doc = " @brief Init TX Power Service Server with ATT DB\n @param tx_power_level"]
    pub fn tx_power_service_server_init(tx_power_level: i8);
}
extern "C" {
    #[doc = " @brief Update TX power level\n @param tx_power_level_dBm range [-100,20]"]
    pub fn tx_power_service_server_set_level(tx_power_level_dBm: i8);
}
extern "C" {
    #[doc = " @brief init"]
    pub fn le_device_db_init();
}
extern "C" {
    #[doc = " @brief sets local bd addr. allows for db per Bluetooth controller\n @param bd_addr"]
    pub fn le_device_db_set_local_bd_addr(bd_addr: *mut u8);
}
extern "C" {
    #[doc = " @brief add device to db\n @param addr_type, address of the device\n @param irk of the device\n @return index if successful, -1 otherwise"]
    pub fn le_device_db_add(addr_type: cty::c_int, addr: *mut u8, irk: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief get number of devices in db\n @return number of device in db"]
    pub fn le_device_db_count() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief get max number of devices in db for enumeration\n @return max number of device in db"]
    pub fn le_device_db_max_count() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief get device information: addr type and address needed to identify device\n @param index\n @param addr_type, address of the device as output\n @param irk of the device"]
    pub fn le_device_db_info(
        index: cty::c_int,
        addr_type: *mut cty::c_int,
        addr: *mut u8,
        irk: *mut u8,
    );
}
extern "C" {
    #[doc = " @brief set remote encryption info\n @brief index\n @brief ediv\n @brief rand\n @brief ltk\n @brief key size\n @brief authenticated\n @brief authorized\n @breif secure_connection"]
    pub fn le_device_db_encryption_set(
        index: cty::c_int,
        ediv: u16,
        rand: *mut u8,
        ltk: *mut u8,
        key_size: cty::c_int,
        authenticated: cty::c_int,
        authorized: cty::c_int,
        secure_connection: cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief get remote encryption info\n @brief index\n @brief ediv\n @brief rand\n @brief ltk\n @brief key size\n @brief authenticated\n @brief authorized\n @breif secure_connection"]
    pub fn le_device_db_encryption_get(
        index: cty::c_int,
        ediv: *mut u16,
        rand: *mut u8,
        ltk: *mut u8,
        key_size: *mut cty::c_int,
        authenticated: *mut cty::c_int,
        authorized: *mut cty::c_int,
        secure_connection: *mut cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief free device\n @param index"]
    pub fn le_device_db_remove(index: cty::c_int);
}
extern "C" {
    pub fn le_device_db_dump();
}
impl le_audio_role_t {
    pub const LE_AUDIO_ROLE_SINK: le_audio_role_t = le_audio_role_t(0);
}
impl le_audio_role_t {
    pub const LE_AUDIO_ROLE_SOURCE: le_audio_role_t = le_audio_role_t(1);
}
impl ::core::ops::BitOr<le_audio_role_t> for le_audio_role_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_role_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_role_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_role_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_role_t> for le_audio_role_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_role_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_role_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_role_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_role_t(pub cty::c_uint);
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_UNDEFINED: le_audio_codec_configuration_type_t =
        le_audio_codec_configuration_type_t(0);
}
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_SAMPLING_FREQUENCY:
        le_audio_codec_configuration_type_t = le_audio_codec_configuration_type_t(1);
}
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_FRAME_DURATION:
        le_audio_codec_configuration_type_t = le_audio_codec_configuration_type_t(2);
}
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_AUDIO_CHANNEL_ALLOCATION:
        le_audio_codec_configuration_type_t = le_audio_codec_configuration_type_t(3);
}
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_OCTETS_PER_CODEC_FRAME:
        le_audio_codec_configuration_type_t = le_audio_codec_configuration_type_t(4);
}
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_CODEC_FRAME_BLOCKS_PER_SDU:
        le_audio_codec_configuration_type_t = le_audio_codec_configuration_type_t(5);
}
impl le_audio_codec_configuration_type_t {
    pub const LE_AUDIO_CODEC_CONFIGURATION_TYPE_RFU: le_audio_codec_configuration_type_t =
        le_audio_codec_configuration_type_t(6);
}
impl ::core::ops::BitOr<le_audio_codec_configuration_type_t>
    for le_audio_codec_configuration_type_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_codec_configuration_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_codec_configuration_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_codec_configuration_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_codec_configuration_type_t>
    for le_audio_codec_configuration_type_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_codec_configuration_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_codec_configuration_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_codec_configuration_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_codec_configuration_type_t(pub cty::c_uint);
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_UNDEFINED: le_audio_codec_capability_type_t =
        le_audio_codec_capability_type_t(0);
}
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_SAMPLING_FREQUENCY: le_audio_codec_capability_type_t =
        le_audio_codec_capability_type_t(1);
}
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_FRAME_DURATION: le_audio_codec_capability_type_t =
        le_audio_codec_capability_type_t(2);
}
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_SUPPORTED_AUDIO_CHANNEL_COUNTS:
        le_audio_codec_capability_type_t = le_audio_codec_capability_type_t(3);
}
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_OCTETS_PER_CODEC_FRAME:
        le_audio_codec_capability_type_t = le_audio_codec_capability_type_t(4);
}
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_CODEC_FRAME_BLOCKS_PER_SDU:
        le_audio_codec_capability_type_t = le_audio_codec_capability_type_t(5);
}
impl le_audio_codec_capability_type_t {
    pub const LE_AUDIO_CODEC_CAPABILITY_TYPE_RFU: le_audio_codec_capability_type_t =
        le_audio_codec_capability_type_t(6);
}
impl ::core::ops::BitOr<le_audio_codec_capability_type_t> for le_audio_codec_capability_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_codec_capability_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_codec_capability_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_codec_capability_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_codec_capability_type_t> for le_audio_codec_capability_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_codec_capability_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_codec_capability_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_codec_capability_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_codec_capability_type_t(pub cty::c_uint);
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_INVALID:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(0);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_8000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(1);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_11025_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(2);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_16000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(3);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_22050_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(4);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_24000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(5);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_32000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(6);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_44100_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(7);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_48000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(8);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_88200_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(9);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_96000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(10);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_176400_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(11);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_192000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(12);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_384000_HZ:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(13);
}
impl le_audio_codec_sampling_frequency_index_t {
    pub const LE_AUDIO_CODEC_SAMPLING_FREQUENCY_INDEX_RFU:
        le_audio_codec_sampling_frequency_index_t = le_audio_codec_sampling_frequency_index_t(14);
}
impl ::core::ops::BitOr<le_audio_codec_sampling_frequency_index_t>
    for le_audio_codec_sampling_frequency_index_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_codec_sampling_frequency_index_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_codec_sampling_frequency_index_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_codec_sampling_frequency_index_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_codec_sampling_frequency_index_t>
    for le_audio_codec_sampling_frequency_index_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_codec_sampling_frequency_index_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_codec_sampling_frequency_index_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_codec_sampling_frequency_index_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_codec_sampling_frequency_index_t(pub cty::c_uint);
impl le_audio_codec_frame_duration_index_t {
    pub const LE_AUDIO_CODEC_FRAME_DURATION_INDEX_INVALID: le_audio_codec_frame_duration_index_t =
        le_audio_codec_frame_duration_index_t(0);
}
impl le_audio_codec_frame_duration_index_t {
    pub const LE_AUDIO_CODEC_FRAME_DURATION_INDEX_7500US: le_audio_codec_frame_duration_index_t =
        le_audio_codec_frame_duration_index_t(1);
}
impl le_audio_codec_frame_duration_index_t {
    pub const LE_AUDIO_CODEC_FRAME_DURATION_INDEX_10000US: le_audio_codec_frame_duration_index_t =
        le_audio_codec_frame_duration_index_t(2);
}
impl le_audio_codec_frame_duration_index_t {
    pub const LE_AUDIO_CODEC_FRAME_DURATION_INDEX_RFU: le_audio_codec_frame_duration_index_t =
        le_audio_codec_frame_duration_index_t(3);
}
impl ::core::ops::BitOr<le_audio_codec_frame_duration_index_t>
    for le_audio_codec_frame_duration_index_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_codec_frame_duration_index_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_codec_frame_duration_index_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_codec_frame_duration_index_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_codec_frame_duration_index_t>
    for le_audio_codec_frame_duration_index_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_codec_frame_duration_index_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_codec_frame_duration_index_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_codec_frame_duration_index_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_codec_frame_duration_index_t(pub cty::c_uint);
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_INVALID: le_audio_metadata_type_t =
        le_audio_metadata_type_t(0);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_PREFERRED_AUDIO_CONTEXTS: le_audio_metadata_type_t =
        le_audio_metadata_type_t(1);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_STREAMING_AUDIO_CONTEXTS: le_audio_metadata_type_t =
        le_audio_metadata_type_t(2);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_PROGRAM_INFO: le_audio_metadata_type_t =
        le_audio_metadata_type_t(3);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_LANGUAGE: le_audio_metadata_type_t =
        le_audio_metadata_type_t(4);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_CCID_LIST: le_audio_metadata_type_t =
        le_audio_metadata_type_t(5);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_PARENTAL_RATING: le_audio_metadata_type_t =
        le_audio_metadata_type_t(6);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_PROGRAM_INFO_URI: le_audio_metadata_type_t =
        le_audio_metadata_type_t(7);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_MAPPED_EXTENDED_METADATA_BIT_POSITION:
        le_audio_metadata_type_t = le_audio_metadata_type_t(8);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_MAPPED_VENDOR_SPECIFIC_METADATA_BIT_POSITION:
        le_audio_metadata_type_t = le_audio_metadata_type_t(9);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_RFU: le_audio_metadata_type_t = le_audio_metadata_type_t(10);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_EXTENDED_METADATA: le_audio_metadata_type_t =
        le_audio_metadata_type_t(254);
}
impl le_audio_metadata_type_t {
    pub const LE_AUDIO_METADATA_TYPE_VENDOR_SPECIFIC_METADATA: le_audio_metadata_type_t =
        le_audio_metadata_type_t(255);
}
impl ::core::ops::BitOr<le_audio_metadata_type_t> for le_audio_metadata_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_metadata_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_metadata_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_metadata_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_metadata_type_t> for le_audio_metadata_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_metadata_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_metadata_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_metadata_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_metadata_type_t(pub cty::c_uint);
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_NO_RATING: le_audio_parental_rating_t =
        le_audio_parental_rating_t(0);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_ANY_AGE: le_audio_parental_rating_t =
        le_audio_parental_rating_t(1);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_2: le_audio_parental_rating_t =
        le_audio_parental_rating_t(2);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_3: le_audio_parental_rating_t =
        le_audio_parental_rating_t(3);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_4: le_audio_parental_rating_t =
        le_audio_parental_rating_t(4);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_6: le_audio_parental_rating_t =
        le_audio_parental_rating_t(5);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_7: le_audio_parental_rating_t =
        le_audio_parental_rating_t(6);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_8: le_audio_parental_rating_t =
        le_audio_parental_rating_t(7);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_9: le_audio_parental_rating_t =
        le_audio_parental_rating_t(8);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_AGE_10: le_audio_parental_rating_t =
        le_audio_parental_rating_t(9);
}
impl le_audio_parental_rating_t {
    pub const LE_AUDIO_PARENTAL_RATING_RFU: le_audio_parental_rating_t =
        le_audio_parental_rating_t(8);
}
impl ::core::ops::BitOr<le_audio_parental_rating_t> for le_audio_parental_rating_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_parental_rating_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_parental_rating_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_parental_rating_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_parental_rating_t> for le_audio_parental_rating_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_parental_rating_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_parental_rating_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_parental_rating_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_parental_rating_t(pub cty::c_uint);
impl le_audio_client_target_latency_t {
    pub const LE_AUDIO_CLIENT_TARGET_LATENCY_NO_PREFERENCE: le_audio_client_target_latency_t =
        le_audio_client_target_latency_t(0);
}
impl le_audio_client_target_latency_t {
    pub const LE_AUDIO_CLIENT_TARGET_LATENCY_LOW_LATENCY: le_audio_client_target_latency_t =
        le_audio_client_target_latency_t(1);
}
impl le_audio_client_target_latency_t {
    pub const LE_AUDIO_CLIENT_TARGET_LATENCY_BALANCED_LATENCY_AND_RELIABILITY:
        le_audio_client_target_latency_t = le_audio_client_target_latency_t(2);
}
impl le_audio_client_target_latency_t {
    pub const LE_AUDIO_CLIENT_TARGET_LATENCY_HIGH_RELIABILITY: le_audio_client_target_latency_t =
        le_audio_client_target_latency_t(3);
}
impl le_audio_client_target_latency_t {
    pub const LE_AUDIO_CLIENT_TARGET_LATENCY_RFU: le_audio_client_target_latency_t =
        le_audio_client_target_latency_t(4);
}
impl ::core::ops::BitOr<le_audio_client_target_latency_t> for le_audio_client_target_latency_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_client_target_latency_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_client_target_latency_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_client_target_latency_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_client_target_latency_t> for le_audio_client_target_latency_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_client_target_latency_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_client_target_latency_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_client_target_latency_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_client_target_latency_t(pub cty::c_uint);
impl le_audio_client_target_phy_t {
    pub const LE_AUDIO_CLIENT_TARGET_PHY_NO_PREFERENCE: le_audio_client_target_phy_t =
        le_audio_client_target_phy_t(0);
}
impl le_audio_client_target_phy_t {
    pub const LE_AUDIO_CLIENT_TARGET_PHY_LOW: le_audio_client_target_phy_t =
        le_audio_client_target_phy_t(1);
}
impl le_audio_client_target_phy_t {
    pub const LE_AUDIO_CLIENT_TARGET_PHY_BALANCED: le_audio_client_target_phy_t =
        le_audio_client_target_phy_t(2);
}
impl le_audio_client_target_phy_t {
    pub const LE_AUDIO_CLIENT_TARGET_PHY_HIGH: le_audio_client_target_phy_t =
        le_audio_client_target_phy_t(3);
}
impl le_audio_client_target_phy_t {
    pub const LE_AUDIO_CLIENT_TARGET_PHY_RFU: le_audio_client_target_phy_t =
        le_audio_client_target_phy_t(4);
}
impl ::core::ops::BitOr<le_audio_client_target_phy_t> for le_audio_client_target_phy_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_client_target_phy_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_client_target_phy_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_client_target_phy_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_client_target_phy_t> for le_audio_client_target_phy_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_client_target_phy_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_client_target_phy_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_client_target_phy_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_client_target_phy_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_audio_codec_id_t {
    pub coding_format: hci_audio_coding_format_t,
    pub company_id: u16,
    pub vendor_specific_codec_id: u16,
}
impl le_audio_pa_sync_t {
    pub const LE_AUDIO_PA_SYNC_DO_NOT_SYNCHRONIZE_TO_PA: le_audio_pa_sync_t = le_audio_pa_sync_t(0);
}
impl le_audio_pa_sync_t {
    pub const LE_AUDIO_PA_SYNC_SYNCHRONIZE_TO_PA_PAST_AVAILABLE: le_audio_pa_sync_t =
        le_audio_pa_sync_t(1);
}
impl le_audio_pa_sync_t {
    pub const LE_AUDIO_PA_SYNC_SYNCHRONIZE_TO_PA_PAST_NOT_AVAILABLE: le_audio_pa_sync_t =
        le_audio_pa_sync_t(2);
}
impl le_audio_pa_sync_t {
    pub const LE_AUDIO_PA_SYNC_RFU: le_audio_pa_sync_t = le_audio_pa_sync_t(3);
}
impl ::core::ops::BitOr<le_audio_pa_sync_t> for le_audio_pa_sync_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_pa_sync_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_pa_sync_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_pa_sync_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_pa_sync_t> for le_audio_pa_sync_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_pa_sync_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_pa_sync_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_pa_sync_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_pa_sync_t(pub cty::c_uint);
impl le_audio_pa_sync_state_t {
    pub const LE_AUDIO_PA_SYNC_STATE_NOT_SYNCHRONIZED_TO_PA: le_audio_pa_sync_state_t =
        le_audio_pa_sync_state_t(0);
}
impl le_audio_pa_sync_state_t {
    pub const LE_AUDIO_PA_SYNC_STATE_SYNCINFO_REQUEST: le_audio_pa_sync_state_t =
        le_audio_pa_sync_state_t(1);
}
impl le_audio_pa_sync_state_t {
    pub const LE_AUDIO_PA_SYNC_STATE_SYNCHRONIZED_TO_PA: le_audio_pa_sync_state_t =
        le_audio_pa_sync_state_t(2);
}
impl le_audio_pa_sync_state_t {
    pub const LE_AUDIO_PA_SYNC_STATE_FAILED_TO_SYNCHRONIZE_TO_PA: le_audio_pa_sync_state_t =
        le_audio_pa_sync_state_t(3);
}
impl le_audio_pa_sync_state_t {
    pub const LE_AUDIO_PA_SYNC_STATE_NO_PAST: le_audio_pa_sync_state_t =
        le_audio_pa_sync_state_t(4);
}
impl le_audio_pa_sync_state_t {
    pub const LE_AUDIO_PA_SYNC_STATE_RFU: le_audio_pa_sync_state_t = le_audio_pa_sync_state_t(5);
}
impl ::core::ops::BitOr<le_audio_pa_sync_state_t> for le_audio_pa_sync_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_pa_sync_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_pa_sync_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_pa_sync_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_pa_sync_state_t> for le_audio_pa_sync_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_pa_sync_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_pa_sync_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_pa_sync_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_pa_sync_state_t(pub cty::c_uint);
impl le_audio_big_encryption_t {
    pub const LE_AUDIO_BIG_ENCRYPTION_NOT_ENCRYPTED: le_audio_big_encryption_t =
        le_audio_big_encryption_t(0);
}
impl le_audio_big_encryption_t {
    pub const LE_AUDIO_BIG_ENCRYPTION_BROADCAST_CODE_REQUIRED: le_audio_big_encryption_t =
        le_audio_big_encryption_t(1);
}
impl le_audio_big_encryption_t {
    pub const LE_AUDIO_BIG_ENCRYPTION_DECRYPTING: le_audio_big_encryption_t =
        le_audio_big_encryption_t(2);
}
impl le_audio_big_encryption_t {
    pub const LE_AUDIO_BIG_ENCRYPTION_BAD_CODE: le_audio_big_encryption_t =
        le_audio_big_encryption_t(3);
}
impl le_audio_big_encryption_t {
    pub const LE_AUDIO_BIG_ENCRYPTION_RFU: le_audio_big_encryption_t = le_audio_big_encryption_t(4);
}
impl ::core::ops::BitOr<le_audio_big_encryption_t> for le_audio_big_encryption_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        le_audio_big_encryption_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for le_audio_big_encryption_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: le_audio_big_encryption_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<le_audio_big_encryption_t> for le_audio_big_encryption_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        le_audio_big_encryption_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for le_audio_big_encryption_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: le_audio_big_encryption_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct le_audio_big_encryption_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct le_audio_metadata_t {
    pub metadata_mask: u16,
    pub preferred_audio_contexts_mask: u16,
    pub streaming_audio_contexts_mask: u16,
    pub program_info_length: u8,
    pub program_info: [u8; 20usize],
    pub language_code: u32,
    pub ccids_num: u8,
    pub ccids: [u8; 10usize],
    pub parental_rating: le_audio_parental_rating_t,
    pub program_info_uri_length: u8,
    pub program_info_uri: [u8; 20usize],
    pub extended_metadata_type: u16,
    pub extended_metadata_length: u8,
    pub extended_metadata: [u8; 20usize],
    pub vendor_specific_company_id: u16,
    pub vendor_specific_metadata_length: u8,
    pub vendor_specific_metadata: [u8; 20usize],
}
extern "C" {
    pub fn le_audio_util_virtual_memcpy_helper(
        field_data: *const u8,
        field_len: u16,
        field_offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
        buffer_offset: u16,
    ) -> u16;
}
extern "C" {
    pub fn le_audio_util_metadata_virtual_memcpy(
        metadata: *const le_audio_metadata_t,
        metadata_length: u8,
        records_offset: *mut u16,
        buffer: *mut u8,
        buffer_size: u16,
        buffer_offset: u16,
    ) -> u16;
}
extern "C" {
    pub fn le_audio_util_metadata_parse(
        buffer: *mut u8,
        buffer_size: u8,
        metadata: *mut le_audio_metadata_t,
    ) -> u16;
}
extern "C" {
    pub fn le_audio_util_metadata_serialize(
        metadata: *mut le_audio_metadata_t,
        event: *mut u8,
        event_size: u16,
    ) -> u16;
}
impl aics_opcode_t {
    pub const AICS_OPCODE_SET_GAIN_SETTING: aics_opcode_t = aics_opcode_t(1);
}
impl aics_opcode_t {
    pub const AICS_OPCODE_UMUTE: aics_opcode_t = aics_opcode_t(2);
}
impl aics_opcode_t {
    pub const AICS_OPCODE_MUTE: aics_opcode_t = aics_opcode_t(3);
}
impl aics_opcode_t {
    pub const AICS_OPCODE_SET_MANUAL_GAIN_MODE: aics_opcode_t = aics_opcode_t(4);
}
impl aics_opcode_t {
    pub const AICS_OPCODE_SET_AUTOMATIC_GAIN_MODE: aics_opcode_t = aics_opcode_t(5);
}
impl ::core::ops::BitOr<aics_opcode_t> for aics_opcode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        aics_opcode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for aics_opcode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: aics_opcode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<aics_opcode_t> for aics_opcode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        aics_opcode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for aics_opcode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: aics_opcode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aics_opcode_t(pub cty::c_uint);
impl aics_mute_mode_t {
    pub const AICS_MUTE_MODE_NOT_MUTED: aics_mute_mode_t = aics_mute_mode_t(0);
}
impl aics_mute_mode_t {
    pub const AICS_MUTE_MODE_MUTED: aics_mute_mode_t = aics_mute_mode_t(1);
}
impl aics_mute_mode_t {
    pub const AICS_MUTE_MODE_DISABLED: aics_mute_mode_t = aics_mute_mode_t(2);
}
impl ::core::ops::BitOr<aics_mute_mode_t> for aics_mute_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        aics_mute_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for aics_mute_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: aics_mute_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<aics_mute_mode_t> for aics_mute_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        aics_mute_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for aics_mute_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: aics_mute_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aics_mute_mode_t(pub cty::c_uint);
impl aics_gain_mode_t {
    pub const AICS_GAIN_MODE_MANUAL_ONLY: aics_gain_mode_t = aics_gain_mode_t(0);
}
impl aics_gain_mode_t {
    pub const AICS_GAIN_MODE_AUTOMATIC_ONLY: aics_gain_mode_t = aics_gain_mode_t(1);
}
impl aics_gain_mode_t {
    pub const AICS_GAIN_MODE_MANUAL: aics_gain_mode_t = aics_gain_mode_t(2);
}
impl aics_gain_mode_t {
    pub const AICS_GAIN_MODE_AUTOMATIC: aics_gain_mode_t = aics_gain_mode_t(3);
}
impl ::core::ops::BitOr<aics_gain_mode_t> for aics_gain_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        aics_gain_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for aics_gain_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: aics_gain_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<aics_gain_mode_t> for aics_gain_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        aics_gain_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for aics_gain_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: aics_gain_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aics_gain_mode_t(pub cty::c_uint);
impl aics_audio_input_status_t {
    pub const AICS_AUDIO_INPUT_STATUS_INACTIVE: aics_audio_input_status_t =
        aics_audio_input_status_t(0);
}
impl aics_audio_input_status_t {
    pub const AICS_AUDIO_INPUT_STATUS_ACTIVE: aics_audio_input_status_t =
        aics_audio_input_status_t(1);
}
impl ::core::ops::BitOr<aics_audio_input_status_t> for aics_audio_input_status_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        aics_audio_input_status_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for aics_audio_input_status_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: aics_audio_input_status_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<aics_audio_input_status_t> for aics_audio_input_status_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        aics_audio_input_status_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for aics_audio_input_status_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: aics_audio_input_status_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aics_audio_input_status_t(pub cty::c_uint);
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_UNSPECIFIED: aics_audio_input_type_t =
        aics_audio_input_type_t(0);
}
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_BLUETOOTH_AUDIO_STREAM: aics_audio_input_type_t =
        aics_audio_input_type_t(1);
}
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_MICROPHONE: aics_audio_input_type_t =
        aics_audio_input_type_t(2);
}
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_ANALOG_INTERFACE: aics_audio_input_type_t =
        aics_audio_input_type_t(3);
}
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_DIGITAL_INTERFACE: aics_audio_input_type_t =
        aics_audio_input_type_t(4);
}
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_RADIO: aics_audio_input_type_t = aics_audio_input_type_t(5);
}
impl aics_audio_input_type_t {
    pub const AICS_AUDIO_INPUT_TYPE_STREAMING_AUDIO_SOURCE: aics_audio_input_type_t =
        aics_audio_input_type_t(6);
}
impl ::core::ops::BitOr<aics_audio_input_type_t> for aics_audio_input_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        aics_audio_input_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for aics_audio_input_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: aics_audio_input_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<aics_audio_input_type_t> for aics_audio_input_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        aics_audio_input_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for aics_audio_input_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: aics_audio_input_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aics_audio_input_type_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aics_audio_input_state_t {
    pub gain_setting_db: i8,
    pub mute_mode: aics_mute_mode_t,
    pub gain_mode: aics_gain_mode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aics_gain_settings_properties_t {
    pub gain_settings_units: u8,
    pub gain_settings_minimum: i8,
    pub gain_settings_maximum: i8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aics_info_t {
    pub audio_input_state: aics_audio_input_state_t,
    pub gain_settings_properties: aics_gain_settings_properties_t,
    pub audio_input_type: aics_audio_input_type_t,
    pub audio_input_description: [cty::c_char; 30usize],
    pub packet_handler: btstack_packet_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_input_control_service_server_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub index: u8,
    pub info: *mut aics_info_t,
    pub service_handler: att_service_handler_t,
    pub scheduled_tasks_callback: btstack_context_callback_registration_t,
    pub scheduled_tasks: u8,
    pub audio_input_state_value_handle: u16,
    pub audio_input_state_change_counter: u8,
    pub audio_input_state_client_configuration_handle: u16,
    pub audio_input_state_client_configuration: u16,
    pub audio_input_state_callback: btstack_context_callback_registration_t,
    pub gain_settings_properties_value_handle: u16,
    pub audio_input_type_value_handle: u16,
    pub audio_input_status_value_handle: u16,
    pub audio_input_status: aics_audio_input_status_t,
    pub audio_input_status_client_configuration_handle: u16,
    pub audio_input_status_client_configuration: u16,
    pub audio_input_status_callback: btstack_context_callback_registration_t,
    pub audio_input_control_value_handle: u16,
    pub audio_input_description_value_handle: u16,
    pub audio_input_description_len: u8,
    pub audio_input_description_client_configuration_handle: u16,
    pub audio_input_description_client_configuration: u16,
    pub audio_input_description_callback: btstack_context_callback_registration_t,
}
extern "C" {
    #[doc = " @brief Init Audio Input Control Service Server with ATT DB\n @param aics service storage"]
    pub fn audio_input_control_service_server_init(aics: *mut audio_input_control_service_server_t);
}
extern "C" {
    #[doc = " @brief Set audio input state of the AICS service. If successful, all registered clients will be notified of change.\n @param aics service\n @param audio_input_state see aics_audio_input_state_t\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_INVALID_HCI_COMMAND_PARAMETERS if gain setting is out of a valid range [gain_settings_minimum, gain_settings_maximum] ."]
    pub fn audio_input_control_service_server_set_audio_input_state(
        aics: *mut audio_input_control_service_server_t,
        audio_input_state: *mut aics_audio_input_state_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio input status of the AICS service. If successful, all registered clients will be notified of change.\n @param aics service\n @param audio_input_status see aics_audio_input_status_t"]
    pub fn audio_input_control_service_server_set_audio_input_status(
        aics: *mut audio_input_control_service_server_t,
        audio_input_status: aics_audio_input_status_t,
    );
}
extern "C" {
    #[doc = " @brief Set audio input description of the AICS service. If successful, all registered clients will be notified of change.\n @param aics service\n @param audio_input_desc"]
    pub fn audio_input_control_service_server_set_audio_input_description(
        aics: *mut audio_input_control_service_server_t,
        audio_input_desc: *const cty::c_char,
    );
}
impl bass_opcode_t {
    pub const BASS_OPCODE_REMOTE_SCAN_STOPPED: bass_opcode_t = bass_opcode_t(0);
}
impl bass_opcode_t {
    pub const BASS_OPCODE_REMOTE_SCAN_STARTED: bass_opcode_t = bass_opcode_t(1);
}
impl bass_opcode_t {
    pub const BASS_OPCODE_ADD_SOURCE: bass_opcode_t = bass_opcode_t(2);
}
impl bass_opcode_t {
    pub const BASS_OPCODE_MODIFY_SOURCE: bass_opcode_t = bass_opcode_t(3);
}
impl bass_opcode_t {
    pub const BASS_OPCODE_SET_BROADCAST_CODE: bass_opcode_t = bass_opcode_t(4);
}
impl bass_opcode_t {
    pub const BASS_OPCODE_REMOVE_SOURCE: bass_opcode_t = bass_opcode_t(5);
}
impl bass_opcode_t {
    pub const BASS_OPCODE_RFU: bass_opcode_t = bass_opcode_t(6);
}
impl ::core::ops::BitOr<bass_opcode_t> for bass_opcode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        bass_opcode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for bass_opcode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: bass_opcode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<bass_opcode_t> for bass_opcode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        bass_opcode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for bass_opcode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: bass_opcode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct bass_opcode_t(pub cty::c_uint);
impl bass_role_t {
    pub const BASS_ROLE_CLIENT: bass_role_t = bass_role_t(0);
}
impl bass_role_t {
    pub const BASS_ROLE_SERVER: bass_role_t = bass_role_t(1);
}
impl ::core::ops::BitOr<bass_role_t> for bass_role_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        bass_role_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for bass_role_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: bass_role_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<bass_role_t> for bass_role_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        bass_role_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for bass_role_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: bass_role_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct bass_role_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bass_subgroup_t {
    pub bis_sync: u32,
    pub bis_sync_state: u32,
    pub metadata_length: u8,
    pub metadata: le_audio_metadata_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bass_source_data_t {
    pub address_type: bd_addr_type_t,
    pub address: bd_addr_t,
    pub adv_sid: u8,
    pub broadcast_id: u32,
    pub pa_sync: le_audio_pa_sync_t,
    pub pa_sync_state: le_audio_pa_sync_state_t,
    pub pa_interval: u16,
    pub subgroups_num: u8,
    pub subgroups: [bass_subgroup_t; 10usize],
}
extern "C" {
    pub fn bass_util_source_data_header_virtual_memcpy(
        data: *const bass_source_data_t,
        source_offset: *mut u16,
        buffer_offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16;
}
extern "C" {
    pub fn bass_util_source_data_subgroups_virtual_memcpy(
        data: *const bass_source_data_t,
        use_state_fields: bool,
        source_offset: *mut u16,
        buffer_offset: u16,
        buffer: *mut u8,
        buffer_size: u16,
    ) -> u16;
}
extern "C" {
    pub fn bass_util_pa_sync_state_and_subgroups_in_valid_range(
        buffer: *mut u8,
        buffer_size: u16,
    ) -> bool;
}
extern "C" {
    pub fn bass_util_source_buffer_in_valid_range(buffer: *mut u8, buffer_size: u16) -> bool;
}
extern "C" {
    pub fn bass_util_source_data_parse(
        buffer: *mut u8,
        buffer_size: u16,
        source_data: *mut bass_source_data_t,
        is_broadcast_receive_state: bool,
    );
}
extern "C" {
    pub fn bass_util_pa_info_and_subgroups_parse(
        buffer: *mut u8,
        buffer_size: u16,
        source_data: *mut bass_source_data_t,
        is_broadcast_receive_state: bool,
    );
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_IDLE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(0);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W2_QUERY_SERVICE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(1);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W4_SERVICE_RESULT:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(2);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W2_QUERY_CHARACTERISTICS:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(3);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W4_CHARACTERISTIC_RESULT:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(4);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W2_QUERY_CHARACTERISTIC_DESCRIPTORS:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(5);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W4_CHARACTERISTIC_DESCRIPTORS_RESULT:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(6);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W2_REGISTER_NOTIFICATION:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(7);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_W4_NOTIFICATION_REGISTERED:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(8);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_STATE_CONNECTED:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(9);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_READ_CHARACTERISTIC_CONFIGURATION:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(10);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_CHARACTERISTIC_CONFIGURATION_RESULT:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(11);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_WRITE_CONTROL_POINT_START_SCAN:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(12);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_WRITE_CONTROL_POINT_START_SCAN:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(13);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_WRITE_CONTROL_POINT_STOP_SCAN:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(14);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_WRITE_CONTROL_POINT_STOP_SCAN:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(15);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_WRITE_CONTROL_POINT_ADD_SOURCE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(16);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_WRITE_CONTROL_POINT_ADD_SOURCE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(17);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_WRITE_CONTROL_POINT_MODIFY_SOURCE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(18);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_WRITE_CONTROL_POINT_MODIFY_SOURCE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(19);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_WRITE_CONTROL_POINT_SET_BROADCAST_CODE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(20);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_WRITE_CONTROL_POINT_SET_BROADCAST_CODE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(21);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_WRITE_CONTROL_POINT_REMOVE_SOURCE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(22);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_WRITE_CONTROL_POINT_REMOVE_SOURCE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(23);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W2_READE_RECEIVE_STATE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(24);
}
impl broadcast_audio_scan_service_client_state_t {
    pub const BROADCAST_AUDIO_SCAN_SERVICE_CLIENT_W4_READE_RECEIVE_STATE:
        broadcast_audio_scan_service_client_state_t =
        broadcast_audio_scan_service_client_state_t(25);
}
impl ::core::ops::BitOr<broadcast_audio_scan_service_client_state_t>
    for broadcast_audio_scan_service_client_state_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        broadcast_audio_scan_service_client_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for broadcast_audio_scan_service_client_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: broadcast_audio_scan_service_client_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<broadcast_audio_scan_service_client_state_t>
    for broadcast_audio_scan_service_client_state_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        broadcast_audio_scan_service_client_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for broadcast_audio_scan_service_client_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: broadcast_audio_scan_service_client_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct broadcast_audio_scan_service_client_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bass_client_source_t {
    pub data: bass_source_data_t,
    pub in_use: bool,
    pub source_id: u8,
    pub big_encryption: le_audio_big_encryption_t,
    pub bad_code: [u8; 16usize],
    pub receive_state_value_handle: u16,
    pub receive_state_ccc_handle: u16,
    pub receive_state_properties: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bass_client_connection_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub cid: u16,
    pub mtu: u16,
    pub state: broadcast_audio_scan_service_client_state_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub control_point_value_handle: u16,
    pub service_instances_num: u8,
    pub receive_states_instances_num: u8,
    pub receive_states_index: u8,
    pub max_receive_states_num: u8,
    pub receive_states: *mut bass_client_source_t,
    pub buffer: [u8; 512usize],
    pub buffer_offset: u16,
    pub data_size: u16,
    pub notification_listener: gatt_client_notification_t,
    pub control_point_operation_data: *const bass_source_data_t,
    pub control_point_operation_source_id: u8,
    pub broadcast_code: *const u8,
}
extern "C" {
    #[doc = " @brief Init Broadcast Audio Scan Service Client\n @param packet_handler for events"]
    pub fn broadcast_audio_scan_service_client_init(packet_handler: btstack_packet_handler_t);
}
extern "C" {
    #[doc = " @brief Connect to BASS Service on remote device\n @note GATTSERVICE_SUBEVENT_BASS_CONNECTED will be emitted\n @param connection struct provided by user, needs to stay valid until disconnect event is received\n @param sources buffer to store information on Broadcast Sources on the service\n @param num_sources\n @param con_handle to connect to\n @param bass_cid connection id for this connection for other functions\n @return status"]
    pub fn broadcast_audio_scan_service_client_connect(
        connection: *mut bass_client_connection_t,
        sources: *mut bass_client_source_t,
        num_sources: u8,
        con_handle: hci_con_handle_t,
        bass_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Notify BASS Service that scanning has started\n @param bass_cid\n @return status"]
    pub fn broadcast_audio_scan_service_client_scanning_started(bass_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Notify BASS Service that scanning has stopped\n @note emits GATTSERVICE_SUBEVENT_BASS_SOURCE_OPERATION_COMPLETE\n @param bass_cid\n @return status"]
    pub fn broadcast_audio_scan_service_client_scanning_stopped(bass_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Add Broadcast Source on service\n @note GATTSERVICE_SUBEVENT_BASS_NOTIFICATION_COMPLETE will contain source_id for other functions\n @param bass_cid\n @param add_source_data data to add, needs to stay valid until GATTSERVICE_SUBEVENT_BASS_SOURCE_OPERATION_COMPLETE\n @return status"]
    pub fn broadcast_audio_scan_service_client_add_source(
        bass_cid: u16,
        add_source_data: *const bass_source_data_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Modify information about Broadcast Source on service\n @param bass_cid\n @param source_id\n @param modify_source_data data to modify, needs to stay valid until GATTSERVICE_SUBEVENT_BASS_SOURCE_OPERATION_COMPLETE\n @return status"]
    pub fn broadcast_audio_scan_service_client_modify_source(
        bass_cid: u16,
        source_id: u8,
        modify_source_data: *const bass_source_data_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set Broadcast Code for a Broadcast Source to allow remote do decrypt audio stream\n @param bass_cid\n @param source_id\n @param broadcast_code\n @return status"]
    pub fn broadcast_audio_scan_service_client_set_broadcast_code(
        bass_cid: u16,
        source_id: u8,
        broadcast_code: *const u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Remove information about Broadcast Source\n @param bass_cid\n @param source_id\n @return status"]
    pub fn broadcast_audio_scan_service_client_remove_source(bass_cid: u16, source_id: u8) -> u8;
}
extern "C" {
    #[doc = " @param Provide read-only access to Broadcast Receive State of given Broadcast Source on service\n @param bass_cid\n @param source_id\n @return pointer to source data or NULL, if source_id not found"]
    pub fn broadcast_audio_scan_service_client_get_source_data(
        bass_cid: u16,
        source_id: u8,
    ) -> *const bass_source_data_t;
}
extern "C" {
    #[doc = " @param Get BIG Encryption and Bad Code from Broadcast Receive State of given Broadcast Source on service\n @param bass_cid\n @param source_id\n @param out_big_encryption\n @param out_bad_code 16-byte buffer\n @return status"]
    pub fn broadcast_audio_scan_service_client_get_encryption_state(
        bass_cid: u16,
        source_id: u8,
        out_big_encryption: *mut le_audio_big_encryption_t,
        out_bad_code: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Deinit Broadcast Audio Scan Service Client"]
    pub fn broadcast_audio_scan_service_client_deinit(bass_cid: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bass_server_source_t {
    pub data: bass_source_data_t,
    pub update_counter: u8,
    pub source_id: u8,
    pub in_use: bool,
    pub big_encryption: le_audio_big_encryption_t,
    pub bad_code: [u8; 16usize],
    pub bass_receive_state_handle: u16,
    pub bass_receive_state_client_configuration_handle: u16,
    pub bass_receive_state_client_configuration: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bass_remote_client_t {
    pub con_handle: hci_con_handle_t,
    pub sources_to_notify: u16,
    pub long_write_buffer: [u8; 512usize],
    pub long_write_value_size: u16,
    pub long_write_attribute_handle: u16,
}
extern "C" {
    #[doc = " @brief Init Broadcast Audio Scan Service Server with ATT DB\n @param sources_num\n @param sources\n @param clients_num\n @param clients"]
    pub fn broadcast_audio_scan_service_server_init(
        sources_num: u8,
        sources: *mut bass_server_source_t,
        clients_num: u8,
        clients: *mut bass_remote_client_t,
    );
}
extern "C" {
    #[doc = " @brief Register callback.\n @param callback"]
    pub fn broadcast_audio_scan_service_server_register_packet_handler(
        callback: btstack_packet_handler_t,
    );
}
extern "C" {
    #[doc = " @brief Set PA state of source.\n @param source_index\n @param sync_state"]
    pub fn broadcast_audio_scan_service_server_set_pa_sync_state(
        source_index: u8,
        sync_state: le_audio_pa_sync_state_t,
    );
}
extern "C" {
    #[doc = " @brief Register callback.\n @param source_data\n @param source_index"]
    pub fn broadcast_audio_scan_service_server_add_source(
        source_data: bass_source_data_t,
        source_index: *mut u8,
    );
}
extern "C" {
    #[doc = " @brief Deinit Broadcast Audio Scan Service Server"]
    pub fn broadcast_audio_scan_service_server_deinit();
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_IDLE: microphone_service_client_state_t =
        microphone_service_client_state_t(0);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_W2_QUERY_SERVICE:
        microphone_service_client_state_t = microphone_service_client_state_t(1);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_W4_SERVICE_RESULT:
        microphone_service_client_state_t = microphone_service_client_state_t(2);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_W2_QUERY_CHARACTERISTICS:
        microphone_service_client_state_t = microphone_service_client_state_t(3);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_W4_CHARACTERISTIC_RESULT:
        microphone_service_client_state_t = microphone_service_client_state_t(4);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_W2_REGISTER_NOTIFICATION:
        microphone_service_client_state_t = microphone_service_client_state_t(5);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_W4_NOTIFICATION_REGISTERED:
        microphone_service_client_state_t = microphone_service_client_state_t(6);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_STATE_CONNECTED: microphone_service_client_state_t =
        microphone_service_client_state_t(7);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_W2_WRITE_MUTE: microphone_service_client_state_t =
        microphone_service_client_state_t(8);
}
impl microphone_service_client_state_t {
    pub const MICROPHONE_CONTROL_SERVICE_CLIENT_W4_WRITE_MUTE_RESULT:
        microphone_service_client_state_t = microphone_service_client_state_t(9);
}
impl ::core::ops::BitOr<microphone_service_client_state_t> for microphone_service_client_state_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        microphone_service_client_state_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for microphone_service_client_state_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: microphone_service_client_state_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<microphone_service_client_state_t> for microphone_service_client_state_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        microphone_service_client_state_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for microphone_service_client_state_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: microphone_service_client_state_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @text The Microphone Control Service Client connects to the Microphone Control Services of a remote device\n and it can query or set mute value if mute value on the remote side is enabled. The Mute updates are received via notifications."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct microphone_service_client_state_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct microphone_service_t {
    pub start_handle: u16,
    pub end_handle: u16,
    pub properties: u16,
    pub value_handle: u16,
    pub notification_listener: gatt_client_notification_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct microphone_control_service_client_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub cid: u16,
    pub state: microphone_service_client_state_t,
    pub client_handler: btstack_packet_handler_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub properties: u16,
    pub mute_value_handle: u16,
    pub need_polling: bool,
    pub num_instances: u16,
    pub requested_mute: u8,
    pub notification_listener: gatt_client_notification_t,
}
extern "C" {
    #[doc = " @brief Initialize Microphone Control Service."]
    pub fn microphone_control_service_client_init();
}
extern "C" {
    #[doc = " @brief Connect to Microphone Control Services of remote device. The client will automatically register for notifications.\n The mute state is received via GATTSERVICE_SUBEVENT_MICROPHONE_CONTROL_SERVICE_MUTE event.\n The mute state can be 0 - off, 1 - on, 2 - disabeled and it is valid if the ATTT status is equal to ATT_ERROR_SUCCESS,\n see ATT errors (see bluetooth.h) for other values.\n\n Event GATTSERVICE_SUBEVENT_MICROPHONE_CONTROL_SERVICE_CONNECTED is emitted with status ERROR_CODE_SUCCESS on success, otherwise\n GATT_CLIENT_IN_WRONG_STATE, ERROR_CODE_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE if no microphone control service is found, or ATT errors (see bluetooth.h).\n\n @param con_handle\n @param packet_handler\n @param mics_cid\n @return status ERROR_CODE_SUCCESS on success, otherwise ERROR_CODE_COMMAND_DISALLOWED if there is already a client associated with con_handle, or BTSTACK_MEMORY_ALLOC_FAILED"]
    pub fn microphone_control_service_client_connect(
        con_handle: hci_con_handle_t,
        packet_handler: btstack_packet_handler_t,
        mics_cid: *mut u16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Read mute state. The mute state is received via GATTSERVICE_SUBEVENT_MICROPHONE_CONTROL_SERVICE_MUTE event.\n @param mics_cid\n @return status"]
    pub fn microphone_control_service_client_read_mute_state(mics_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Turn on mute.\n @param mics_cid\n @return status"]
    pub fn microphone_control_service_client_mute_turn_on(mics_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Turn off mute.\n @param mics_cid\n @return status"]
    pub fn microphone_control_service_client_mute_turn_off(mics_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief Disconnect.\n @param mics_cid\n @return status"]
    pub fn microphone_control_service_client_disconnect(mics_cid: u16) -> u8;
}
extern "C" {
    #[doc = " @brief De-initialize Microphone Control Service."]
    pub fn microphone_control_service_client_deinit();
}
extern "C" {
    #[doc = " @brief Init Microphone Control Service Server with ATT DB\n @param mute_state"]
    pub fn microphone_control_service_server_init(
        mute_state: gatt_microphone_control_mute_t,
        aics_info_num: u8,
        aics_info: *mut aics_info_t,
    );
}
extern "C" {
    #[doc = " @brief Register callback to receive updates of mute value from remote side via MICS_MUTE event\n @param callback"]
    pub fn microphone_control_service_server_register_packet_handler(
        callback: btstack_packet_handler_t,
    );
}
extern "C" {
    #[doc = " @brief Set mute value.\n @param mute_state"]
    pub fn microphone_control_service_server_set_mute(mute_state: gatt_microphone_control_mute_t);
}
extern "C" {
    #[doc = " @brief Set mute and gain mode, as well as gain setting of the AICS service identified by aics_index.\n @param aics_index\n @param audio_input_state see aics_audio_input_state_t in audio_input_control_service_server.h\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range, or ERROR_CODE_INVALID_HCI_COMMAND_PARAMETERS if gain setting is out of valid range."]
    pub fn microphone_control_service_server_set_audio_input_state_for_aics(
        aics_index: u8,
        audio_input_state: *mut aics_audio_input_state_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio input description of the AICS service identified by aics_index.\n @param aics_index\n @param audio_input_state see aics_audio_input_state_t in audio_input_control_service_server.h\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn microphone_control_service_server_set_audio_input_description_for_aics(
        aics_index: u8,
        audio_input_desc: *const cty::c_char,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio input status of the AICS service identified by aics_index.\n @param aics_index\n @param audio_input_status see aics_audio_input_status_t in audio_input_control_service_server.h\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn microphone_control_service_server_set_audio_input_status_for_aics(
        aics_index: u8,
        audio_input_status: aics_audio_input_status_t,
    ) -> u8;
}
impl vocs_opcode_t {
    pub const VOCS_OPCODE_SET_VOLUME_OFFSET: vocs_opcode_t = vocs_opcode_t(1);
}
impl ::core::ops::BitOr<vocs_opcode_t> for vocs_opcode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        vocs_opcode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for vocs_opcode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: vocs_opcode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<vocs_opcode_t> for vocs_opcode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        vocs_opcode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for vocs_opcode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: vocs_opcode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct vocs_opcode_t(pub cty::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vocs_info_t {
    pub volume_offset: i16,
    pub audio_location: u32,
    pub audio_output_description: [cty::c_char; 30usize],
    pub packet_handler: btstack_packet_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct volume_offset_control_service_server_t {
    pub item: btstack_linked_item_t,
    pub con_handle: hci_con_handle_t,
    pub start_handle: u16,
    pub end_handle: u16,
    pub index: u8,
    pub info: *mut vocs_info_t,
    pub service_handler: att_service_handler_t,
    pub scheduled_tasks_callback: btstack_context_callback_registration_t,
    pub scheduled_tasks: u8,
    pub volume_offset_state_value_handle: u16,
    pub volume_offset_state_change_counter: u8,
    pub volume_offset_state_client_configuration_handle: u16,
    pub volume_offset_state_client_configuration: u16,
    pub volume_offset_state_callback: btstack_context_callback_registration_t,
    pub audio_location_value_handle: u16,
    pub audio_location_client_configuration_handle: u16,
    pub audio_location_client_configuration: u16,
    pub audio_location_callback: btstack_context_callback_registration_t,
    pub volume_offset_control_point_value_handle: u16,
    pub audio_output_description_value_handle: u16,
    pub audio_output_description_len: u8,
    pub audio_output_description_client_configuration_handle: u16,
    pub audio_output_description_client_configuration: u16,
    pub audio_output_description_callback: btstack_context_callback_registration_t,
}
extern "C" {
    #[doc = " @brief Init Volume Offset Control Service Server with ATT DB\n @param vocs service storage"]
    pub fn volume_offset_control_service_server_init(
        vocs: *mut volume_offset_control_service_server_t,
    );
}
extern "C" {
    #[doc = " @brief Set volume offset of the VOCS service. If successful, all registered clients will be notified of change.\n @param vocs service\n @param volume_offset\n @return status ERROR_CODE_SUCCESS if successful"]
    pub fn volume_offset_control_service_server_set_volume_offset(
        vocs: *mut volume_offset_control_service_server_t,
        volume_offset: i16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio location of the VOCS service. If successful, all registered clients will be notified of change.\n @param vocs service\n @param audio_location see VOCS_AUDIO_LOCATION_* defines above\n @return status ERROR_CODE_SUCCESS if successful"]
    pub fn volume_offset_control_service_server_set_audio_location(
        vocs: *mut volume_offset_control_service_server_t,
        audio_location: u32,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio output description of the VOCS service. If successful, all registered clients will be notified of change.\n @param vocs service\n @param audio_output_desc\n @return status ERROR_CODE_SUCCESS if successful"]
    pub fn volume_offset_control_service_server_set_audio_output_description(
        vocs: *mut volume_offset_control_service_server_t,
        audio_output_desc: *const cty::c_char,
    );
}
impl vcs_mute_t {
    pub const VCS_MUTE_OFF: vcs_mute_t = vcs_mute_t(0);
}
impl vcs_mute_t {
    pub const VCS_MUTE_ON: vcs_mute_t = vcs_mute_t(1);
}
impl ::core::ops::BitOr<vcs_mute_t> for vcs_mute_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        vcs_mute_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for vcs_mute_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: vcs_mute_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<vcs_mute_t> for vcs_mute_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        vcs_mute_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for vcs_mute_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: vcs_mute_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct vcs_mute_t(pub cty::c_uint);
extern "C" {
    #[doc = " @brief Init Volume Control Service Server with ATT DB\n @param volume_setting        range [0,255]\n @param mute                  see vcs_mute_t\n @param volume_change_step\n @param aics_info_num\n @param aics_info\n @param vocs_info_num\n @param vocs_info"]
    pub fn volume_control_service_server_init(
        volume_setting: u8,
        mute: vcs_mute_t,
        aics_info_num: u8,
        aics_info: *mut aics_info_t,
        vocs_info_num: u8,
        vocs_info: *mut vocs_info_t,
    );
}
extern "C" {
    #[doc = " @brief Register callback to receive updates of volume state and volume flags GATTSERVICE_SUBEVENT_VCS_VOLUME_STATE and GATTSERVICE_SUBEVENT_VCS_VOLUME_FLAGS events respectively.\n @param callback"]
    pub fn volume_control_service_server_register_packet_handler(
        callback: btstack_packet_handler_t,
    );
}
extern "C" {
    #[doc = " @brief Set volume state.\n @param volume_setting        range [0,255]\n @param mute                  see vcs_mute_t"]
    pub fn volume_control_service_server_set_volume_state(volume_setting: u8, mute: vcs_mute_t);
}
extern "C" {
    #[doc = " @brief Set volume change step.\n @param volume_change_step"]
    pub fn volume_control_service_server_set_volume_change_step(volume_change_step: u8);
}
extern "C" {
    #[doc = " @brief Set mute and gain mode, as well as gain setting of the AICS service identified by aics_index.\n @param aics_index\n @param audio_input_state see aics_audio_input_state_t in audio_input_control_service_server.h\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range, or ERROR_CODE_INVALID_HCI_COMMAND_PARAMETERS if gain setting is out of valid range."]
    pub fn volume_control_service_server_set_audio_input_state_for_aics(
        aics_index: u8,
        audio_input_state: *mut aics_audio_input_state_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio input description of the AICS service identified by aics_index.\n @param aics_index\n @param audio_input_state see aics_audio_input_state_t in audio_input_control_service_server.h\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn volume_control_service_server_set_audio_input_description_for_aics(
        aics_index: u8,
        audio_input_desc: *const cty::c_char,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio input status of the AICS service identified by aics_index.\n @param aics_index\n @param audio_input_status see aics_audio_input_status_t in audio_input_control_service_server.h\n @return status ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn volume_control_service_server_set_audio_input_status_for_aics(
        aics_index: u8,
        audio_input_status: aics_audio_input_status_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set volume offset location of the VOCS service. If successful, all registered clients will be notified of change.\n @param vocs service\n @param volume_offset\n @return ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn volume_control_service_server_set_volume_offset_for_vocs(
        vocs_index: u8,
        volume_offset: i16,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio location of the VOCS service. If successful, all registered clients will be notified of change.\n @param vocs service\n @param audio_location see VOCS_AUDIO_LOCATION_* defines in volume_offset_control_service_server.h\n @return ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn volume_control_service_server_set_audio_location_for_vocs(
        vocs_index: u8,
        audio_location: u32,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Set audio output description of the VOCS service. If successful, all registered clients will be notified of change.\n @param vocs service\n @param audio_output_desc\n @return ERROR_CODE_SUCCESS if successful, otherwise ERROR_CODE_UNKNOWN_CONNECTION_IDENTIFIER if aics_index is out of range."]
    pub fn volume_control_service_server_set_audio_output_description_for_vocs(
        vocs_index: u8,
        audio_output_desc: *const cty::c_char,
    ) -> u8;
}
pub type uint = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absolute_time_t {
    pub _private_us_since_boot: u64,
}
#[doc = " \\struct datetime_t\n  \\ingroup util_datetime\n  \\brief Structure containing date and time information\n\n    When setting an RTC alarm, set a field to -1 tells\n    the RTC to not match on this field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct datetime_t {
    #[doc = "< 0..4095"]
    pub year: i16,
    #[doc = "< 1..12, 1 is January"]
    pub month: i8,
    #[doc = "< 1..28,29,30,31 depending on month"]
    pub day: i8,
    #[doc = "< 0..6, 0 is Sunday"]
    pub dotw: i8,
    #[doc = "< 0..23"]
    pub hour: i8,
    #[doc = "< 0..59"]
    pub min: i8,
    #[doc = "< 0..59"]
    pub sec: i8,
}
extern "C" {
    #[doc = " \\brief Panics with the message \"Unsupported\"\n  \\ingroup pico_platform\n  \\see panic"]
    pub fn panic_unsupported() -> !;
}
extern "C" {
    #[doc = " \\brief Displays a panic message and halts execution\n  \\ingroup pico_platform\n\n An attempt is made to output the message to all registered STDOUT drivers\n after which this method executes a BKPT instruction.\n\n @param fmt format string (printf-like)\n @param ...  printf-like arguments"]
    pub fn panic(fmt: *const cty::c_char, ...) -> !;
}
extern "C" {
    pub fn running_on_fpga() -> bool;
}
extern "C" {
    #[doc = " \\brief Returns the RP2040 chip revision number\n  \\ingroup pico_platform\n @return the RP2040 chip revision number (1 for B0/B1, 2 for B2)"]
    pub fn rp2040_chip_version() -> u8;
}
impl pico_error_codes {
    pub const PICO_OK: pico_error_codes = pico_error_codes(0);
}
impl pico_error_codes {
    pub const PICO_ERROR_NONE: pico_error_codes = pico_error_codes(0);
}
impl pico_error_codes {
    pub const PICO_ERROR_TIMEOUT: pico_error_codes = pico_error_codes(-1);
}
impl pico_error_codes {
    pub const PICO_ERROR_GENERIC: pico_error_codes = pico_error_codes(-2);
}
impl pico_error_codes {
    pub const PICO_ERROR_NO_DATA: pico_error_codes = pico_error_codes(-3);
}
impl pico_error_codes {
    pub const PICO_ERROR_NOT_PERMITTED: pico_error_codes = pico_error_codes(-4);
}
impl pico_error_codes {
    pub const PICO_ERROR_INVALID_ARG: pico_error_codes = pico_error_codes(-5);
}
impl pico_error_codes {
    pub const PICO_ERROR_IO: pico_error_codes = pico_error_codes(-6);
}
impl pico_error_codes {
    pub const PICO_ERROR_BADAUTH: pico_error_codes = pico_error_codes(-7);
}
impl pico_error_codes {
    pub const PICO_ERROR_CONNECT_FAILED: pico_error_codes = pico_error_codes(-8);
}
impl ::core::ops::BitOr<pico_error_codes> for pico_error_codes {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        pico_error_codes(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for pico_error_codes {
    #[inline]
    fn bitor_assign(&mut self, rhs: pico_error_codes) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<pico_error_codes> for pico_error_codes {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        pico_error_codes(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for pico_error_codes {
    #[inline]
    fn bitand_assign(&mut self, rhs: pico_error_codes) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief Common return codes from pico_sdk methods that return a status\n \\ingroup pico_base"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct pico_error_codes(pub cty::c_int);
pub type io_rw_32 = u32;
pub type io_ro_32 = u32;
pub type io_wo_32 = u32;
pub type io_rw_16 = u16;
pub type io_ro_16 = u16;
pub type io_wo_16 = u16;
pub type io_rw_8 = u8;
pub type io_ro_8 = u8;
pub type io_wo_8 = u8;
pub type ioptr = *mut u8;
pub type const_ioptr = ioptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct interp_hw_t {
    pub accum: [io_rw_32; 2usize],
    pub base: [io_rw_32; 3usize],
    pub pop: [io_ro_32; 3usize],
    pub peek: [io_ro_32; 3usize],
    pub ctrl: [io_rw_32; 2usize],
    pub add_raw: [io_rw_32; 2usize],
    pub base01: io_wo_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sio_hw_t {
    pub cpuid: io_ro_32,
    pub gpio_in: io_ro_32,
    pub gpio_hi_in: io_ro_32,
    pub _pad0: u32,
    pub gpio_out: io_rw_32,
    pub gpio_set: io_wo_32,
    pub gpio_clr: io_wo_32,
    pub gpio_togl: io_wo_32,
    pub gpio_oe: io_rw_32,
    pub gpio_oe_set: io_wo_32,
    pub gpio_oe_clr: io_wo_32,
    pub gpio_oe_togl: io_wo_32,
    pub gpio_hi_out: io_rw_32,
    pub gpio_hi_set: io_wo_32,
    pub gpio_hi_clr: io_wo_32,
    pub gpio_hi_togl: io_wo_32,
    pub gpio_hi_oe: io_rw_32,
    pub gpio_hi_oe_set: io_wo_32,
    pub gpio_hi_oe_clr: io_wo_32,
    pub gpio_hi_oe_togl: io_wo_32,
    pub fifo_st: io_rw_32,
    pub fifo_wr: io_wo_32,
    pub fifo_rd: io_ro_32,
    pub spinlock_st: io_ro_32,
    pub div_udividend: io_rw_32,
    pub div_udivisor: io_rw_32,
    pub div_sdividend: io_rw_32,
    pub div_sdivisor: io_rw_32,
    pub div_quotient: io_rw_32,
    pub div_remainder: io_rw_32,
    pub div_csr: io_ro_32,
    pub _pad1: u32,
    pub interp: [interp_hw_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct padsbank0_hw_t {
    pub voltage_select: io_rw_32,
    pub io: [io_rw_32; 30usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iobank0_status_ctrl_hw_t {
    pub status: io_ro_32,
    pub ctrl: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_irq_ctrl_hw_t {
    pub inte: [io_rw_32; 4usize],
    pub intf: [io_rw_32; 4usize],
    pub ints: [io_ro_32; 4usize],
}
#[doc = " \\tag::iobank0_hw[]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iobank0_hw_t {
    pub io: [iobank0_status_ctrl_hw_t; 30usize],
    pub intr: [io_rw_32; 4usize],
    pub proc0_irq_ctrl: io_irq_ctrl_hw_t,
    pub proc1_irq_ctrl: io_irq_ctrl_hw_t,
    pub dormant_wake_irq_ctrl: io_irq_ctrl_hw_t,
}
#[doc = " \\brief Interrupt handler function type\n  \\ingroup hardware_irq\n\n All interrupts handlers should be of this type, and follow normal ARM EABI register saving conventions"]
pub type irq_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Set specified interrupt's priority\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param hardware_priority Priority to set.\n Numerically-lower values indicate a higher priority. Hardware priorities\n range from 0 (highest priority) to 255 (lowest priority) though only the\n top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify\n higher or lower priorities than the default, all IRQ priorities are\n initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup.\n PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80"]
    pub fn irq_set_priority(num: uint, hardware_priority: u8);
}
extern "C" {
    #[doc = " \\brief Get specified interrupt's priority\n  \\ingroup hardware_irq\n\n Numerically-lower values indicate a higher priority. Hardware priorities\n range from 0 (highest priority) to 255 (lowest priority) though only the\n top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify\n higher or lower priorities than the default, all IRQ priorities are\n initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup.\n PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return the IRQ priority"]
    pub fn irq_get_priority(num: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief Enable or disable a specific interrupt on the executing core\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param enabled true to enable the interrupt, false to disable"]
    pub fn irq_set_enabled(num: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Determine if a specific interrupt is enabled on the executing core\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return true if the interrupt is enabled"]
    pub fn irq_is_enabled(num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Enable/disable multiple interrupts on the executing core\n  \\ingroup hardware_irq\n\n \\param mask 32-bit mask with one bits set for the interrupts to enable/disable \\ref interrupt_nums\n \\param enabled true to enable the interrupts, false to disable them."]
    pub fn irq_set_mask_enabled(mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief  Set an exclusive interrupt handler for an interrupt on the executing core.\n  \\ingroup hardware_irq\n\n Use this method to set a handler for single IRQ source interrupts, or when\n your code, use case or performance requirements dictate that there should\n no other handlers for the interrupt.\n\n This method will assert if there is already any sort of interrupt handler installed\n for the specified irq number.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param handler The handler to set. See \\ref irq_handler_t\n \\see irq_add_shared_handler()"]
    pub fn irq_set_exclusive_handler(num: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief  Get the exclusive interrupt handler for an interrupt on the executing core.\n  \\ingroup hardware_irq\n\n This method will return an exclusive IRQ handler set on this core\n by irq_set_exclusive_handler if there is one.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\see irq_set_exclusive_handler()\n \\return handler The handler if an exclusive handler is set for the IRQ,\n                 NULL if no handler is set or shared/shareable handlers are installed"]
    pub fn irq_get_exclusive_handler(num: uint) -> irq_handler_t;
}
extern "C" {
    #[doc = " \\brief Add a shared interrupt handler for an interrupt on the executing core\n  \\ingroup hardware_irq\n\n Use this method to add a handler on an irq number shared between multiple distinct hardware sources (e.g. GPIO, DMA or PIO IRQs).\n Handlers added by this method will all be called in sequence from highest order_priority to lowest. The\n irq_set_exclusive_handler() method should be used instead if you know there will or should only ever be one handler for the interrupt.\n\n This method will assert if there is an exclusive interrupt handler set for this irq number on this core, or if\n the (total across all IRQs on both cores) maximum (configurable via PICO_MAX_SHARED_IRQ_HANDLERS) number of shared handlers\n would be exceeded.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param handler The handler to set. See \\ref irq_handler_t\n \\param order_priority The order priority controls the order that handlers for the same IRQ number on the core are called.\n The shared irq handlers for an interrupt are all called when an IRQ fires, however the order of the calls is based\n on the order_priority (higher priorities are called first, identical priorities are called in undefined order). A good\n rule of thumb is to use PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY if you don't much care, as it is in the middle of\n the priority range by default.\n\n \\note The order_priority uses \\em higher values for higher priorities which is the \\em opposite of the CPU interrupt priorities passed\n to irq_set_priority() which use lower values for higher priorities.\n\n \\see irq_set_exclusive_handler()"]
    pub fn irq_add_shared_handler(num: uint, handler: irq_handler_t, order_priority: u8);
}
extern "C" {
    #[doc = " \\brief Remove a specific interrupt handler for the given irq number on the executing core\n  \\ingroup hardware_irq\n\n This method may be used to remove an irq set via either irq_set_exclusive_handler() or\n irq_add_shared_handler(), and will assert if the handler is not currently installed for the given\n IRQ number\n\n \\note This method may *only* be called from user (non IRQ code) or from within the handler\n itself (i.e. an IRQ handler may remove itself as part of handling the IRQ). Attempts to call\n from another IRQ will cause an assertion.\n\n \\param num Interrupt number \\ref interrupt_nums\n \\param handler The handler to removed.\n \\see irq_set_exclusive_handler()\n \\see irq_add_shared_handler()"]
    pub fn irq_remove_handler(num: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Determine if the current handler for the given number is shared\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return true if the specified IRQ has a shared handler"]
    pub fn irq_has_shared_handler(num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Get the current IRQ handler for the specified IRQ from the currently installed hardware vector table (VTOR)\n of the execution core\n  \\ingroup hardware_irq\n\n \\param num Interrupt number \\ref interrupt_nums\n \\return the address stored in the VTABLE for the given irq number"]
    pub fn irq_get_vtable_handler(num: uint) -> irq_handler_t;
}
extern "C" {
    #[doc = " \\brief Force an interrupt to be pending on the executing core\n  \\ingroup hardware_irq\n\n This should generally not be used for IRQs connected to hardware.\n\n \\param num Interrupt number \\ref interrupt_nums"]
    pub fn irq_set_pending(num: uint);
}
extern "C" {
    #[doc = " \\brief Perform IRQ priority initialization for the current core\n\n \\note This is an internal method and user should generally not call it."]
    pub fn irq_init_priorities();
}
extern "C" {
    #[doc = " \\brief Claim ownership of a user IRQ on the calling core\n  \\ingroup hardware_irq\n\n User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by \\ref irq_set_pending.\n\n \\note User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions\n dealing with Uer IRQs affect only the calling core\n\n This method explicitly claims ownership of a user IRQ, so other code can know it is being used.\n\n \\param irq_num the user IRQ to claim"]
    pub fn user_irq_claim(irq_num: uint);
}
extern "C" {
    #[doc = " \\brief Mark a user IRQ as no longer used on the calling core\n  \\ingroup hardware_irq\n\n User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by \\ref irq_set_pending.\n\n \\note User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions\n dealing with Uer IRQs affect only the calling core\n\n This method explicitly releases ownership of a user IRQ, so other code can know it is free to use.\n\n \\note it is customary to have disabled the irq and removed the handler prior to calling this method.\n\n \\param irq_num the irq irq_num to unclaim"]
    pub fn user_irq_unclaim(irq_num: uint);
}
extern "C" {
    #[doc = " \\brief Claim ownership of a free user IRQ on the calling core\n  \\ingroup hardware_irq\n\n User IRQs are numbered 26-31 and are not connected to any hardware, but can be triggered by \\ref irq_set_pending.\n\n \\note User IRQs are a core local feature; they cannot be used to communicate between cores. Therfore all functions\n dealing with Uer IRQs affect only the calling core\n\n This method explicitly claims ownership of an unused user IRQ if there is one, so other code can know it is being used.\n\n \\param required if true the function will panic if none are available\n \\return the user IRQ number or -1 if required was false, and none were free"]
    pub fn user_irq_claim_unused(required: bool) -> cty::c_int;
}
extern "C" {
    pub fn user_irq_is_claimed(irq_num: uint) -> bool;
}
impl gpio_function {
    pub const GPIO_FUNC_XIP: gpio_function = gpio_function(0);
}
impl gpio_function {
    pub const GPIO_FUNC_SPI: gpio_function = gpio_function(1);
}
impl gpio_function {
    pub const GPIO_FUNC_UART: gpio_function = gpio_function(2);
}
impl gpio_function {
    pub const GPIO_FUNC_I2C: gpio_function = gpio_function(3);
}
impl gpio_function {
    pub const GPIO_FUNC_PWM: gpio_function = gpio_function(4);
}
impl gpio_function {
    pub const GPIO_FUNC_SIO: gpio_function = gpio_function(5);
}
impl gpio_function {
    pub const GPIO_FUNC_PIO0: gpio_function = gpio_function(6);
}
impl gpio_function {
    pub const GPIO_FUNC_PIO1: gpio_function = gpio_function(7);
}
impl gpio_function {
    pub const GPIO_FUNC_GPCK: gpio_function = gpio_function(8);
}
impl gpio_function {
    pub const GPIO_FUNC_USB: gpio_function = gpio_function(9);
}
impl gpio_function {
    pub const GPIO_FUNC_NULL: gpio_function = gpio_function(31);
}
impl ::core::ops::BitOr<gpio_function> for gpio_function {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpio_function(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpio_function {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpio_function) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpio_function> for gpio_function {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpio_function(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpio_function {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpio_function) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief  GPIO function definitions for use with function select\n  \\ingroup hardware_gpio\n \\brief GPIO function selectors\n\n Each GPIO can have one function selected at a time. Likewise, each peripheral input (e.g. UART0 RX) should only be\n selected on one GPIO at a time. If the same peripheral input is connected to multiple GPIOs, the peripheral sees the logical\n OR of these GPIO inputs.\n\n Please refer to the datasheet for more information on GPIO function selection."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gpio_function(pub cty::c_uint);
impl gpio_irq_level {
    pub const GPIO_IRQ_LEVEL_LOW: gpio_irq_level = gpio_irq_level(1);
}
impl gpio_irq_level {
    pub const GPIO_IRQ_LEVEL_HIGH: gpio_irq_level = gpio_irq_level(2);
}
impl gpio_irq_level {
    pub const GPIO_IRQ_EDGE_FALL: gpio_irq_level = gpio_irq_level(4);
}
impl gpio_irq_level {
    pub const GPIO_IRQ_EDGE_RISE: gpio_irq_level = gpio_irq_level(8);
}
impl ::core::ops::BitOr<gpio_irq_level> for gpio_irq_level {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpio_irq_level(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpio_irq_level {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpio_irq_level) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpio_irq_level> for gpio_irq_level {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpio_irq_level(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpio_irq_level {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpio_irq_level) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief  GPIO Interrupt level definitions (GPIO events)\n  \\ingroup hardware_gpio\n  \\brief GPIO Interrupt levels\n\n An interrupt can be generated for every GPIO pin in 4 scenarios:\n\n * Level High: the GPIO pin is a logical 1\n * Level Low: the GPIO pin is a logical 0\n * Edge High: the GPIO has transitioned from a logical 0 to a logical 1\n * Edge Low: the GPIO has transitioned from a logical 1 to a logical 0\n\n The level interrupts are not latched. This means that if the pin is a logical 1 and the level high interrupt is active, it will\n become inactive as soon as the pin changes to a logical 0. The edge interrupts are stored in the INTR register and can be\n cleared by writing to the INTR register."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gpio_irq_level(pub cty::c_uint);
#[doc = " Callback function type for GPIO events\n  \\ingroup hardware_gpio\n\n \\param gpio Which GPIO caused this interrupt\n \\param event_mask Which events caused this interrupt. See \\ref gpio_irq_level for details.\n \\sa gpio_set_irq_enabled_with_callback()\n \\sa gpio_set_irq_callback()"]
pub type gpio_irq_callback_t =
    ::core::option::Option<unsafe extern "C" fn(gpio: uint, event_mask: u32)>;
impl gpio_override {
    #[doc = "< peripheral signal selected via \\ref gpio_set_function"]
    pub const GPIO_OVERRIDE_NORMAL: gpio_override = gpio_override(0);
}
impl gpio_override {
    #[doc = "< invert peripheral signal selected via \\ref gpio_set_function"]
    pub const GPIO_OVERRIDE_INVERT: gpio_override = gpio_override(1);
}
impl gpio_override {
    #[doc = "< drive low/disable output"]
    pub const GPIO_OVERRIDE_LOW: gpio_override = gpio_override(2);
}
impl gpio_override {
    #[doc = "< drive high/enable output"]
    pub const GPIO_OVERRIDE_HIGH: gpio_override = gpio_override(3);
}
impl ::core::ops::BitOr<gpio_override> for gpio_override {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpio_override(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpio_override {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpio_override) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpio_override> for gpio_override {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpio_override(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpio_override {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpio_override) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gpio_override(pub cty::c_uint);
impl gpio_slew_rate {
    #[doc = "< Slew rate limiting enabled"]
    pub const GPIO_SLEW_RATE_SLOW: gpio_slew_rate = gpio_slew_rate(0);
}
impl gpio_slew_rate {
    #[doc = "< Slew rate limiting disabled"]
    pub const GPIO_SLEW_RATE_FAST: gpio_slew_rate = gpio_slew_rate(1);
}
impl ::core::ops::BitOr<gpio_slew_rate> for gpio_slew_rate {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpio_slew_rate(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpio_slew_rate {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpio_slew_rate) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpio_slew_rate> for gpio_slew_rate {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpio_slew_rate(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpio_slew_rate {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpio_slew_rate) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief Slew rate limiting levels for GPIO outputs\n  \\ingroup hardware_gpio\n\n Slew rate limiting increases the minimum rise/fall time when a GPIO output\n is lightly loaded, which can help to reduce electromagnetic emissions.\n \\sa gpio_set_slew_rate"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gpio_slew_rate(pub cty::c_uint);
impl gpio_drive_strength {
    #[doc = "< 2 mA nominal drive strength"]
    pub const GPIO_DRIVE_STRENGTH_2MA: gpio_drive_strength = gpio_drive_strength(0);
}
impl gpio_drive_strength {
    #[doc = "< 4 mA nominal drive strength"]
    pub const GPIO_DRIVE_STRENGTH_4MA: gpio_drive_strength = gpio_drive_strength(1);
}
impl gpio_drive_strength {
    #[doc = "< 8 mA nominal drive strength"]
    pub const GPIO_DRIVE_STRENGTH_8MA: gpio_drive_strength = gpio_drive_strength(2);
}
impl gpio_drive_strength {
    #[doc = "< 12 mA nominal drive strength"]
    pub const GPIO_DRIVE_STRENGTH_12MA: gpio_drive_strength = gpio_drive_strength(3);
}
impl ::core::ops::BitOr<gpio_drive_strength> for gpio_drive_strength {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpio_drive_strength(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpio_drive_strength {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpio_drive_strength) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpio_drive_strength> for gpio_drive_strength {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpio_drive_strength(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpio_drive_strength {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpio_drive_strength) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief Drive strength levels for GPIO outputs\n  \\ingroup hardware_gpio\n\n Drive strength levels for GPIO outputs.\n \\sa gpio_set_drive_strength"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct gpio_drive_strength(pub cty::c_uint);
extern "C" {
    #[doc = " \\brief Select GPIO function\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param fn Which GPIO function select to use from list \\ref gpio_function"]
    pub fn gpio_set_function(gpio: uint, fn_: gpio_function);
}
extern "C" {
    #[doc = " \\brief Determine current GPIO function\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\return Which GPIO function is currently selected from list \\ref gpio_function"]
    pub fn gpio_get_function(gpio: uint) -> gpio_function;
}
extern "C" {
    #[doc = " \\brief Select up and down pulls on specific GPIO\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param up If true set a pull up on the GPIO\n \\param down If true set a pull down on the GPIO\n\n \\note On the RP2040, setting both pulls enables a \"bus keep\" function,\n i.e. a weak pull to whatever is current high/low state of GPIO."]
    pub fn gpio_set_pulls(gpio: uint, up: bool, down: bool);
}
extern "C" {
    #[doc = " \\brief Set GPIO IRQ override\n  \\ingroup hardware_gpio\n\n Optionally invert a GPIO IRQ signal, or drive it high or low\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_irqover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Set GPIO output override\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_outover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Select GPIO input override\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_inover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Select GPIO output enable override\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param value See \\ref gpio_override"]
    pub fn gpio_set_oeover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Enable GPIO input\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number\n \\param enabled true to enable input on specified GPIO"]
    pub fn gpio_set_input_enabled(gpio: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Enable/disable GPIO input hysteresis (Schmitt trigger)\n  \\ingroup hardware_gpio\n\n Enable or disable the Schmitt trigger hysteresis on a given GPIO. This is\n enabled on all GPIOs by default. Disabling input hysteresis can lead to\n inconsistent readings when the input signal has very long rise or fall\n times, but slightly reduces the GPIO's input delay.\n\n \\sa gpio_is_input_hysteresis_enabled\n \\param gpio GPIO number\n \\param enabled true to enable input hysteresis on specified GPIO"]
    pub fn gpio_set_input_hysteresis_enabled(gpio: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Determine whether input hysteresis is enabled on a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_set_input_hysteresis_enabled\n \\param gpio GPIO number"]
    pub fn gpio_is_input_hysteresis_enabled(gpio: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Set slew rate for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_get_slew_rate\n \\param gpio GPIO number\n \\param slew GPIO output slew rate"]
    pub fn gpio_set_slew_rate(gpio: uint, slew: gpio_slew_rate);
}
extern "C" {
    #[doc = " \\brief Determine current slew rate for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_set_slew_rate\n \\param gpio GPIO number\n \\return Current slew rate of that GPIO"]
    pub fn gpio_get_slew_rate(gpio: uint) -> gpio_slew_rate;
}
extern "C" {
    #[doc = " \\brief Set drive strength for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_get_drive_strength\n \\param gpio GPIO number\n \\param drive GPIO output drive strength"]
    pub fn gpio_set_drive_strength(gpio: uint, drive: gpio_drive_strength);
}
extern "C" {
    #[doc = " \\brief Determine current slew rate for a specified GPIO\n  \\ingroup hardware_gpio\n\n \\sa gpio_set_drive_strength\n \\param gpio GPIO number\n \\return Current drive strength of that GPIO"]
    pub fn gpio_get_drive_strength(gpio: uint) -> gpio_drive_strength;
}
extern "C" {
    #[doc = " \\brief Enable or disable specific interrupt events for specified GPIO\n  \\ingroup hardware_gpio\n\n This function sets which GPIO events cause a GPIO interrupt on the calling core. See\n \\ref gpio_set_irq_callback, \\ref gpio_set_irq_enabled_with_callback and\n \\ref gpio_add_raw_irq_handler to set up a GPIO interrupt handler to handle the events.\n\n \\note The IO IRQs are independent per-processor. This configures the interrupt events for\n the processor that calls the function.\n\n \\param gpio GPIO number\n \\param event_mask Which events will cause an interrupt\n \\param enabled Enable or disable flag\n\n Events is a bitmask of the following \\ref gpio_irq_level values:\n\n bit | constant            | interrupt\n ----|----------------------------------------------------------\n   0 | GPIO_IRQ_LEVEL_LOW  | Continuously while level is low\n   1 | GPIO_IRQ_LEVEL_HIGH | Continuously while level is high\n   2 | GPIO_IRQ_EDGE_FALL  | On each transition from high to low\n   3 | GPIO_IRQ_EDGE_RISE  | On each transition from low to high\n\n which are specified in \\ref gpio_irq_level"]
    pub fn gpio_set_irq_enabled(gpio: uint, event_mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Set the generic callback used for GPIO IRQ events for the current core\n  \\ingroup hardware_gpio\n\n This function sets the callback used for all GPIO IRQs on the current core that are not explicitly\n hooked via \\ref gpio_add_raw_irq_handler or other gpio_add_raw_irq_handler_ functions.\n\n This function is called with the GPIO number and event mask for each of the (not explicitly hooked)\n GPIOs that have events enabled and that are pending (see \\ref gpio_get_irq_event_mask).\n\n \\note The IO IRQs are independent per-processor. This function affects\n the processor that calls the function.\n\n \\param callback default user function to call on GPIO irq. Note only one of these can be set per processor."]
    pub fn gpio_set_irq_callback(callback: gpio_irq_callback_t);
}
extern "C" {
    #[doc = " \\brief Convenience function which performs multiple GPIO IRQ related initializations\n  \\ingroup hardware_gpio\n\n This method is a slightly eclectic mix of initialization, that:\n\n \\li Updates whether the specified events for the specified GPIO causes an interrupt on the calling core based\n on the enable flag.\n\n \\li Sets the callback handler for the calling core to callback (or clears the handler if the callback is NULL).\n\n \\li Enables GPIO IRQs on the current core if enabled is true.\n\n This method is commonly used to perform a one time setup, and following that any additional IRQs/events are enabled\n via \\ref gpio_set_irq_enabled. All GPIOs/events added in this way on the same core share the same callback; for multiple\n independent handlers for different GPIOs you should use \\ref gpio_add_raw_irq_handler and related functions.\n\n This method is equivalent to:\n\n \\code{.c}\n gpio_set_irq_enabled(gpio, event_mask, enabled);\n gpio_set_irq_callback(callback);\n if (enabled) irq_set_enabled(IO_IRQ_BANK0, true);\n \\endcode\n\n \\note The IO IRQs are independent per-processor. This method affects only the processor that calls the function.\n\n \\param gpio GPIO number\n \\param event_mask Which events will cause an interrupt. See \\ref gpio_irq_level for details.\n \\param enabled Enable or disable flag\n \\param callback user function to call on GPIO irq. if NULL, the callback is removed"]
    pub fn gpio_set_irq_enabled_with_callback(
        gpio: uint,
        event_mask: u32,
        enabled: bool,
        callback: gpio_irq_callback_t,
    );
}
extern "C" {
    #[doc = " \\brief Enable dormant wake up interrupt for specified GPIO and events\n  \\ingroup hardware_gpio\n\n This configures IRQs to restart the XOSC or ROSC when they are\n disabled in dormant mode\n\n \\param gpio GPIO number\n \\param event_mask Which events will cause an interrupt. See \\ref gpio_irq_level for details.\n \\param enabled Enable/disable flag"]
    pub fn gpio_set_dormant_irq_enabled(gpio: uint, event_mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Acknowledge a GPIO interrupt for the specified events on the calling core\n  \\ingroup hardware_gpio\n\n \\note This may be called with a mask of any of valid bits specified in \\ref gpio_irq_level, however\n it has no effect on \\a level sensitive interrupts which remain pending while the GPIO is at the specified\n level. When handling \\a level sensitive interrupts, you should generally disable the interrupt (see\n \\ref gpio_set_irq_enabled) and then set it up again later once the GPIO level has changed (or to catch\n the opposite level).\n\n \\param gpio GPIO number\n\n \\note For callbacks set with \\ref gpio_set_irq_enabled_with_callback, or \\ref gpio_set_irq_callback, this function is called automatically.\n \\param event_mask Bitmask of events to clear. See \\ref gpio_irq_level for details."]
    pub fn gpio_acknowledge_irq(gpio: uint, event_mask: u32);
}
extern "C" {
    #[doc = " \\brief Adds a raw GPIO IRQ handler for the specified GPIOs on the current core\n  \\ingroup hardware_gpio\n\n In addition to the default mechanism of a single GPIO IRQ event callback per core (see \\ref gpio_set_irq_callback),\n it is possible to add explicit GPIO IRQ handlers which are called independent of the default callback. The order\n relative to the default callback can be controlled via the order_priority parameter (the default callback has the priority\n \\ref GPIO_IRQ_CALLBACK_ORDER_PRIORITY which defaults to the lowest priority with the intention of it running last).\n\n This method adds such an explicit GPIO IRQ handler, and disables the \"default\" callback for the specified GPIOs.\n\n \\note Multiple raw handlers should not be added for the same GPIOs, and this method will assert if you attempt to.\n\n A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:\n\n \\code{.c}\n void my_irq_handler(void) {\n     if (gpio_get_irq_event_mask(my_gpio_num) & my_gpio_event_mask) {\n        gpio_acknowledge_irq(my_gpio_num, my_gpio_event_mask);\n       // handle the IRQ\n     }\n     if (gpio_get_irq_event_mask(my_gpio_num2) & my_gpio_event_mask2) {\n        gpio_acknowledge_irq(my_gpio_num2, my_gpio_event_mask2);\n       // handle the IRQ\n     }\n }\n \\endcode\n\n @param gpio_mask a bit mask of the GPIO numbers that will no longer be passed to the default callback for this core\n @param handler the handler to add to the list of GPIO IRQ handlers for this core\n @param order_priority the priority order to determine the relative position of the handler in the list of GPIO IRQ handlers for this core."]
    pub fn gpio_add_raw_irq_handler_with_order_priority_masked(
        gpio_mask: uint,
        handler: irq_handler_t,
        order_priority: u8,
    );
}
extern "C" {
    #[doc = " \\brief Adds a raw GPIO IRQ handler for the specified GPIOs on the current core\n  \\ingroup hardware_gpio\n\n In addition to the default mechanism of a single GPIO IRQ event callback per core (see \\ref gpio_set_irq_callback),\n it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.\n\n This method adds such a callback, and disables the \"default\" callback for the specified GPIOs.\n\n \\note Multiple raw handlers should not be added for the same GPIOs, and this method will assert if you attempt to.\n\n A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:\n\n \\code{.c}\n void my_irq_handler(void) {\n     if (gpio_get_irq_event_mask(my_gpio_num) & my_gpio_event_mask) {\n        gpio_acknowledge_irq(my_gpio_num, my_gpio_event_mask);\n       // handle the IRQ\n     }\n     if (gpio_get_irq_event_mask(my_gpio_num2) & my_gpio_event_mask2) {\n        gpio_acknowledge_irq(my_gpio_num2, my_gpio_event_mask2);\n       // handle the IRQ\n     }\n }\n \\endcode\n\n @param gpio_mask a bit mask of the GPIO numbers that will no longer be passed to the default callback for this core\n @param handler the handler to add to the list of GPIO IRQ handlers for this core"]
    pub fn gpio_add_raw_irq_handler_masked(gpio_mask: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Removes a raw GPIO IRQ handler for the specified GPIOs on the current core\n  \\ingroup hardware_gpio\n\n In addition to the default mechanism of a single GPIO IRQ event callback per core (see \\ref gpio_set_irq_callback),\n it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.\n\n This method removes such a callback, and enables the \"default\" callback for the specified GPIOs.\n\n @param gpio_mask a bit mask of the GPIO numbers that will now be passed to the default callback for this core\n @param handler the handler to remove from the list of GPIO IRQ handlers for this core"]
    pub fn gpio_remove_raw_irq_handler_masked(gpio_mask: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Initialise a GPIO for (enabled I/O and set func to GPIO_FUNC_SIO)\n  \\ingroup hardware_gpio\n\n Clear the output enable (i.e. set to input).\n Clear any output value.\n\n \\param gpio GPIO number"]
    pub fn gpio_init(gpio: uint);
}
extern "C" {
    #[doc = " \\brief Resets a GPIO back to the NULL function, i.e. disables it.\n  \\ingroup hardware_gpio\n\n \\param gpio GPIO number"]
    pub fn gpio_deinit(gpio: uint);
}
extern "C" {
    #[doc = " \\brief Initialise multiple GPIOs (enabled I/O and set func to GPIO_FUNC_SIO)\n  \\ingroup hardware_gpio\n\n Clear the output enable (i.e. set to input).\n Clear any output value.\n\n \\param gpio_mask Mask with 1 bit per GPIO number to initialize"]
    pub fn gpio_init_mask(gpio_mask: uint);
}
extern "C" {
    pub fn gpio_debug_pins_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_hw_t {
    pub timehw: io_wo_32,
    pub timelw: io_wo_32,
    pub timehr: io_ro_32,
    pub timelr: io_ro_32,
    pub alarm: [io_rw_32; 4usize],
    pub armed: io_rw_32,
    pub timerawh: io_ro_32,
    pub timerawl: io_ro_32,
    pub dbgpause: io_rw_32,
    pub pause: io_rw_32,
    pub intr: io_rw_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
extern "C" {
    #[doc = " \\brief Return the current 64 bit timestamp value in microseconds\n  \\ingroup hardware_timer\n\n Returns the full 64 bits of the hardware timer. The \\ref pico_time and other functions rely on the fact that this\n value monotonically increases from power up. As such it is expected that this value counts upwards and never wraps\n (we apologize for introducing a potential year 5851444 bug).\n\n \\return the 64 bit timestamp"]
    pub fn time_us_64() -> u64;
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given (32 bit) number of microseconds\n  \\ingroup hardware_timer\n\n \\param delay_us delay amount in microseconds"]
    pub fn busy_wait_us_32(delay_us: u32);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given (64 bit) number of microseconds\n  \\ingroup hardware_timer\n\n \\param delay_us delay amount in microseconds"]
    pub fn busy_wait_us(delay_us: u64);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given number of milliseconds\n  \\ingroup hardware_timer\n\n \\param delay_ms delay amount in milliseconds"]
    pub fn busy_wait_ms(delay_ms: u32);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles until after the specified timestamp\n  \\ingroup hardware_timer\n\n \\param t Absolute time to wait until"]
    pub fn busy_wait_until(t: absolute_time_t);
}
#[doc = " Callback function type for hardware alarms\n  \\ingroup hardware_timer\n\n \\param alarm_num the hardware alarm number\n \\sa hardware_alarm_set_callback()"]
pub type hardware_alarm_callback_t = ::core::option::Option<unsafe extern "C" fn(alarm_num: uint)>;
extern "C" {
    #[doc = " \\brief cooperatively claim the use of this hardware alarm_num\n  \\ingroup hardware_timer\n\n This method hard asserts if the hardware alarm is currently claimed.\n\n \\param alarm_num the hardware alarm to claim\n \\sa hardware_claiming"]
    pub fn hardware_alarm_claim(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief cooperatively claim the use of this hardware alarm_num\n  \\ingroup hardware_timer\n\n This method attempts to claim an unused hardware alarm\n\n \\return alarm_num the hardware alarm claimed or -1 if requires was false, and none are available\n \\sa hardware_claiming"]
    pub fn hardware_alarm_claim_unused(required: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief cooperatively release the claim on use of this hardware alarm_num\n  \\ingroup hardware_timer\n\n \\param alarm_num the hardware alarm to unclaim\n \\sa hardware_claiming"]
    pub fn hardware_alarm_unclaim(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief Determine if a hardware alarm has been claimed\n  \\ingroup hardware_timer\n\n \\param alarm_num the hardware alarm number\n \\return true if claimed, false otherwise\n \\see hardware_alarm_claim"]
    pub fn hardware_alarm_is_claimed(alarm_num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Enable/Disable a callback for a hardware timer on this core\n  \\ingroup hardware_timer\n\n This method enables/disables the alarm IRQ for the specified hardware alarm on the\n calling core, and set the specified callback to be associated with that alarm.\n\n This callback will be used for the timeout set via hardware_alarm_set_target\n\n \\note This will install the handler on the current core if the IRQ handler isn't already set.\n Therefore the user has the opportunity to call this up from the core of their choice\n\n \\param alarm_num the hardware alarm number\n \\param callback the callback to install, or NULL to unset\n\n \\sa hardware_alarm_set_target()"]
    pub fn hardware_alarm_set_callback(alarm_num: uint, callback: hardware_alarm_callback_t);
}
extern "C" {
    #[doc = " \\brief Set the current target for the specified hardware alarm\n \\ingroup hardware_timer\n\n This will replace any existing target\n\n @param alarm_num the hardware alarm number\n @param t the target timestamp\n @return true if the target was \"missed\"; i.e. it was in the past, or occurred before a future hardware timeout could be set"]
    pub fn hardware_alarm_set_target(alarm_num: uint, t: absolute_time_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Cancel an existing target (if any) for a given hardware_alarm\n \\ingroup hardware_timer\n\n @param alarm_num the hardware alarm number"]
    pub fn hardware_alarm_cancel(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief Force and IRQ for a specific hardware alarm\n \\ingroup hardware_timer\n\n This method will forcibly make sure the current alarm callback (if present) for the hardware\n alarm is called from an IRQ context after this call. If an actual callback is due at the same\n time then the callback may only be called once.\n\n Calling this method does not otherwise interfere with regular callback operations.\n\n @param alarm_num the hardware alarm number"]
    pub fn hardware_alarm_force_irq(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief The timestamp representing the end of time; this is actually not the maximum possible\n timestamp, but is set to 0x7fffffff_ffffffff microseconds to avoid sign overflows with time\n arithmetic. This is almost 300,000 years, so should be sufficient.\n \\ingroup timestamp"]
    pub static at_the_end_of_time: absolute_time_t;
}
extern "C" {
    #[doc = " \\brief The timestamp representing a null timestamp\n \\ingroup timestamp"]
    pub static nil_time: absolute_time_t;
}
extern "C" {
    #[doc = " \\brief Wait until after the given timestamp to return\n \\ingroup sleep\n\n \\note  This method attempts to perform a lower power (WFE) sleep\n\n \\param target the time after which to return\n \\sa sleep_us()\n \\sa busy_wait_until()"]
    pub fn sleep_until(target: absolute_time_t);
}
extern "C" {
    #[doc = " \\brief Wait for the given number of microseconds before returning\n \\ingroup sleep\n\n \\note This method attempts to perform a lower power (WFE) sleep\n\n \\param us the number of microseconds to sleep\n \\sa busy_wait_us()"]
    pub fn sleep_us(us: u64);
}
extern "C" {
    #[doc = " \\brief Wait for the given number of milliseconds before returning\n \\ingroup sleep\n\n \\note This method attempts to perform a lower power sleep (using WFE) as much as possible.\n\n \\param ms the number of milliseconds to sleep"]
    pub fn sleep_ms(ms: u32);
}
extern "C" {
    #[doc = " \\brief Helper method for blocking on a timeout\n \\ingroup sleep\n\n This method will return in response to an event (as per __wfe) or\n when the target time is reached, or at any point before.\n\n This method can be used to implement a lower power polling loop waiting on\n some condition signalled by an event (__sev()).\n\n This is called \\a best_effort because under certain circumstances (notably the default timer pool\n being disabled or full) the best effort is simply to return immediately without a __wfe, thus turning the calling\n code into a busy wait.\n\n Example usage:\n ```c\n bool my_function_with_timeout_us(uint64_t timeout_us) {\n     absolute_time_t timeout_time = make_timeout_time_us(timeout_us);\n     do {\n         // each time round the loop, we check to see if the condition\n         // we are waiting on has happened\n         if (my_check_done()) {\n             // do something\n             return true;\n         }\n         // will try to sleep until timeout or the next processor event\n     } while (!best_effort_wfe_or_timeout(timeout_time));\n     return false; // timed out\n }\n ```\n\n @param timeout_timestamp the timeout time\n @return true if the target time is reached, false otherwise"]
    pub fn best_effort_wfe_or_timeout(timeout_timestamp: absolute_time_t) -> bool;
}
#[doc = " \\brief The identifier for an alarm\n\n \\note this identifier is signed because -1 is used as an error condition when creating alarms\n\n \\note alarm ids may be reused, however for convenience the implementation makes an attempt to defer\n reusing as long as possible. You should certainly expect it to be hundreds of ids before one is\n reused, although in most cases it is more. Nonetheless care must still be taken when cancelling\n alarms or other functionality based on alarms when the alarm may have expired, as eventually\n the alarm id may be reused for another alarm.\n\n \\ingroup alarm"]
pub type alarm_id_t = i32;
#[doc = " \\brief User alarm callback\n \\ingroup alarm\n \\param id the alarm_id as returned when the alarm was added\n \\param user_data the user data passed when the alarm was added\n \\return <0 to reschedule the same alarm this many us from the time the alarm was previously scheduled to fire\n \\return >0 to reschedule the same alarm this many us from the time this method returns\n \\return 0 to not reschedule the alarm"]
pub type alarm_callback_t = ::core::option::Option<
    unsafe extern "C" fn(id: alarm_id_t, user_data: *mut cty::c_void) -> i64,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alarm_pool {
    _unused: [u8; 0],
}
pub type alarm_pool_t = alarm_pool;
extern "C" {
    #[doc = " \\brief Create the default alarm pool (if not already created or disabled)\n \\ingroup alarm"]
    pub fn alarm_pool_init_default();
}
extern "C" {
    #[doc = " \\brief The default alarm pool used when alarms are added without specifying an alarm pool,\n        and also used by the SDK to support lower power sleeps and timeouts.\n\n \\ingroup alarm\n \\sa #PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM"]
    pub fn alarm_pool_get_default() -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Create an alarm pool\n\n The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from.\n\n In many situations there is never any need for anything other than the default alarm pool, however you\n might want to create another if you want alarm callbacks on core 1 or require alarm pools of\n different priority (IRQ priority based preemption of callbacks)\n\n \\note This method will hard assert if the hardware alarm is already claimed.\n\n \\ingroup alarm\n \\param hardware_alarm_num the hardware alarm to use to back this pool\n \\param max_timers the maximum number of timers\n        \\note For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255\n \\sa alarm_pool_get_default()\n \\sa hardware_claiming"]
    pub fn alarm_pool_create(hardware_alarm_num: uint, max_timers: uint) -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Create an alarm pool, claiming an used hardware alarm to back it.\n\n The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from.\n\n In many situations there is never any need for anything other than the default alarm pool, however you\n might want to create another if you want alarm callbacks on core 1 or require alarm pools of\n different priority (IRQ priority based preemption of callbacks)\n\n \\note This method will hard assert if the there is no free hardware to claim.\n\n \\ingroup alarm\n \\param max_timers the maximum number of timers\n        \\note For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255\n \\sa alarm_pool_get_default()\n \\sa hardware_claiming"]
    pub fn alarm_pool_create_with_unused_hardware_alarm(max_timers: uint) -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Return the hardware alarm used by an alarm pool\n \\ingroup alarm\n \\param pool the pool\n \\return the hardware alarm used by the pool"]
    pub fn alarm_pool_hardware_alarm_num(pool: *mut alarm_pool_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Return the core number the alarm pool was initialized on (and hence callbacks are called on)\n \\ingroup alarm\n \\param pool the pool\n \\return the core used by the pool"]
    pub fn alarm_pool_core_num(pool: *mut alarm_pool_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Destroy the alarm pool, cancelling all alarms and freeing up the underlying hardware alarm\n \\ingroup alarm\n \\param pool the pool\n \\return the hardware alarm used by the pool"]
    pub fn alarm_pool_destroy(pool: *mut alarm_pool_t);
}
extern "C" {
    #[doc = " \\brief Add an alarm callback to be called at a specific time\n \\ingroup alarm\n\n Generally the callback is called as soon as possible after the time specified from an IRQ handler\n on the core the alarm pool was created on. If the callback is in the past or happens before\n the alarm setup could be completed, then this method will optionally call the callback itself\n and then return a return code to indicate that the target time has passed.\n\n \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.\n\n @param pool the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback)\n @param time the timestamp when (after which) the callback should fire\n @param callback the callback function\n @param user_data user data to pass to the callback function\n @param fire_if_past if true, and the alarm time falls before or during this call before the alarm can be set,\n                     then the callback should be called during (by) this function instead\n @return >0 the alarm id for an active (at the time of return) alarm\n @return 0 if the alarm time passed before or during the call AND there is no active alarm to return the id of.\n           The latter can either happen because fire_if_past was false (i.e. no timer was ever created),\n           or if the callback <i>was</i> called during this method but the callback cancelled itself by returning 0\n @return -1 if there were no alarm slots available"]
    pub fn alarm_pool_add_alarm_at(
        pool: *mut alarm_pool_t,
        time: absolute_time_t,
        callback: alarm_callback_t,
        user_data: *mut cty::c_void,
        fire_if_past: bool,
    ) -> alarm_id_t;
}
extern "C" {
    #[doc = " \\brief Add an alarm callback to be called at or after a specific time\n \\ingroup alarm\n\n The callback is called as soon as possible after the time specified from an IRQ handler\n on the core the alarm pool was created on. Unlike \\ref alarm_pool_add_alarm_at, this method\n guarantees to call the callback from that core even if the time is during this method call or in the past.\n\n \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.\n\n @param pool the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback)\n @param time the timestamp when (after which) the callback should fire\n @param callback the callback function\n @param user_data user data to pass to the callback function\n @return >0 the alarm id for an active (at the time of return) alarm\n @return -1 if there were no alarm slots available"]
    pub fn alarm_pool_add_alarm_at_force_in_context(
        pool: *mut alarm_pool_t,
        time: absolute_time_t,
        callback: alarm_callback_t,
        user_data: *mut cty::c_void,
    ) -> alarm_id_t;
}
extern "C" {
    #[doc = " \\brief Cancel an alarm\n \\ingroup alarm\n \\param pool the alarm_pool containing the alarm\n \\param alarm_id the alarm\n \\return true if the alarm was cancelled, false if it didn't exist\n \\sa alarm_id_t for a note on reuse of IDs"]
    pub fn alarm_pool_cancel_alarm(pool: *mut alarm_pool_t, alarm_id: alarm_id_t) -> bool;
}
#[doc = " \\brief Information about a repeating timer\n \\ingroup repeating_timer\n \\return"]
pub type repeating_timer_t = repeating_timer;
#[doc = " \\brief Callback for a repeating timer\n \\ingroup repeating_timer\n \\param rt repeating time structure containing information about the repeating time. user_data is of primary important to the user\n \\return true to continue repeating, false to stop."]
pub type repeating_timer_callback_t =
    ::core::option::Option<unsafe extern "C" fn(rt: *mut repeating_timer_t) -> bool>;
#[doc = " \\brief Information about a repeating timer\n \\ingroup repeating_timer\n \\return"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct repeating_timer {
    pub delay_us: i64,
    pub pool: *mut alarm_pool_t,
    pub alarm_id: alarm_id_t,
    pub callback: repeating_timer_callback_t,
    pub user_data: *mut cty::c_void,
}
extern "C" {
    #[doc = " \\brief Add a repeating timer that is called repeatedly at the specified interval in microseconds\n \\ingroup repeating_timer\n\n Generally the callback is called as soon as possible after the time specified from an IRQ handler\n on the core the alarm pool was created on. If the callback is in the past or happens before\n the alarm setup could be completed, then this method will optionally call the callback itself\n and then return a return code to indicate that the target time has passed.\n\n \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.\n\n @param pool the alarm pool to use for scheduling the repeating timer (this determines which hardware alarm is used, and which core calls the callback)\n @param delay_us the repeat delay in microseconds; if >0 then this is the delay between one callback ending and the next starting; if <0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1\n @param callback the repeating timer callback function\n @param user_data user data to pass to store in the repeating_timer structure for use by the callback.\n @param out the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space\n @return false if there were no alarm slots available to create the timer, true otherwise."]
    pub fn alarm_pool_add_repeating_timer_us(
        pool: *mut alarm_pool_t,
        delay_us: i64,
        callback: repeating_timer_callback_t,
        user_data: *mut cty::c_void,
        out: *mut repeating_timer_t,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Cancel a repeating timer\n \\ingroup repeating_timer\n \\param timer the repeating timer to cancel\n \\return true if the repeating timer was cancelled, false if it didn't exist\n \\sa alarm_id_t for a note on reuse of IDs"]
    pub fn cancel_repeating_timer(timer: *mut repeating_timer_t) -> bool;
}
extern "C" {
    pub fn cyw43_hal_get_mac(idx: cty::c_int, buf: *mut u8);
}
extern "C" {
    pub fn cyw43_hal_generate_laa_mac(idx: cty::c_int, buf: *mut u8);
}
extern "C" {
    pub fn cyw43_thread_enter();
}
extern "C" {
    pub fn cyw43_thread_exit();
}
extern "C" {
    pub fn cyw43_thread_lock_check();
}
extern "C" {
    pub fn cyw43_await_background_or_timeout_us(timeout_us: u32);
}
extern "C" {
    pub fn cyw43_delay_ms(ms: u32);
}
extern "C" {
    pub fn cyw43_delay_us(us: u32);
}
extern "C" {
    pub fn cyw43_schedule_internal_poll_dispatch(
        func: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn cyw43_post_poll_hook();
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
extern "C" {
    pub fn ctermid(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut cty::c_char, arg2: cty::c_int, arg3: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn fputc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const cty::c_char, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn puts(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: cty::c_long, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(arg1: *const cty::c_char);
}
extern "C" {
    pub fn fopen(_name: *const cty::c_char, _type: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn remove(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        arg4: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn asiprintf(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn diprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfiprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn vfiscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fdopen(arg1: cty::c_int, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut cty::c_char, arg3: cty::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fmemopen(arg1: *mut cty::c_void, arg2: usize, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut cty::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(arg1: cty::c_int, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: cty::c_int,
        arg4: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _fdopen_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        arg3: usize,
        arg4: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const cty::c_char, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: cty::c_long,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const cty::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const cty::c_char,
        _new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut cty::c_char,
        arg2: *mut usize,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut cty::c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
#[doc = "< Client interface STA mode"]
pub const CYW43_ITF_STA: _bindgen_ty_6 = _bindgen_ty_6(0);
#[doc = "< Access point (AP) interface mode"]
pub const CYW43_ITF_AP: _bindgen_ty_6 = _bindgen_ty_6(1);
impl ::core::ops::BitOr<_bindgen_ty_6> for _bindgen_ty_6 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_6(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_6 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_6) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_6> for _bindgen_ty_6 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_6(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_6 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_6) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief Network interface types\n \\anchor CYW43_ITF_\n/\n//!\\{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_6(pub cty::c_uint);
#[doc = " \\brief Structure to return wifi scan results\n/\n//!\\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cyw43_ev_scan_result_t {
    pub _0: [u32; 5usize],
    #[doc = "< access point mac address"]
    pub bssid: [u8; 6usize],
    pub _1: [u16; 2usize],
    #[doc = "< length of wlan access point name"]
    pub ssid_len: u8,
    #[doc = "< wlan access point name"]
    pub ssid: [u8; 32usize],
    pub _2: [u32; 5usize],
    #[doc = "< wifi channel"]
    pub channel: u16,
    pub _3: u16,
    #[doc = "< wifi auth mode \\ref CYW43_AUTH_"]
    pub auth_mode: u8,
    #[doc = "< signal strength"]
    pub rssi: i16,
}
#[doc = " \\brief Structure to return wifi scan results\n/\n//!\\{"]
pub type cyw43_ev_scan_result_t = _cyw43_ev_scan_result_t;
#[doc = "!\\}"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _cyw43_async_event_t {
    pub _0: u16,
    pub flags: u16,
    pub event_type: u32,
    pub status: u32,
    pub reason: u32,
    pub _1: [u8; 30usize],
    pub interface: u8,
    pub _2: u8,
    pub u: _cyw43_async_event_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _cyw43_async_event_t__bindgen_ty_1 {
    pub scan_result: cyw43_ev_scan_result_t,
}
#[doc = "!\\}"]
pub type cyw43_async_event_t = _cyw43_async_event_t;
#[doc = " \\brief wifi scan options passed to cyw43_wifi_scan\n/\n//!\\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cyw43_wifi_scan_options_t {
    #[doc = "< version (not used)"]
    pub version: u32,
    #[doc = "< action (not used)"]
    pub action: u16,
    #[doc = "< not used"]
    pub __: u16,
    #[doc = "< ssid length, 0=all"]
    pub ssid_len: u32,
    #[doc = "< ssid name"]
    pub ssid: [u8; 32usize],
    #[doc = "< bssid (not used)"]
    pub bssid: [u8; 6usize],
    #[doc = "< bssid type (not used)"]
    pub bss_type: i8,
    #[doc = "< scan type 0=active, 1=passive"]
    pub scan_type: i8,
    #[doc = "< number of probes (not used)"]
    pub nprobes: i32,
    #[doc = "< active time (not used)"]
    pub active_time: i32,
    #[doc = "< passive time (not used)"]
    pub passive_time: i32,
    #[doc = "< home time (not used)"]
    pub home_time: i32,
    #[doc = "< number of channels (not used)"]
    pub channel_num: i32,
    #[doc = "< channel list (not used)"]
    pub channel_list: [u16; 1usize],
}
#[doc = " \\brief wifi scan options passed to cyw43_wifi_scan\n/\n//!\\{"]
pub type cyw43_wifi_scan_options_t = _cyw43_wifi_scan_options_t;
#[doc = "!\\}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cyw43_ll_t {
    pub opaque: [u32; 533usize],
}
#[doc = "!\\}"]
pub type cyw43_ll_t = _cyw43_ll_t;
extern "C" {
    pub fn cyw43_ll_init(self_: *mut cyw43_ll_t, cb_data: *mut cty::c_void);
}
extern "C" {
    pub fn cyw43_ll_deinit(self_: *mut cyw43_ll_t);
}
extern "C" {
    pub fn cyw43_ll_bus_init(self_: *mut cyw43_ll_t, mac: *const u8) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_bus_sleep(self_: *mut cyw43_ll_t, can_sleep: bool);
}
extern "C" {
    pub fn cyw43_ll_process_packets(self_: *mut cyw43_ll_t);
}
extern "C" {
    pub fn cyw43_ll_ioctl(
        self_: *mut cyw43_ll_t,
        cmd: u32,
        len: usize,
        buf: *mut u8,
        iface: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_send_ethernet(
        self_: *mut cyw43_ll_t,
        itf: cty::c_int,
        len: usize,
        buf: *const cty::c_void,
        is_pbuf: bool,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_on(self_: *mut cyw43_ll_t, country: u32) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_pm(
        self_: *mut cyw43_ll_t,
        pm: u32,
        pm_sleep_ret: u32,
        li_bcn: u32,
        li_dtim: u32,
        li_assoc: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_get_pm(
        self_: *mut cyw43_ll_t,
        pm: *mut u32,
        pm_sleep_ret: *mut u32,
        li_bcn: *mut u32,
        li_dtim: *mut u32,
        li_assoc: *mut u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_scan(
        self_: *mut cyw43_ll_t,
        opts: *mut cyw43_wifi_scan_options_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_join(
        self_: *mut cyw43_ll_t,
        ssid_len: usize,
        ssid: *const u8,
        key_len: usize,
        key: *const u8,
        auth_type: u32,
        bssid: *const u8,
        channel: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_set_wpa_auth(self_: *mut cyw43_ll_t);
}
extern "C" {
    pub fn cyw43_ll_wifi_rejoin(self_: *mut cyw43_ll_t);
}
extern "C" {
    pub fn cyw43_ll_wifi_get_bssid(self_in: *mut cyw43_ll_t, bssid: *mut u8) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_ap_init(
        self_: *mut cyw43_ll_t,
        ssid_len: usize,
        ssid: *const u8,
        auth: u32,
        key_len: usize,
        key: *const u8,
        channel: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_ap_set_up(self_: *mut cyw43_ll_t, up: bool) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_ap_get_stas(
        self_: *mut cyw43_ll_t,
        num_stas: *mut cty::c_int,
        macs: *mut u8,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_gpio_set(
        self_: *mut cyw43_ll_t,
        gpio_n: cty::c_int,
        gpio_en: bool,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_gpio_get(
        self_in: *mut cyw43_ll_t,
        gpio_n: cty::c_int,
        gpio_en: *mut bool,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_get_mac(self_in: *mut cyw43_ll_t, addr: *mut u8) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_wifi_update_multicast_filter(
        self_in: *mut cyw43_ll_t,
        addr: *mut u8,
        add: bool,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_has_work(self_: *mut cyw43_ll_t) -> bool;
}
extern "C" {
    pub fn cyw43_ll_bt_has_work(self_: *mut cyw43_ll_t) -> bool;
}
extern "C" {
    pub fn cyw43_cb_read_host_interrupt_pin(cb_data: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_cb_ensure_awake(cb_data: *mut cty::c_void);
}
extern "C" {
    pub fn cyw43_cb_process_async_event(cb_data: *mut cty::c_void, ev: *const cyw43_async_event_t);
}
extern "C" {
    pub fn cyw43_cb_process_ethernet(
        cb_data: *mut cty::c_void,
        itf: cty::c_int,
        len: usize,
        buf: *const u8,
    );
}
extern "C" {
    pub fn cyw43_ll_write_backplane_reg(self_in: *mut cyw43_ll_t, addr: u32, val: u32);
}
extern "C" {
    pub fn cyw43_ll_read_backplane_reg(self_in: *mut cyw43_ll_t, addr: u32) -> u32;
}
extern "C" {
    pub fn cyw43_ll_write_backplane_mem(
        self_in: *mut cyw43_ll_t,
        addr: u32,
        len: u32,
        buf: *const u8,
    ) -> cty::c_int;
}
extern "C" {
    pub fn cyw43_ll_read_backplane_mem(
        self_in: *mut cyw43_ll_t,
        addr: u32,
        len: u32,
        buf: *mut u8,
    ) -> cty::c_int;
}
#[doc = "!\\}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cyw43_t {
    pub cyw43_ll: cyw43_ll_t,
    pub itf_state: u8,
    pub trace_flags: u32,
    pub wifi_scan_state: u32,
    pub wifi_join_state: u32,
    pub wifi_scan_env: *mut cty::c_void,
    pub wifi_scan_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *const cyw43_ev_scan_result_t,
        ) -> cty::c_int,
    >,
    pub initted: bool,
    pub pend_disassoc: bool,
    pub pend_rejoin: bool,
    pub pend_rejoin_wpa: bool,
    pub ap_auth: u32,
    pub ap_channel: u8,
    pub ap_ssid_len: u8,
    pub ap_key_len: u8,
    pub ap_ssid: [u8; 32usize],
    pub ap_key: [u8; 64usize],
    pub mac: [u8; 6usize],
    pub bt_loaded: bool,
}
#[doc = "!\\}"]
pub type cyw43_t = _cyw43_t;
extern "C" {
    pub static mut cyw43_state: cyw43_t;
}
extern "C" {
    pub static mut cyw43_poll: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut cyw43_sleep: u32;
}
extern "C" {
    #[doc = " \\brief Initialize the driver\n\n This method must be called before using the driver\n\n \\param self the driver state object. This should always be \\c &cyw43_state"]
    pub fn cyw43_init(self_: *mut cyw43_t);
}
extern "C" {
    #[doc = " \\brief Shut the driver down\n\n This method will close the network interfaces, and free up resources\n\n \\param self the driver state object. This should always be \\c &cyw43_state"]
    pub fn cyw43_deinit(self_: *mut cyw43_t);
}
extern "C" {
    #[doc = " \\brief Send an ioctl command to cyw43\n\n This method sends a command to cyw43.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param cmd the command to send\n \\param len the amount of data to send with the commannd\n \\param buf a buffer containing the data to send\n \\param iface the interface to use, either CYW43_ITF_STA or CYW43_ITF_AP\n \\return 0 on success"]
    pub fn cyw43_ioctl(
        self_: *mut cyw43_t,
        cmd: u32,
        len: usize,
        buf: *mut u8,
        iface: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Send a raw ethernet packet\n\n This method sends a raw ethernet packet.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf interface to use, either CYW43_ITF_STA or CYW43_ITF_AP\n \\param len the amount of data to send\n \\param buf the data to send\n \\param is_pbuf true if buf points to an lwip struct pbuf\n \\return 0 on success"]
    pub fn cyw43_send_ethernet(
        self_: *mut cyw43_t,
        itf: cty::c_int,
        len: usize,
        buf: *const cty::c_void,
        is_pbuf: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Set the wifi power management mode\n\n This method sets the power management mode used by cyw43.\n This should be called after cyw43_wifi_set_up\n\n \\see cyw43_pm_value\n \\see CYW43_DEFAULT_PM\n \\see CYW43_AGGRESSIVE_PM\n \\see CYW43_PERFORMANCE_PM\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param pm Power management value\n \\return 0 on success"]
    pub fn cyw43_wifi_pm(self_: *mut cyw43_t, pm: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Get the wifi power management mode\n\n This method gets the power management mode used by cyw43.\n The value is expressed as an unsigned integer 0x00adbrrm where,\n m = pm_mode Power management mode\n rr = pm2_sleep_ret (in units of 10ms)\n b = li_beacon_period\n d = li_dtim_period\n a = li_assoc\n \\see cyw43_pm_value for an explanation of these values\n This should be called after cyw43_wifi_set_up\n\n \\param pm Power management value\n \\return 0 on success"]
    pub fn cyw43_wifi_get_pm(self_: *mut cyw43_t, pm: *mut u32) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Get the wifi link status\n\n Returns the status of the wifi link.\n\n link status        | Meaning\n -------------------|--------\n CYW43_LINK_DOWN    | Wifi down\n CYW43_LINK_JOIN    | Connected to wifi\n CYW43_LINK_FAIL    | Connection failed\n CYW43_LINK_NONET   | No matching SSID found (could be out of range, or down)\n CYW43_LINK_BADAUTH | Authenticatation failure\n\n \\note If the link status is negative it indicates an error\n The wifi link status for the interface CYW43_ITF_AP is always CYW43_LINK_DOWN\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface to use, should be CYW43_ITF_STA or CYW43_ITF_AP\n \\return A integer value representing the link status"]
    pub fn cyw43_wifi_link_status(self_: *mut cyw43_t, itf: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Set up and initialise wifi\n\n This method turns on wifi and sets the country for regulation purposes.\n The power management mode is initialised to \\ref CYW43_DEFAULT_PM\n For CYW43_ITF_AP, the access point is enabled.\n For CYW43_ITF_STA, the TCP/IP stack is reinitialised\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface to use either CYW43_ITF_STA or CYW43_ITF_AP\n \\param up true to enable the link. Set to false to disable AP mode.\n Setting the \\em up parameter to false for CYW43_ITF_STA is ignored.\n \\param country the country code, see \\ref CYW43_COUNTRY_\n"]
    pub fn cyw43_wifi_set_up(self_: *mut cyw43_t, itf: cty::c_int, up: bool, country: u32);
}
extern "C" {
    #[doc = " \\brief Get the mac address of the device\n\n This method returns the mac address of the interface.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface to use, either CYW43_ITF_STA or CYW43_ITF_AP\n \\param mac a buffer to receive the mac address\n \\return 0 on success"]
    pub fn cyw43_wifi_get_mac(self_: *mut cyw43_t, itf: cty::c_int, mac: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Add/remove multicast group address\n\n This method adds/removes an address from the multicast filter, allowing\n frames sent to this group to be received\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param addr a buffer containing a group mac address\n \\param add true to add the address, false to remove it\n \\return 0 on success"]
    pub fn cyw43_wifi_update_multicast_filter(
        self_: *mut cyw43_t,
        addr: *mut u8,
        add: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Perform a wifi scan for wifi networks\n\n Start a scan for wifi networks. Results are returned via the callback.\n\n \\note The scan is complete when \\ref cyw43_wifi_scan_active return false\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param opts An instance of \\ref cyw43_wifi_scan_options_t. Values in here are currently ignored.\n \\param env Pointer passed back in the callback\n \\param result_cb Callback for wifi scan results, see \\ref cyw43_ev_scan_result_t\n \\return 0 on success"]
    pub fn cyw43_wifi_scan(
        self_: *mut cyw43_t,
        opts: *mut cyw43_wifi_scan_options_t,
        env: *mut cty::c_void,
        result_cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *const cyw43_ev_scan_result_t,
            ) -> cty::c_int,
        >,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Connect or \\em join a wifi network\n\n Connect to a wifi network in STA (client) mode\n After success is returned, periodically call \\ref cyw43_wifi_link_status or \\ref cyw43_tcpip_link_status,\n to query the status of the link. It can take a many seconds to connect to fully join a network.\n\n \\note Call \\ref cyw43_wifi_leave to dissassociate from a wifi network.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param ssid_len the length of the wifi network name\n \\param ssid A buffer containing the wifi network name\n \\param key_len The length of the wifi \\em password\n \\param key A buffer containing the wifi \\em password\n \\param auth_type Auth type, \\see CYW43_AUTH_\n \\param bssid the mac address of the access point to connect to. This can be NULL.\n \\param channel Used to set the band of the connection. This is only used if bssid is non NULL.\n \\return 0 on success"]
    pub fn cyw43_wifi_join(
        self_: *mut cyw43_t,
        ssid_len: usize,
        ssid: *const u8,
        key_len: usize,
        key: *const u8,
        auth_type: u32,
        bssid: *const u8,
        channel: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Dissassociate from a wifi network\n\n This method dissassociates from a wifi network.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf The interface to disconnect, either CYW43_ITF_STA or CYW43_ITF_AP\n \\return 0 on success"]
    pub fn cyw43_wifi_leave(self_: *mut cyw43_t, itf: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Get the signal strength (RSSI) of the wifi network\n\n For STA (client) mode, returns the signal strength or RSSI of the wifi network.\n An RSSI value of zero is returned if you call this function before a network is connected.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param rssi a pointer to which the returned RSSI value is stored.\n \\return 0 on success"]
    pub fn cyw43_wifi_get_rssi(self_: *mut cyw43_t, rssi: *mut i32) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Get the BSSID of the connected wifi network\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param bssid a buffer to receive the BSSID\n \\return 0 on success"]
    pub fn cyw43_wifi_get_bssid(self_: *mut cyw43_t, bssid: *mut u8) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Get the maximum number of devices (STAs) that can be associated with the wifi access point\n\n For access point (AP) mode, this method can be used to get the maximum number of devices that can be\n connected to the wifi access point.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param max_stas Returns the maximum number of devices (STAs) that can be connected to the access point"]
    pub fn cyw43_wifi_ap_get_max_stas(self_: *mut cyw43_t, max_stas: *mut cty::c_int);
}
extern "C" {
    #[doc = " \\brief Get the number of devices (STAs) associated with the wifi access point\n\n For access point (AP) mode, this method can be used to get the number of devices and mac addresses of devices\n connected to the wifi access point.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param num_stas Returns the number of devices (STA) connected to the access point\n \\param macs Returns the mac addresses of devies (STA) connected to the access point.\n The supplied buffer should have enough room for 6 bytes per mac address.\n Call \\ref cyw43_wifi_ap_get_max_stas to determine how many mac addresses can be returned."]
    pub fn cyw43_wifi_ap_get_stas(self_: *mut cyw43_t, num_stas: *mut cty::c_int, macs: *mut u8);
}
extern "C" {
    #[doc = " \\brief Initialise the IP stack\n\n This method must be provided by the network stack interface\n It is called to initialise the IP stack.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface used, either CYW43_ITF_STA or CYW43_ITF_AP"]
    pub fn cyw43_cb_tcpip_init(self_: *mut cyw43_t, itf: cty::c_int);
}
extern "C" {
    #[doc = " \\brief Deinitialise the IP stack\n\n This method must be provided by the network stack interface\n It is called to close the IP stack and free resources.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface used, either CYW43_ITF_STA or CYW43_ITF_AP"]
    pub fn cyw43_cb_tcpip_deinit(self_: *mut cyw43_t, itf: cty::c_int);
}
extern "C" {
    #[doc = " \\brief Notify the IP stack that the link is up\n\n This method must be provided by the network stack interface\n It is called to notify the IP stack that the link is up.\n This can, for example be used to request an IP address via DHCP.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface used, either CYW43_ITF_STA or CYW43_ITF_AP"]
    pub fn cyw43_cb_tcpip_set_link_up(self_: *mut cyw43_t, itf: cty::c_int);
}
extern "C" {
    #[doc = " \\brief Notify the IP stack that the link is down\n\n This method must be provided by the network stack interface\n It is called to notify the IP stack that the link is down.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface used, either CYW43_ITF_STA or CYW43_ITF_AP"]
    pub fn cyw43_cb_tcpip_set_link_down(self_: *mut cyw43_t, itf: cty::c_int);
}
extern "C" {
    #[doc = " \\brief Get the link status\n\n Returns the status of the link which is a superset of the wifi link status returned by \\ref cyw43_wifi_link_status\n \\note If the link status is negative it indicates an error\n\n link status        | Meaning\n -------------------|--------\n CYW43_LINK_DOWN    | Wifi down\n CYW43_LINK_JOIN    | Connected to wifi\n CYW43_LINK_NOIP    | Connected to wifi, but no IP address\n CYW43_LINK_UP      | Connect to wifi with an IP address\n CYW43_LINK_FAIL    | Connection failed\n CYW43_LINK_NONET   | No matching SSID found (could be out of range, or down)\n CYW43_LINK_BADAUTH | Authenticatation failure\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param itf the interface for which to return the link status, should be CYW43_ITF_STA or CYW43_ITF_AP\n \\return A value representing the link status"]
    pub fn cyw43_tcpip_link_status(self_: *mut cyw43_t, itf: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Set the value of the cyw43 gpio\n\n Set the value of a cyw43 gpio.\n \\note Check the datasheet for the number and purpose of the cyw43 gpios.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param gpio number of the gpio to set\n \\param val value for the gpio\n \\return 0 on success"]
    pub fn cyw43_gpio_set(self_: *mut cyw43_t, gpio: cty::c_int, val: bool) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Get the value of the cyw43 gpio\n\n Get the value of a cyw43 gpio.\n \\note Check the datasheet for the number and purpose of the cyw43 gpios.\n\n \\param self the driver state object. This should always be \\c &cyw43_state\n \\param gpio number of the gpio to get\n \\param val Returns the value of the gpio\n \\return 0 on success"]
    pub fn cyw43_gpio_get(self_: *mut cyw43_t, gpio: cty::c_int, val: *mut bool) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Initialise the Bluetooth HCI layer\n\n \\return zero on success"]
    pub fn cyw43_bluetooth_hci_init() -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Read data from the Bluetooth HCI layer\n\n \\param buf Buffer to be filled with hci data\n \\param max_size The maximum size of the buffer\n \\param len Returns the length of the data in the buffer including an initial 4 byte header. The last byte of the header is the packet type\n \\return zero on success"]
    pub fn cyw43_bluetooth_hci_read(buf: *mut u8, max_size: u32, len: *mut u32) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Write data to the Bluetooth HCI layer\n\n \\param buf Data to write\n \\param len Size of data to send. Must include a 4 byte header. The last byte of the header should be the packet type\n \\return zero on success"]
    pub fn cyw43_bluetooth_hci_write(buf: *mut u8, len: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Callback for the Bluetooth HCI layer to do processing"]
    pub fn cyw43_bluetooth_hci_process();
}
pub const ASYNC_CONTEXT_POLL: _bindgen_ty_7 = _bindgen_ty_7(1);
pub const ASYNC_CONTEXT_THREADSAFE_BACKGROUND: _bindgen_ty_7 = _bindgen_ty_7(2);
pub const ASYNC_CONTEXT_FREERTOS: _bindgen_ty_7 = _bindgen_ty_7(3);
impl ::core::ops::BitOr<_bindgen_ty_7> for _bindgen_ty_7 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _bindgen_ty_7(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for _bindgen_ty_7 {
    #[inline]
    fn bitor_assign(&mut self, rhs: _bindgen_ty_7) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<_bindgen_ty_7> for _bindgen_ty_7 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _bindgen_ty_7(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for _bindgen_ty_7 {
    #[inline]
    fn bitand_assign(&mut self, rhs: _bindgen_ty_7) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_7(pub cty::c_uint);
#[doc = " \\brief Base structure type of all async_contexts. For details about its use, see \\ref pico_async_context.\n \\ingroup pico_async_context\n\n Individual async_context_types with additional state, should contain this structure at the start."]
pub type async_context_t = async_context;
#[doc = " \\brief A \"timeout\" instance used by an async_context\n  \\ingroup pico_async_context\n\n  A \"timeout\" represents some future action that must be taken at a specific time.\n  It's methods are called from the async_context under lock at the given time\n\n \\see async_context_add_worker_at\n \\see async_context_add_worker_in_ms"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_work_on_timeout {
    #[doc = " private link list pointer"]
    pub next: *mut async_work_on_timeout,
    #[doc = " Method called when the timeout is reached; may not be NULL\n\n Note, that when this method is called, the timeout has been removed from the async_context, so\n if you want the timeout to repeat, you should re-add it during this callback\n @param context\n @param timeout"]
    pub do_work: ::core::option::Option<
        unsafe extern "C" fn(context: *mut async_context_t, timeout: *mut async_work_on_timeout),
    >,
    #[doc = " The next timeout time; this should only be modified during the above methods\n or via async_context methods"]
    pub next_time: absolute_time_t,
    #[doc = " User data associated with the timeout instance"]
    pub user_data: *mut cty::c_void,
}
#[doc = " \\brief A \"timeout\" instance used by an async_context\n  \\ingroup pico_async_context\n\n  A \"timeout\" represents some future action that must be taken at a specific time.\n  It's methods are called from the async_context under lock at the given time\n\n \\see async_context_add_worker_at\n \\see async_context_add_worker_in_ms"]
pub type async_at_time_worker_t = async_work_on_timeout;
#[doc = " \\brief A \"worker\" instance used by an async_context\n  \\ingroup pico_async_context\n\n  A \"worker\" represents some external entity that must do work in response\n  to some external stimulus (usually an IRQ).\n  It's methods are called from the async_context under lock at the given time\n\n \\see async_context_add_worker_at\n \\see async_context_add_worker_in_ms"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_when_pending_worker {
    #[doc = " private link list pointer"]
    pub next: *mut async_when_pending_worker,
    #[doc = " Called by the async_context when the worker has been marked as having \"work pending\"\n\n @param context the async_context\n @param worker the function to be called when work is pending"]
    pub do_work: ::core::option::Option<
        unsafe extern "C" fn(context: *mut async_context_t, worker: *mut async_when_pending_worker),
    >,
    #[doc = " True if the worker need do_work called"]
    pub work_pending: bool,
}
#[doc = " \\brief A \"worker\" instance used by an async_context\n  \\ingroup pico_async_context\n\n  A \"worker\" represents some external entity that must do work in response\n  to some external stimulus (usually an IRQ).\n  It's methods are called from the async_context under lock at the given time\n\n \\see async_context_add_worker_at\n \\see async_context_add_worker_in_ms"]
pub type async_when_pending_worker_t = async_when_pending_worker;
#[doc = " \\brief Implementation of an async_context type, providing methods common to that type\n \\ingroup pico_async_context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_context_type {
    pub type_: u16,
    pub acquire_lock_blocking:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut async_context_t)>,
    pub release_lock: ::core::option::Option<unsafe extern "C" fn(self_: *mut async_context_t)>,
    pub lock_check: ::core::option::Option<unsafe extern "C" fn(self_: *mut async_context_t)>,
    pub execute_sync: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut async_context_t,
            func: ::core::option::Option<unsafe extern "C" fn(param: *mut cty::c_void) -> u32>,
            param: *mut cty::c_void,
        ) -> u32,
    >,
    pub add_at_time_worker: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut async_context_t,
            worker: *mut async_at_time_worker_t,
        ) -> bool,
    >,
    pub remove_at_time_worker: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut async_context_t,
            worker: *mut async_at_time_worker_t,
        ) -> bool,
    >,
    pub add_when_pending_worker: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut async_context_t,
            worker: *mut async_when_pending_worker_t,
        ) -> bool,
    >,
    pub remove_when_pending_worker: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut async_context_t,
            worker: *mut async_when_pending_worker_t,
        ) -> bool,
    >,
    pub set_work_pending: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut async_context_t, worker: *mut async_when_pending_worker_t),
    >,
    pub poll: ::core::option::Option<unsafe extern "C" fn(self_: *mut async_context_t)>,
    pub wait_until: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut async_context_t, until: absolute_time_t),
    >,
    pub wait_for_work_until: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut async_context_t, until: absolute_time_t),
    >,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(self_: *mut async_context_t)>,
}
#[doc = " \\brief Implementation of an async_context type, providing methods common to that type\n \\ingroup pico_async_context"]
pub type async_context_type_t = async_context_type;
#[doc = " \\brief Base structure type of all async_contexts. For details about its use, see \\ref pico_async_context.\n \\ingroup pico_async_context\n\n Individual async_context_types with additional state, should contain this structure at the start."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_context {
    pub type_: *const async_context_type_t,
    pub when_pending_list: *mut async_when_pending_worker_t,
    pub at_time_list: *mut async_at_time_worker_t,
    pub next_time: absolute_time_t,
    pub flags: u16,
    pub core_num: u8,
}
extern "C" {
    #[doc = " \\brief Initialize the CYW43 architecture\n \\ingroup pico_cyw43_arch\n\n This method initializes the `cyw43_driver` code and initializes the lwIP stack (if it\n was enabled at build time). This method must be called prior to using any other \\c pico_cyw43_arch,\n \\c cyw43_driver or lwIP functions.\n\n \\note this method initializes wireless with a country code of \\c PICO_CYW43_ARCH_DEFAULT_COUNTRY_CODE\n which defaults to \\c CYW43_COUNTRY_WORLDWIDE. Worldwide settings may not give the best performance; consider\n setting PICO_CYW43_ARCH_DEFAULT_COUNTRY_CODE to a different value or calling \\ref cyw43_arch_init_with_country\n\n By default this method initializes the cyw43_arch code's own async_context by calling\n \\ref cyw43_arch_init_default_async_context, however the user can specify use of their own async_context\n by calling \\ref cyw43_arch_set_async_context() before calling this method\n\n \\return 0 if the initialization is successful, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_init() -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize the CYW43 architecture for use in a specific country\n \\ingroup pico_cyw43_arch\n\n This method initializes the `cyw43_driver` code and initializes the lwIP stack (if it\n was enabled at build time). This method must be called prior to using any other \\c pico_cyw43_arch,\n \\c cyw43_driver or lwIP functions.\n\n By default this method initializes the cyw43_arch code's own async_context by calling\n \\ref cyw43_arch_init_default_async_context, however the user can specify use of their own async_context\n by calling \\ref cyw43_arch_set_async_context() before calling this method\n\n \\param country the country code to use (see \\ref CYW43_COUNTRY_)\n \\return 0 if the initialization is successful, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_init_with_country(country: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief De-initialize the CYW43 architecture\n \\ingroup pico_cyw43_arch\n\n This method de-initializes the `cyw43_driver` code and de-initializes the lwIP stack (if it\n was enabled at build time). Note this method should always be called from the same core (or RTOS\n task, depending on the environment) as \\ref cyw43_arch_init.\n\n Additionally if the cyw43_arch is using its own async_context instance, then that instance is de-initialized."]
    pub fn cyw43_arch_deinit();
}
extern "C" {
    #[doc = " \\brief Return the current async_context currently in use by the cyw43_arch code\n \\ingroup pico_cyw43_arch\n\n \\return the async_context."]
    pub fn cyw43_arch_async_context() -> *mut async_context_t;
}
extern "C" {
    #[doc = " \\brief Set the async_context to be used by the cyw43_arch_init\n \\ingroup pico_cyw43_arch\n\n \\note This method must be called before calling cyw43_arch_init or cyw43_arch_init_with_country\n if you wish to use a custom async_context instance.\n\n \\param context the async_context to be used"]
    pub fn cyw43_arch_set_async_context(context: *mut async_context_t);
}
extern "C" {
    #[doc = " \\brief Initialize the default async_context for the current cyw43_arch type\n \\ingroup pico_cyw43_arch\n\n This method initializes and returns a pointer to the static async_context associated\n with cyw43_arch. This method is called by \\ref cyw43_arch_init automatically\n if a different async_context has not been set by \\ref cyw43_arch_set_async_context\n\n \\return the context or NULL if initialization failed."]
    pub fn cyw43_arch_init_default_async_context() -> *mut async_context_t;
}
extern "C" {
    #[doc = " \\brief Perform any processing required by the \\c cyw43_driver or the TCP/IP stack\n \\ingroup pico_cyw43_arch\n\n This method must be called periodically from the main loop when using a\n \\em polling style \\c pico_cyw43_arch (e.g. \\c pico_cyw43_arch_lwip_poll ). It\n may be called in other styles, but it is unnecessary to do so."]
    pub fn cyw43_arch_poll();
}
extern "C" {
    #[doc = " \\brief Sleep until there is cyw43_driver work to be done\n \\ingroup pico_cyw43_arch\n\n This method may be called by code that is waiting for an event to\n come from the cyw43_driver, and has no work to do, but would like\n to sleep without blocking any background work associated with the cyw43_driver.\n\n \\param until the time to wait until if there is no work to do."]
    pub fn cyw43_arch_wait_for_work_until(until: absolute_time_t);
}
extern "C" {
    #[doc = " \\brief Return the country code used to initialize cyw43_arch\n \\ingroup pico_cyw43_arch\n\n \\return the country code (see \\ref CYW43_COUNTRY_)"]
    pub fn cyw43_arch_get_country_code() -> u32;
}
extern "C" {
    #[doc = " \\brief Enables Wi-Fi STA (Station) mode.\n \\ingroup pico_cyw43_arch\n\n This enables the Wi-Fi in \\emStation mode such that connections can be made to other Wi-Fi Access Points"]
    pub fn cyw43_arch_enable_sta_mode();
}
extern "C" {
    #[doc = " \\brief Enables Wi-Fi AP (Access point) mode.\n \\ingroup pico_cyw43_arch\n\n This enables the Wi-Fi in \\em Access \\em Point mode such that connections can be made to the device by  other Wi-Fi clients\n \\param ssid the name for the access point\n \\param password the password to use or NULL for no password.\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)"]
    pub fn cyw43_arch_enable_ap_mode(
        ssid: *const cty::c_char,
        password: *const cty::c_char,
        auth: u32,
    );
}
extern "C" {
    #[doc = " \\brief Attempt to connect to a wireless access point, blocking until the network is joined or a failure is detected.\n \\ingroup pico_cyw43_arch\n\n \\param ssid the network name to connect to\n \\param pw the network password or NULL if there is no password required\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)\n\n \\return 0 if the initialization is successful, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_wifi_connect_blocking(
        ssid: *const cty::c_char,
        pw: *const cty::c_char,
        auth: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Attempt to connect to a wireless access point specified by SSID and BSSID, blocking until the network is joined or a failure is detected.\n \\ingroup pico_cyw43_arch\n\n \\param ssid the network name to connect to\n \\param bssid the network BSSID to connect to or NULL if ignored\n \\param password the network password or NULL if there is no password required\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)\n\n \\return 0 if the initialization is successful, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_wifi_connect_bssid_blocking(
        ssid: *const cty::c_char,
        bssid: *const u8,
        pw: *const cty::c_char,
        auth: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Attempt to connect to a wireless access point, blocking until the network is joined, a failure is detected or a timeout occurs\n \\ingroup pico_cyw43_arch\n\n \\param ssid the network name to connect to\n \\param pw the network password or NULL if there is no password required\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)\n\n \\return 0 if the initialization is successful, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_wifi_connect_timeout_ms(
        ssid: *const cty::c_char,
        pw: *const cty::c_char,
        auth: u32,
        timeout: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Attempt to connect to a wireless access point specified by SSID and BSSID, blocking until the network is joined, a failure is detected or a timeout occurs\n \\ingroup pico_cyw43_arch\n\n \\param ssid the network name to connect to\n \\param bssid the network BSSID to connect to or NULL if ignored\n \\param password the network password or NULL if there is no password required\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)\n\n \\return 0 if the initialization is successful, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_wifi_connect_bssid_timeout_ms(
        ssid: *const cty::c_char,
        bssid: *const u8,
        pw: *const cty::c_char,
        auth: u32,
        timeout: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Start attempting to connect to a wireless access point\n \\ingroup pico_cyw43_arch\n\n This method tells the CYW43 driver to start connecting to an access point. You should subsequently check the\n status by calling \\ref cyw43_wifi_link_status.\n\n \\param ssid the network name to connect to\n \\param pw the network password or NULL if there is no password required\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)\n\n \\return 0 if the scan was started successfully, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_wifi_connect_async(
        ssid: *const cty::c_char,
        pw: *const cty::c_char,
        auth: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Start attempting to connect to a wireless access point specified by SSID and BSSID\n \\ingroup pico_cyw43_arch\n\n This method tells the CYW43 driver to start connecting to an access point. You should subsequently check the\n status by calling \\ref cyw43_wifi_link_status.\n\n \\param ssid the network name to connect to\n \\param bssid the network BSSID to connect to or NULL if ignored\n \\param password the network password or NULL if there is no password required\n \\param auth the authorization type to use when the password is enabled. Values are \\ref CYW43_AUTH_WPA_TKIP_PSK,\n             \\ref CYW43_AUTH_WPA2_AES_PSK, or \\ref CYW43_AUTH_WPA2_MIXED_PSK (see \\ref CYW43_AUTH_)\n\n \\return 0 if the scan was started successfully, an error code otherwise \\see pico_error_codes"]
    pub fn cyw43_arch_wifi_connect_bssid_async(
        ssid: *const cty::c_char,
        bssid: *const u8,
        pw: *const cty::c_char,
        auth: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Set a GPIO pin on the wireless chip to a given value\n \\ingroup pico_cyw43_arch\n \\note this method does not check for errors setting the GPIO. You can use the lower level \\ref cyw43_gpio_set instead if you wish\n to check for errors.\n\n \\param wl_gpio the GPIO number on the wireless chip\n \\param value true to set the GPIO, false to clear it."]
    pub fn cyw43_arch_gpio_put(wl_gpio: uint, value: bool);
}
extern "C" {
    #[doc = " \\brief Read the value of a GPIO pin on the wireless chip\n \\ingroup pico_cyw43_arch\n \\note this method does not check for errors setting the GPIO. You can use the lower level \\ref cyw43_gpio_get instead if you wish\n to check for errors.\n\n \\param wl_gpio the GPIO number on the wireless chip\n \\return true if the GPIO is high, false otherwise"]
    pub fn cyw43_arch_gpio_get(wl_gpio: uint) -> bool;
}
